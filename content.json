{"meta":{"title":"purplewall1206 blog","subtitle":"","description":"something about kernel & programming","author":"purplewall1206","url":"https://www.zi-c.wang","root":"/"},"pages":[{"title":"","date":"2020-11-15T10:43:54.047Z","updated":"2020-11-15T10:43:54.047Z","comments":true,"path":"404.html","permalink":"https://www.zi-c.wang/404.html","excerpt":"","text":"+layout: false +--- 404"},{"title":"categories","date":"2020-11-15T10:40:07.000Z","updated":"2020-11-15T10:43:51.827Z","comments":false,"path":"categories/index.html","permalink":"https://www.zi-c.wang/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-11-15T10:38:51.000Z","updated":"2020-11-15T10:38:51.790Z","comments":true,"path":"about/index.html","permalink":"https://www.zi-c.wang/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-15T10:39:13.000Z","updated":"2020-11-15T10:43:56.047Z","comments":false,"path":"tags/index.html","permalink":"https://www.zi-c.wang/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"二叉树非递归遍历","slug":"二叉树非递归遍历","date":"2020-11-24T02:28:59.000Z","updated":"2020-11-24T05:43:42.653Z","comments":true,"path":"2020/11/24/二叉树非递归遍历/","link":"","permalink":"https://www.zi-c.wang/2020/11/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/","excerpt":"二叉树非递归遍历总是容易忘，这次从原理出发理解一次。 12345 1 &#x2F; \\ 2 3 &#x2F; \\ &#x2F;4 5 6","text":"二叉树非递归遍历总是容易忘，这次从原理出发理解一次。 12345 1 &#x2F; \\ 2 3 &#x2F; \\ &#x2F;4 5 6 preorder123handle(p-&gt;val);preorder(root-&gt;left);preorder(root-&gt;right); 1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6 先序输出顺序是中左右，因此首先输出，其次要保存左子树，穷尽左子树之后弹出节点，最后输出右子树 1234567891011121314stack&lt;TreeNode*&gt; st;TreeNode* p &#x3D; root;while (p !&#x3D; NULL || !st.empty()）&#123; while (p !&#x3D; NULL) &#123; handle(p-&gt;val); st.push(p); p &#x3D; p-&gt;left; &#125; if (!st.empty()) &#123; p &#x3D; st.top(); st.pop(); p &#x3D; p-&gt;right; &#125;&#125; inorder123inorder(p-&gt;left);handle(p-&gt;val);inorder(p-&gt;right); 4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3 中序遍历的输出顺序是左中右，和先序遍历有相似性，因为也需要先保存左子树，再弹出左子树找到中和右。 123456789101112stack&lt;TreeNode*&gt; st;TreeNode* p &#x3D; root;while (p !&#x3D; NULL || !st.empty()) &#123; st.push(p); p &#x3D; p-&gt;left;&#125;if (!st.empty()) &#123; p &#x3D; st.top(); st.pop(); handle(p-&gt;val); p &#x3D; p-&gt;right;&#125; postorder123postorder(p-&gt;left);postorder(p-&gt;right);handle(p-&gt;val); 4-&gt;5-&gt;2-&gt;6-&gt;3-&gt;1 后序遍历输出顺序是左右中，先保存左侧节点，然后检查右侧节点，当右子树为空或者已经被访问了，可以访问这个节点 12345678910111213141516171819stack&lt;TreeNode*&gt; st;TreeNode* p &#x3D; root;while (p !&#x3D; NULL || !st.empty()) &#123; while (p !&#x3D; NULL) &#123; st.push(p); p &#x3D; p-&gt;left; &#125; p &#x3D; s.top(); TreeNode* tmp &#x3D; NULL; while (!st.empty() &amp;&amp; (p-&gt;right &#x3D;&#x3D; NULL || p-&gt;right &#x3D;&#x3D; tmp)) &#123; st.pop(); if (!st.empty()) &#123; tmp &#x3D; p; p &#x3D; st.top(); &#125; &#125; if (st.emtpy()) break; p &#x3D; p-&gt;right;&#125; BFS1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 广度优先按照层次每次保存一层，当输出的时候记录当前队列长度，该长度即为上层被保存的节点数量，依次遍历即为按层次输出 12345678910111213141516queue&lt;TreeNode*&gt; q;TreeNode* p &#x3D; NULL;q.push(p);while (!q.emtpy()) &#123; int size &#x3D; q.size(); for (int i &#x3D; 0;i &lt; size;i++) &#123; p &#x3D; q.front(); q.pop(); handle(p-&gt;val); if (p-&gt;left !&#x3D; NULL) q.push(p-&gt;left); if (p-&gt;right !&#x3D; NULL) q.push(p-&gt;right); &#125; &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"},{"name":"binarytree","slug":"binarytree","permalink":"https://www.zi-c.wang/tags/binarytree/"}]},{"title":"NJU研究生通知RSS","slug":"NJU研究生通知RSS","date":"2020-11-19T06:39:45.000Z","updated":"2020-11-21T08:54:32.396Z","comments":true,"path":"2020/11/19/NJU研究生通知RSS/","link":"","permalink":"https://www.zi-c.wang/2020/11/19/NJU%E7%A0%94%E7%A9%B6%E7%94%9F%E9%80%9A%E7%9F%A5RSS/","excerpt":"NJU-notifeedNanjing University notification feed https://github.com/purplewall1206/NJU-notifeed 直接订阅：http://idcvz.zi-c.wang:8000/rss","text":"NJU-notifeedNanjing University notification feed https://github.com/purplewall1206/NJU-notifeed 直接订阅：http://idcvz.zi-c.wang:8000/rss 主要收集以下两个网站的最新通知，生成统一的feed提供给本地部署的RSS阅读器（i.e. Thunderbird） https://grawww.nju.edu.cn http://pyb.nju.edu.cn/ 设计思路使用requests和beautifulsoup4制作爬虫，获取通知页面的信息条目news 使用PyRSS2Gen生成feed条目，并写到feed.xml文件中（这里有个问题，lib好像只提供文件写入函数了，暂时没找到其他的output方式） 使用Flask构建RESTful API，访问 http://url/rss 获取feed 使用多线程其中一个线程运行爬虫，主线程（flask单线程）维护API 文件结构： news.py news struct，存储消息的属性 crawlerPYB/GRA.py 两个网站的爬虫策略 __init__.py 主函数，通过多线程的方式每小时更新一次feed。 logging.txt 记录调用日志 requirement.txt 安装的python lib，sudo pip install -r requirement.txt ubuntu 运行面对的问题 sudo apt-get install python3-html5lib 启动问题加入description信息获取之后，服务器往往无法立即反应，需要等到logging中显示出爬虫已经完全获取信息的日志之后，才能通过网站访问。需要处理一下这个问题，应该是global被锁住，服务器比爬虫先启动导致的。","categories":[{"name":"python","slug":"python","permalink":"https://www.zi-c.wang/categories/python/"},{"name":"rss","slug":"python/rss","permalink":"https://www.zi-c.wang/categories/python/rss/"},{"name":"github","slug":"python/rss/github","permalink":"https://www.zi-c.wang/categories/python/rss/github/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.zi-c.wang/tags/python/"},{"name":"rss","slug":"rss","permalink":"https://www.zi-c.wang/tags/rss/"},{"name":"github","slug":"github","permalink":"https://www.zi-c.wang/tags/github/"},{"name":"NJU","slug":"NJU","permalink":"https://www.zi-c.wang/tags/NJU/"}]},{"title":"Raspberry Pi 内核编译","slug":"Raspberry-Pi-内核编译","date":"2020-11-16T12:06:10.000Z","updated":"2020-11-16T12:10:02.276Z","comments":true,"path":"2020/11/16/Raspberry-Pi-内核编译/","link":"","permalink":"https://www.zi-c.wang/2020/11/16/Raspberry-Pi-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/","excerpt":"我的版本 : 树莓派3 1.内核获取1.1.软件下载sudo apt install git bc bison flex libssl-dev make","text":"我的版本 : 树莓派3 1.内核获取1.1.软件下载sudo apt install git bc bison flex libssl-dev make 关于libssl-dev的小问题12345sudo apt-get install aptitudedpkg -l *libssl*sudo aptitude install libssl-dev 1.2.源码获取git clone --depth=1 https://github.com/raspberrypi/linux 2.内核编译预设环境 1234cd linuxKERNEL&#x3D;kernel7make bcm2709_defconfig或者 zcat &#x2F;proc&#x2F;config.gz &gt; .config #从现在原有版本的内核中复制配置文件 编译 123456make -j4 zImage modules dtbssudo make modules_installsudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;*.dtb &#x2F;boot&#x2F;sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;*.dtb* &#x2F;boot&#x2F;overlays&#x2F;sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;README &#x2F;boot&#x2F;overlays&#x2F;sudo cp arch&#x2F;arm&#x2F;boot&#x2F;zImage &#x2F;boot&#x2F;$KERNEL.img 3.更换内核修改 /boot/config.txt 文件中内容 kernel=kernel-myconfig.img myconfig的版本在/lib/modules/ 文件夹中。 4.参考文件DOCUMENTATION &gt; LINUX &gt; KERNEL &gt; BUILDING","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"},{"name":"raspberryPi","slug":"kernel/raspberryPi","permalink":"https://www.zi-c.wang/categories/kernel/raspberryPi/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"raspberryPi","slug":"raspberryPi","permalink":"https://www.zi-c.wang/tags/raspberryPi/"}]},{"title":"三剑客sed/awk/grep常用速查","slug":"三剑客sed-awk-grep常用速查","date":"2020-11-16T06:22:23.000Z","updated":"2020-11-16T06:24:22.817Z","comments":true,"path":"2020/11/16/三剑客sed-awk-grep常用速查/","link":"","permalink":"https://www.zi-c.wang/2020/11/16/%E4%B8%89%E5%89%91%E5%AE%A2sed-awk-grep%E5%B8%B8%E7%94%A8%E9%80%9F%E6%9F%A5/","excerpt":"sed和awk的区别，都是按行读入，但是awk会拆分行里面的元素，sed则直接用正则做匹配，基本上sed可以做到的awk都可以。 awkawk &#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39; netstat.txt awk 使用print和printf打印每行中按列分布的元素。 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot;&#39; netstat.txt 过滤记录 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot; || NR==1 &#123;printf &quot;%02s %s %-20s %-20s %s\\n&quot;,NR, FNR, $4,$5,$6&#125;&#39; netstat.txt 其中NR，FNR为内建变量","text":"sed和awk的区别，都是按行读入，但是awk会拆分行里面的元素，sed则直接用正则做匹配，基本上sed可以做到的awk都可以。 awkawk &#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39; netstat.txt awk 使用print和printf打印每行中按列分布的元素。 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot;&#39; netstat.txt 过滤记录 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot; || NR==1 &#123;printf &quot;%02s %s %-20s %-20s %s\\n&quot;,NR, FNR, $4,$5,$6&#125;&#39; netstat.txt 其中NR，FNR为内建变量 $0 当前记录（这个变量中存放着整个行的内容） $1~$n 当前记录的第n个字段，字段间由FS分隔 FS 输入字段分隔符 默认是空格或Tab NF 当前记录中的字段个数，就是有多少列 NR 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。 FNR 当前记录数，与NR不同的是，这个值会是各个文件自己的行号 RS 输入的记录分隔符， 默认为换行符 OFS 输出字段分隔符， 默认也是空格 ORS 输出的记录分隔符，默认为换行符 FILENAME 当前输入文件的名字 awk &#39;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1,$3,$6&#125;&#39; /etc/passwd 指定分隔符 awk &#39;$6 ~ /E/ || NR==1 &#123;print NR, $4,$5,$6&#125;&#39; netstat.txt ~表示开始，//表示匹配，这行命令表示匹配第六个元素开始包含E的行和第一行，然后输出行数和第456个元素。 awk &#39;NR!=1&#123;print $4,$5 &gt; $6&#125;&#39; netstat.txt 不处理第一行，按照第六列元素分类拆分成若干个文件，文件的内容是第45列元素。 awk 脚本123456789101112131415161718192021222324#!&#x2F;bin&#x2F;awk -f# 运行前BEGIN &#123; math &#x3D; 0 english &#x3D; 0 computer &#x3D; 0 printf &quot;NAME NO. MATH ENGLISH COMPUTER TOTAL\\n&quot; printf &quot;---------------------------------------------\\n&quot;&#125;# 运行中&#123; math +&#x3D; $3 english +&#x3D; $4 computer +&#x3D; $5 printf &quot;%-6s %-6s %4d %8d %8d %8d\\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5&#125;# 运行之后END &#123; printf &quot;---------------------------------------------\\n&quot; printf &quot; TOTAL:%10d %8d %8d \\n&quot;, math, english, computer printf &quot;AVERAGE:%10.2f %8.2f %8.2f\\n&quot;, math&#x2F;NR, english&#x2F;NR, computer&#x2F;NR&#125; awk -v val=$x &#39;&#123;print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]&#125;&#39; OFS=&quot;\\t&quot; score.txt 其中x，y为环境变量，为了使用环境变量需要 -v echo $PATH| awk &#39;BEGIN&#123;RS=&quot;:&quot;&#125;&#123;print NR,$0&#125;&#39; 把单行拆分成多行 sedsed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件] e&lt;script&gt;或–expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。 f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。 h或–help 显示帮助。 n或–quiet或–silent 仅显示script处理后的结果。 V或–version 显示版本信息。 a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～ s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ sed &quot;s/my/ppw &#39;s/g&quot; pets.txt 把pets.txt文件的my改成ppw’s，并不修改文件。/g 表示一行上的替换所有的匹配 加入-i sed -i &quot;s/my/ppw &#39;s/g&quot; pets.txt可以直接修改文件 sed &#39;s/^/---/g&#39; pets.txt 在开头加上— sed &#39;s/$/---/g&#39; pets.txt 在结尾加上— 同理类似的有： \\&lt; 表示词首。 如：&lt;abc 表示以 abc 为首的詞。 \\&gt; 表示词尾。 如：abc&gt; 表示以 abc 結尾的詞。 . 表示任何单个字符。 * 表示某个字符出现了0次或多次。 字符集合。 如：[abc] 表示匹配a或b或c，还有 [a-zA-Z] 表示匹配所有的26个字符。如果其中有^表示反，如 [^a] 表示非a的字符 sed &#39;s/&lt;[^&gt;]*&gt;//g&#39; html.txt 取消html文件中的&lt;&gt;tags,不能使用&#39;s/&lt;.*&gt;&#39;//g，因为会贪婪匹配掉第一个《和最后一个》之间所有的内容，现在给出的示例是匹配除了&gt;意外的字符。 sed &#39;3s/my/your/g&#39; pets.txt 和 sed &#39;3,6s/my/your/g&#39; pets.txt，分别表示匹配第三行和第三到六行。 sed &#39;s/s/S/1&#39; pets.txt 匹配每一行的第一个s sed &#39;1,3s/my/your/g; 3,$s/This/That/g&#39; pets.txt 匹配多个 sed &#39;s/my/[&amp;]/g&#39; pets.txt 使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西 sed &#39;s/This is my \\([^,]*\\),.*is \\(.*\\)/\\1:\\2/g&#39; my.txt 圆括号括起来的正则表达式所匹配的字符串会可以当成变量来使用，sed中使用的是\\1,\\2… sed &#39;N;s/my/your/&#39; pets.txt 原文本中的偶数行纳入奇数行匹配，而s只匹配并替换一次，所以最后只有奇数行被修改。 N命令把下一行的内容纳入当成缓冲区做匹配。 sed &quot;1 i This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 和 sed &quot;$ a This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 命令i和a分别表示insert 和 append，添加行 sed &quot;/my/a ----&quot; my.txt 在每行结尾都添加 —- sed &quot;2 c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 和 sed &quot;/fish/c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 命令c表示替换，这两个命令分别表示替换第二行和有’fish’存在的那一行。 sed &#39;/fish/d&#39; my.txt 和 sed &#39;2d&#39; my.txt 和 sed &#39;2,$d&#39; my.txt 命令d表示删除匹配行，这三个命令分别表示删除有fish的一行，删除第二行和删除第二到最后的所有行。 sed -n &#39;/dog/,/fish/p&#39; my.txt 命令-n表示只显示处理后的结果，命令p表示打印，图中命令表示打印有dog的一行和有fish的一行。 grepgrep -i -c &#39;.*ret.*&#39; linux-exec.s 统计内核二级制文件中ret命令的个数，不区分大小写，直接输出匹配行数。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/categories/linux/"},{"name":"bash","slug":"linux/bash","permalink":"https://www.zi-c.wang/categories/linux/bash/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://www.zi-c.wang/tags/bash/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"tool","slug":"tool","permalink":"https://www.zi-c.wang/tags/tool/"}]},{"title":"kernel contribution 统计","slug":"kernel-contribution-统计","date":"2020-11-16T06:19:37.000Z","updated":"2020-11-16T06:24:36.180Z","comments":true,"path":"2020/11/16/kernel-contribution-统计/","link":"","permalink":"https://www.zi-c.wang/2020/11/16/kernel-contribution-%E7%BB%9F%E8%AE%A1/","excerpt":"保存lwn.net发布的新版本开发统计文章，目前来看还是华为最屌。 Development statistics for the 5.0 kernelAs of this writing, 12,517 non-merge changesets have been pulled into the mainline repository for the 5.0 release Some 5.5 kernel development statistics5.5 saw the merging of 14,350 non-merge changesets from 1,885 developers","text":"保存lwn.net发布的新版本开发统计文章，目前来看还是华为最屌。 Development statistics for the 5.0 kernelAs of this writing, 12,517 non-merge changesets have been pulled into the mainline repository for the 5.0 release Some 5.5 kernel development statistics5.5 saw the merging of 14,350 non-merge changesets from 1,885 developers Some 5.6 kernel development statistics12,665 non-merge changesets had been accepted from 1,712 developers Development statistics for the 5.7 kernelWork on 5.7 arrived in the form of 13,901 non-merge changesets contributed by 1,878 developers;","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"lwn.net","slug":"lwn-net","permalink":"https://www.zi-c.wang/tags/lwn-net/"}]},{"title":"io_uring 系统性整理","slug":"io-uring-系统性整理","date":"2020-11-15T11:42:54.000Z","updated":"2020-11-15T11:52:18.240Z","comments":true,"path":"2020/11/15/io-uring-系统性整理/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/","excerpt":"io_uring 系统性整理 io_uring 系统性整理 I/O 模型 comparison Asynchronous I/O io_uring 总结邮件 这里有个误解，I/O模型其实是针对整个系统的所有I/O操作的，但是平时很少对文件系统使用异步读写，同步或直接映射的情况比较多。更别提多路复用了，这个机制基本只用在network中。 lwn Kernel article index","text":"io_uring 系统性整理 io_uring 系统性整理 I/O 模型 comparison Asynchronous I/O io_uring 总结邮件 这里有个误解，I/O模型其实是针对整个系统的所有I/O操作的，但是平时很少对文件系统使用异步读写，同步或直接映射的情况比较多。更别提多路复用了，这个机制基本只用在network中。 lwn Kernel article index I/O 模型 blocking I/O 同步阻塞，直到内核收到数据返回给线程。 nonblocking I/O 同步不阻塞，但是如果内核没收到数据会返回一个 EWOULDBLOCK I/O multiplexing (select and poll) 异步阻塞，使用selet（using select requires two system calls instead of one）、poll系统调用循环等待socket可读时，使用recvfrom收取数据。主要优势在于能够在单线程监控多个文件描述符fd。 初次之外还有epoll,使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次 优点有： 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。 这种方法基本等价于 一个进程创建多个线程，每个线程维护一个blocking I/O signal driven I/O (SIGIO) 非阻塞，通过sigaction系统调用安装signal handler，当datagram数据报可读时，向I/O接收进程发送SIGIO信号，可以在signal handler里面读这个数据，然后通知main loop；也可以先通知main loop，让main loop去读这个数据。 asynchronous I/O (the POSIX aio_functions) 异步非阻塞，也是调用aio_read之后立刻返回，和SIGIO的区别是直到接收到数据并将数据传输到用户时，才产生完成信号。 comparison 参考:io models彻底理解 IO多路复用聊聊IO多路复用之select、poll、epoll详解 Asynchronous I/O首先确定这里的AIO是内核态的，由libaio封装的系统调用运行库，而不是glibc用户态AIO，使用多线程模拟的。 linux kernel AIO的主要缺点在于项目泥潭，bug太多，项目设计和领导更换，而且实现比较复杂，直到现在只能比较稳定支持以O_DIRECT（直接映射修改，bypass page cache）方式打开文件，需要自己处理buffer、offset对其这些问题，不能用page cache层以bio的方式读写block数据。 因为使用page buffer层时涉及到block driver里面的队列，相比O_DIRECT多出很多阻塞点，因此实现起来比较令人恼火。因此这个项目根本就没实现起来。 因此io_uring的主要对比对象是多路复用和DPDK、SPDK，是一个事实上的新异步IO API Linux AIO does suffer from a number of ailments. The subsystem is quite complex and requires explicit code in any I/O target for it to be supported. 实现不了的地方基本上都开一个kernel thread跑，感觉开销更大了。 参考：Linux Asynchronous I/O Fixing asynchronous I/O, againLinux kernel AIO这个奇葩2017Toward non-blocking asynchronous I/O io_uring参考：Kernel Recipes 2019 - Faster IO through io_uring20190115Ringing in a new asynchronous I/O API20200715Operations restrictions for io_uring20200320Automatic buffer selection for io_uring20200124The rapid growth of io_uring20200511Hussain: Lord of the io_uringLinux异步IO新时代：io_uring20200716io_uring: add restrictions to support untrusted applications and guests20200225io_uring support for automatic buffersio_uring（1） – 我们为什么会需要 io_uringlinux “io_uring” 提权漏洞(CVE-2019-19241)分析io_uring（2）- 从创建必要的文件描述符 fd 开始 uring这个词没有翻译”something that looks a little less like io_urine”. 这是一个为了高速I/O提出的新的一系列系统调用，简单来说就是新的ring buffer。之前的异步I/O策略是libaio，这个机制饱受诟病，于是Jens Axboe直接提出io_uring，性能远超aio。 从5.7开始超出纯I/O的范畴，io_uring开始为一部接口提供FAST POLL机制，用户无需再像使用select、event poll等多路复用机制来监听文件句柄，只要把读写请求直接丢到io_uring的submission queue中提交 ，当文件句柄不可读写时，内核会主动添加poll handler，当文件句柄可读写时主动调用poll handler再次下发读写请求，从而减少系统调用次数提高性能 这是一个线程粒度的异步I/O机制，分为 submission queue和completion queue，在使用系统调用申请之后，直接返回可以使用mmap映射的file discriptor。 应用程序可以直接使用mmap映射的两个ring buffer直接与内核进行I/O数据传输交换，减少了大量系统调用的开销。 具体流程： setup int io_uring_setup(int entries, struct io_uring_params *params); 其中entries表示submission and completion queues两个队列的大小 param中设置两个队列和具体的状态 12345678struct io_uring_params &#123; __u32 sq_entries; __u32 cq_entries; __u32 flags; __u16 resv[10]; struct io_sqring_offsets sq_off; struct io_cqring_offsets cq_off;&#125;; 最终实现目的通过file descriptor与内核共享ring buffer 123456789101112subqueue &#x3D; mmap(0, params.sq_off.array + params.sq_entries*sizeof(__u32), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_SQ_RING);sqentries &#x3D; mmap(0, params.sq_entries*sizeof(struct io_uring_sqe), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_SQES);cqentries &#x3D; mmap(0, params.cq_off.cqes + params.cq_entries*sizeof(struct io_uring_cqe), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_CQ_RING); 相关资料：Ringing in a new asynchronous I/O APIThe rapid growth of io_uring 12345678910111213141516171819202122232425262728293031323334#include &lt;liburing.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main()&#123; struct io_uring ring; io_uring_queue_init(32, &amp;ring, 0); struct io_uring_sqe *sqe &#x3D; io_uring_get_sqe(&amp;ring); int fd &#x3D; open(&quot;&#x2F;home&#x2F;carter&#x2F;test.txt&quot;, O_WRONLY | O_CREAT); struct iovec iov &#x3D; &#123; .iov_base &#x3D; &quot;Hello world&quot;, .iov_len &#x3D; strlen(&quot;Hello world&quot;), &#125;; io_uring_prep_writev(sqe, fd, &amp;iov, 1, 0); io_uring_submit(&amp;ring); struct io_uring_cqe *cqe; for (;;) &#123; io_uring_peek_cqe(&amp;ring, &amp;cqe); if (!cqe) &#123; puts(&quot;Waiting...&quot;); &#x2F;&#x2F; accept 新连接，做其他事 &#125; else &#123; puts(&quot;Finished.&quot;); break; &#125; &#125; io_uring_cqe_seen(&amp;ring, cqe); io_uring_queue_exit(&amp;ring);&#125; 总结邮件今天重新思考了一下IO模型，并阅读了io_uring和多路复用相关代码，感觉突然想通了。io_uring取代了AIO而不是取代了usercopy，usercopy部署的安全策略未必适用擅长传输大量数据的io_uring，这个工作可以推后再进行。具体如下。 一、将I/O模型的设计和实现分离 I/O在操作系统中含义包括与I/O设备通信和输入输出数据，I/O模型是针对第一种含义提出的解决方案。 linux在实现I/O的过程中参考了这些模型进行实现，但并没有在同一层次进行实现。例如LKM开发中定义的file_operations实际只包括 read（同步）/read_iter（异步）/mmap/poll 等函数指针，在I/O模型中的阻塞同步和非阻塞同步的情况可以通过使用read/read_iter 附加O_NONBLOCK的方式实现。 select epoll 多路复用和AIO这些I/O模型，则是分别在与之相同或不同的层次对底层函数进行封装。 例如 select 系统调用是在内核层通过vfs_poll遍历相关的file_descriptor，glibc实现的AIO是在用户空间多线程调用这些阻塞/非阻塞的同步/异步系统调用，epoll（更像是一个通知机制）是将select/poll中需要每次都传递的file descriptor都保存在内核中，减少了usercopy；通过event监听callback进行通知，减少了对fd的遍历开销。 二、思考io_uring的设计和实现 io_uring的设计借鉴了以上的优点，在内核空间通过kthread实现对阻塞读写任务的托管，并加入了zero copy特性，开发者可以通过一次系统调用唤醒线程一直向共享ringbuffer中写数据，而不是每次写数据都需要系统调用，这在内核和用户通信范畴内很大程度上减少了系统调用的次数，消除了usercopy的负担。 但无法否认io_uring是对下层file_operations的封装，下层函数又是device driver file_operations的封装（甚至对buffer I/O中间还有一层page cache、一层block layer、一层I/O schedule），因此io_uring在许多情况无法获得SPDK用户空间直通driver的性能优势。 三、对安全问题的思考 我目前理解的安全风险主要来自于usercopy造成的out-of-bound、information/pointer leakage和race情况，尤其是struct结构可能存在的函数/数据指针，但是io_uring消除掉的usercopy主要负责大量I/O数据的传输，而非带有指针的控制数据结构（io_uring中的控制数据也在用copy_*_user传输，如图），因此对安全问题的认识比我预期要复杂一些（主要问题可能是OOB和Iago攻击），需要加深对漏洞形式的理解，但好处是急迫程度下降了。 我只能继续积累漏洞阅读量提升认知水平，思考copy_*_user可以部署的安全机制和策略。 四、总结 我这阶段应该继续把重点放在kernel extension问题的描述上，对这个问题我已经基本有了一定想法，大致是将威胁模型定位为kernel rootkits，通过修改页表或切换地址空间构建运行时沙箱，使用可信基截获、保护gateway，使用hook方式监控driver相关函数和数据I/O。可以将性能的提升和对DPDK/SPDK使用的UIO和VFIO保护作为贡献点（这可能是这次突发奇想的意外收获），现在面临的问题是不确定相关方案是否有实现、近期driver保护方案相关只有四篇。","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"io_uring","slug":"io-uring","permalink":"https://www.zi-c.wang/tags/io-uring/"},{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"}]},{"title":"eBPF 简介","slug":"eBPF-简介","date":"2020-11-15T11:17:06.000Z","updated":"2020-11-15T11:52:20.424Z","comments":true,"path":"2020/11/15/eBPF-简介/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/eBPF-%E7%AE%80%E4%BB%8B/","excerpt":"eBPF eBPF 1. 简介 2. 参考材料 3. in-kernel virtual machine 4. JIT just-in-time compile 5. kprobe 实现原理 ebpf summit 2020峰会 这个有时间应该看一下 1. 简介eBPF由BPF（berkeley packet filter发展而来，BPF现在也叫classic-BPF由于区别BPF），到目前为止被引入了linux内核并且使用了JIT just in time comilper进行加速，类似于浏览器的javascript脚本执行语言。 eBPF定义了一个内核内运行的虚拟机 使用bcc进行bpf的开发，bcc和bpftrace项目的维护放在 iovisor","text":"eBPF eBPF 1. 简介 2. 参考材料 3. in-kernel virtual machine 4. JIT just-in-time compile 5. kprobe 实现原理 ebpf summit 2020峰会 这个有时间应该看一下 1. 简介eBPF由BPF（berkeley packet filter发展而来，BPF现在也叫classic-BPF由于区别BPF），到目前为止被引入了linux内核并且使用了JIT just in time comilper进行加速，类似于浏览器的javascript脚本执行语言。 eBPF定义了一个内核内运行的虚拟机 使用bcc进行bpf的开发，bcc和bpftrace项目的维护放在 iovisor 2. 参考材料 A thorough introduction to eBPF A JIT for packet filters BPF: the universal in-kernel virtual machine LECTURE BPF: Tracing and More TUTORIAL Learn eBPF Tracing: Tutorial and Examples TUTORIAL The bpftrace One-Liner Tutorial TUTORIAL bpftrace Reference Guide Linux内核攻击面之eBPF模块 3. in-kernel virtual machineThings started to change in the 3.0 release, when Eric Dumazet added a just-in-time compiler to the BPF interpreter. In the 3.4 kernel, the “secure computing” (seccomp) facility was enhanced to support a user-supplied filter for system calls; that filter, too, is written in the BPF language. 4. JIT just-in-time compileEric Dumazet’s patch is a fundamental change: it puts a just-in-time compiler into the kernel to translate BPF code directly into the host system’s assembly code. The simplicity of the BPF machine makes the JIT translation relatively simple; every BPF instruction maps to a straightforward x86 instruction sequence. 5. kprobe 实现原理这里仅做猜测，应该是直接使用kprobe技术，int3 打断点到指定位置，截取控制流到相应的probe callback 函数。","categories":[{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/categories/eBPF/"}],"tags":[{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/tags/eBPF/"}]},{"title":"内核近期改变","slug":"内核近期改变","date":"2020-11-15T11:09:13.000Z","updated":"2020-11-15T11:52:26.240Z","comments":true,"path":"2020/11/15/内核近期改变/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/%E5%86%85%E6%A0%B8%E8%BF%91%E6%9C%9F%E6%94%B9%E5%8F%98/","excerpt":"内核近期改变 内核近期改变 ioctl 1.原始版本的ioctl 2.内核改进后的ioctl 3.在编写过程中的处理办法 4. 原因分析 异步I/O read_iter 1.具体变化 2.原因分析 3.问题 timer计时器发生改变 block 驱动在5.0后进行了非常大的变化 原因 blk-mq 设计了两层队列 在架构层面 具体到函数 内核计时接口发生变化 系统调用初始化接口变化（未解决） 文件系统减少定义数量 （未解决） jprobe 被取消","text":"内核近期改变 内核近期改变 ioctl 1.原始版本的ioctl 2.内核改进后的ioctl 3.在编写过程中的处理办法 4. 原因分析 异步I/O read_iter 1.具体变化 2.原因分析 3.问题 timer计时器发生改变 block 驱动在5.0后进行了非常大的变化 原因 blk-mq 设计了两层队列 在架构层面 具体到函数 内核计时接口发生变化 系统调用初始化接口变化（未解决） 文件系统减少定义数量 （未解决） jprobe 被取消 ioctl1.原始版本的ioctl1int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long); 2.内核改进后的ioctl123long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);long (*compat_ioctl) (struct file *, unsigned int, unsigned long); 3.在编写过程中的处理办法 将原先的写的 ioctl 函数声明给改成下面的 unlocked_ioctl 或者 compat_ioctl, 在 file_operations 结构体的初始化中也是一样. 修改为unlocked_ioctl 或者 compat_ioctl, 注意参数的兼容性问题, 新的ioctl() 接口没有 struct inode* 参数, 如果ioctl 接口中使用了 inode, 因此需要通过其他方式获取 inode 123456789101112131415161718192021#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36)static int XXX_ioctl( struct inode *indoe, struct file *filp, unsigned int cmd, unsigned long arg)&#123;#else&#x2F;&#x2F;long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);&#x2F;&#x2F;long (*compat_ioctl) (struct file *, unsigned int cmd, unsigned long arg)static long XXX_unlocked_ioctl( struct file *filp, unsigned int cmd, unsigned long arg)&#123; &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;f_dentry-&gt;d_inode; &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;d_inode; struct inode *inode &#x3D; inode &#x3D; file_inode(filp);#endif &#x2F;* 此处是ioctl() 函数结构的具体实现 *&#x2F;&#125; 同理，file_operations中也进行同样修改。 123456789101112static struct file_operations fpga_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; fpga_open, .read &#x3D; fpga_read, .write &#x3D; fpga_write, .llseek &#x3D; fpga_llseek,#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36) .ioctl &#x3D; XXX_ioctl,#else .unlocked_ioctl &#x3D; XXX_unlocked_ioctl,#endif&#125;; 4. 原因分析file_operations (include/linux/fs.h) 结构变化,ioctl本身并不安全，且之前的ioctl使用了大内核锁延迟太大，因此进行修改。具体内容见The new way of ioctl() 异步I/O read_iter1.具体变化file_operations (include/linux/fs.h) 结构变化，导致 read_iter 和 write_iter 负责设备驱动的异步读写，取代了之前的 aio_read 和 aio_write,只需要将资料中二者进行转换即可。 2.原因分析The iov_iter interface iov_iter 功能增强了，并且试图合并 read(write)_iter 和 splice_read(write)，不过截至2020年5月13日来看这俩似乎还存在着 3.问题fs/ramfs/file-mmu.c 中为什么 file_operations 里面没有定义 read 和 write， 而只有异步I/O。 timer计时器发生改变Improving the kernel timers API用 timer_setup 替换了 init_timer,替换内核版本为4.14(2017)，属于较新的替换 1234567891011#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0) init_timer(&amp;dev-&gt;getIntrTimer); dev-&gt;getIntrTimer.data &#x3D; (unsigned long) dev; dev-&gt;getIntrTimer.function &#x3D; GetIntrTimerCallback; &#x2F;* ... *&#x2F; add_timer(&amp;dev-&gt;getIntrTimer);#else timer_setup(&amp;dev-&gt;getIntrTimer, GetIntrTimerCallback, 0); &#x2F;* the third argument may include TIMER_* flags *&#x2F; &#x2F;* ... *&#x2F;#endif callback function的变化 参数类型发生变化，否则会编译失败 12345678910#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0)void GetIntrTimerCallback(unsigned long devAddr)&#123; myDevice *dev &#x3D; (myDevice *) devAddr;#elsevoid GetIntrTimerCallback(struct timer_list *t)&#123; myDevice *dev &#x3D; from_timer(dev, t, getIntrTimer);#endif &#x2F;* Do something with &quot;dev&quot; *&#x2F; block 驱动在5.0后进行了非常大的变化In kernel V5 blk_fetch_request() and blk_init_queue() gone. Now What? Linux Kernel 5.0 – we write Simple Block Device under blk-mq block: remove __bio_kmap_atomic 内核工匠 公众号 Multiqueue架构分析 block 驱动在5.0后进行了非常大的变化 原因是使用了 multi-queue block layer 即 blk-mq 完全取代了之前的 blk-sq（single-queue），因为从前的IO速度瓶颈在硬件方面，因此可以使用单一队列，即使多个cpu竞争自旋锁获取队列写入权限依旧不过分影响性能。而最近的高IOPS（io per second）硬件逐渐增多比如ssd，nvme等硬件设备开始大量使用，那么从前的single queue在高IOPS场景下80% cpu时间耗费在锁获取上了，因此设计了新的blk-mq 获取锁仅占用 3% cpu时间。 blk-mq 设计了两层队列 首先为每个cpu分配了一个软件暂存队列（software staging queue），负责完成bio 提交/完成处理，IO请求暂存（合并、排序等）、IO请求标记、调度、记账（和新的IO调度算法BFS有关） 硬件派发队列（Hardware Dispatch Queue） 为每个硬件队列分派一个硬件派发队列，负责存放软件队列向硬件派发的IO请求，一个和多个软件队列和一个硬件队列存在固定映射关系 在架构层面mq 将 request 和 tag 绑定，request内存分配在块设备驱动初始化时完成（调用blk_mq_alloc_tag_set）避免IO时分配request内存带来消耗 tag作为request（static_rqs/rqs）的索引。 具体到函数有 blk_fetch_request , __blk_end_request_cur ,blk_init_queue, __bio_kmap_atomic(bio, iter) , __bio_kunmap_atomic(buffer) 等 其中 取代 __bio_kmap_atomic(bio, iter) , __bio_kunmap_atomic(buffer) 如下 123456789- char *buffer &#x3D; __bio_kmap_atomic(bio, iter);+ char *buffer &#x3D; kmap_atomic(bvec.bv_page) + bvec.bv_offset; unsigned len &#x3D; bvec.bv_len &gt;&gt; SECTOR_SHIFT; simdisk_transfer(dev, sector, len, buffer, bio_data_dir(bio) &#x3D;&#x3D; WRITE); sector +&#x3D; len;- __bio_kunmap_atomic(buffer);+ kunmap_atomic(buffer) 除此之外 BLK_MQ_F_SG_MERGE 和 QUEUE_FLAG_NO_SG_MERGE 都可以被省略了block: kill BLK_MQ_F_SG_MERGE 12- lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;+ lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE; 内核计时接口发生变化64位系统中,由于2038问题 时间戳 timespec 在 inode数据结构中的i_*time 中弃用，转而使用 timespec64 相应的 getnstimeofday 等函数也被弃用， 转而使用 ktime_get_ts64(struct timespec64 *ts) 等函数获取时间，另外需要注意 这个函数必须使用 GPL协议才能成功加载。 详见内核时间api文件，ktime accessors 最新设计的时间数据结构为 ktime_t 获取方式为 ktime_t ktime_get(void) 系统调用初始化接口变化（未解决）系统调用初始化接口代码越变越少，而且有点难以理解，除了在arch/x86/entry/syscall 目录下定义之外，还用了同目录下的脚本直接生成了ni代码 具体的解决办法是直接ftrace跟踪一波，看看syscall最新的调用路径 文件系统减少定义数量 （未解决）文件系统减少了大量file_operations定义数量，例如 aio_read aio_write 等异步代码直接被省略掉，read 和 write 接口基本也不定义了， 似乎使用了 read_iter 和 write_iter 替代了前两类接口 具体原因还没搞清楚，但是在 [V5,17/30] fs: use read_iter and write_iter rather than aio_read and aio_write 中显示 aio被明确删除掉，用iter替代。 此外 file_operations 当中的 readdir 等接口也被取消，直接由read/read_iter和 iterate 替代,iterate基本上可以理解为负责执行ls命令， filldentry_t 由 dir_context 替代。 jprobe 被取消在 kprobe中只剩下kprobe和kretprobe，jprobe及相关的一套函数被取消，替代方式如下： /source/samples/kprobes/kprobe_example.c 和 /source/samples/kprobes/kretprobe_example.c 中示例 使用kprobe中的handler_pre和handler_post替代。","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"}]},{"title":"dynamicprogramming.md","slug":"dynamicprogramming-md","date":"2020-11-15T10:36:17.000Z","updated":"2020-11-15T11:52:25.507Z","comments":true,"path":"2020/11/15/dynamicprogramming-md/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/dynamicprogramming-md/","excerpt":"动态规划 Dynamic Programming动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 tricky一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。 如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。","text":"动态规划 Dynamic Programming动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 tricky一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。 如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。 硬币找零问题 coin changeleetcode-322 You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:Input: coins = [1, 2, 5], amount = 11Output: 3Explanation: 11 = 5 + 5 + 1 解析：每种coins的数量是不限的，因此假设dp[i]是从0到金额i，所需要的最小硬币的数量初始化假设dp值均为 amount+1dp[i] = min(dp[i-coin[x]]+1, dp[i])循环遍历每个coin的值，获得dp最后的值，即相应的结果 123456789101112131415161718int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; &#x2F;&#x2F; dp[i] &#x3D; min(dp[i-coink]+1, dp[i]) if (amount &#x3D;&#x3D; 0) return 0; vector&lt;int&gt; dp(amount+1, amount+1); &#x2F;&#x2F; 此处初始化为amount+1，便于之后取最小值 dp[0] &#x3D; 0; for (int i &#x3D; 1;i &lt;&#x3D; amount;i++) &#123; for (int j &#x3D; 0;j &lt; coins.size();j++) &#123; if (i &gt;&#x3D; coins[j]) &#123; &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; coins[j] &lt;&lt;&quot; &quot; &lt;&lt; dp[i] &lt;&lt; &quot; &quot;; dp[i] &#x3D; min(dp[i], dp[i-coins[j]]+1); &#x2F;&#x2F; cout &lt;&lt; dp[i] &lt;&lt; endl; &#125; &#125; &#125; return (dp[amount] &#x3D;&#x3D; amount+1) ? -1 : dp[amount]; &#125; 01背包问题01背包是解决什么问题？ 答：当书包容量大小固定，面对1堆重量固定而且带有价格的物品。在不超出包容量前提下，选择那些物品使包里物品总价值最大。 其中代表重量的数组 w[0…i….n], 代表价值的数组 v[0…i…n]。 一般可以通过画表格确定解空间（还没研究明白） 动态规划的思路是设计 dp[N+1][S+1] 其中N代表物品数量，S代表背包总重量，即在N件物品，重量为S的情况下，物品的价值多大当w[i-1] &lt; j(当前剩余重量)时间分别代表装入或不装入dp[i][j] = min(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1]) 例题 target sumleetcode-494 You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1:Input: nums is [1, 1, 1, 1, 1], S is 3.Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. 根据题意可以假设集合nums有两个真子集A,B，其中集合A表示所有为正数的集合，集合B表示所有未负数的集合，目标值未target，那么有 123sum(A) + sum(B) &#x3D; sum(nums)sum(A) - sum(B) &#x3D; target2 * sum(A) &#x3D; sum(nums) + target 由上述递推公式将该问题转化为01背包问题，题解如下 123456789101112131415161718192021222324252627int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n &#x3D; nums.size(); long sum &#x3D; 0; for (int i : nums) sum +&#x3D; i; if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123; return 0; &#125; S &#x3D; (sum + S) &#x2F; 2; &#x2F;&#x2F; 传统dp &#x2F;&#x2F; 对于dp(i,j)就表示可选物品为i到n且背包容量为j(总重量)时背包中所放物品的最大价值 vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(S+1, 0)); &#x2F;&#x2F; 0个数和为0的个数为1 dp[0][0] &#x3D; 1; for (int i &#x3D; 1;i &lt;&#x3D;n;i++ ) &#123; for (int j &#x3D; 0;j &lt; S+1;j++) &#123; if(j-nums[i-1] &lt; 0)&#x2F;&#x2F;背包容量不足，不能放入第i个物品 &#123; dp[i][j] &#x3D; dp[i-1][j];&#x2F;&#x2F;其实就是表格的左边界 &#125; else &#123; dp[i][j] &#x3D; dp[i-1][j-nums[i-1]] + dp[i-1][j];&#x2F;&#x2F;装入第i个物品或者不装入 &#125; &#125; &#125; return dp[n][S]; &#125; 根据上述代码我们发现 dp[i][j] = dp[i-1][...] 的关系，即i至于i-1有关系，因此我们可以减少一维向量，用一维向量记录上一轮的运算结果。 12345678910111213141516171819int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n &#x3D; nums.size(); long sum &#x3D; 0; for (int i : nums) sum +&#x3D; i; if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123; return 0; &#125; S &#x3D; (sum + S) &#x2F; 2; &#x2F;&#x2F; dp优化 vector&lt;int&gt; dp(S+1, 0); dp[0] &#x3D; 1; for (int i &#x3D; 0;i &lt; n;i++) &#123; for (int j &#x3D; S;j &gt;&#x3D; nums[i];j--) &#123; dp[j] +&#x3D; dp[j-nums[i]]; &#125; &#125; return dp[S]; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-14T08:54:12.760Z","updated":"2020-11-15T11:22:11.557Z","comments":true,"path":"2020/11/14/hello-world/","link":"","permalink":"https://www.zi-c.wang/2020/11/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Next-theme ConfigHexo-NexT (v7.0+) 主题配置","categories":[],"tags":[]},{"title":"Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1的自动部署脚本","slug":"Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1的自动部署脚本","date":"2016-10-18T09:50:10.000Z","updated":"2020-11-22T08:51:15.510Z","comments":true,"path":"2016/10/18/Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1的自动部署脚本/","link":"","permalink":"https://www.zi-c.wang/2016/10/18/Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/","excerpt":"在阳总的帮助下，终于搞出了这个自动部署脚本，感谢阳总让我第一次看到真人写的bash脚本，很涨姿势。 hbase-0.98-hadoop 的选择原因是[http://wiki.apache.org/nutch/Nutch2Tutorial ](nutch turorial)上这么推荐的 solr5.x 的玩法似乎和solr4.9 差别不小，之后应该会单独写一篇分析的 测试环境是 centos6环境，使用ubuntu或者其他发行版的兄弟记得改下 那堆yum，rpm","text":"在阳总的帮助下，终于搞出了这个自动部署脚本，感谢阳总让我第一次看到真人写的bash脚本，很涨姿势。 hbase-0.98-hadoop 的选择原因是[http://wiki.apache.org/nutch/Nutch2Tutorial ](nutch turorial)上这么推荐的 solr5.x 的玩法似乎和solr4.9 差别不小，之后应该会单独写一篇分析的 测试环境是 centos6环境，使用ubuntu或者其他发行版的兄弟记得改下 那堆yum，rpm #!/bin/bash 这个写到一开头表示这是.sh那一类文件，剩下的就是用重定向之类的linux下的特殊写法追加写入文本的 脚本中的所有文件都将被部署到 /usr 目录下，如果改目录需要连着配置文件一起改，权限不够加sudo nutch crawl solr hbase 都写入环境变量，可以在任何目录下运行。 nutch 执行的是 /usr/nutch-2/runtime/local/bin/nutch 目录的文件，而不是deploy中 之后集成hadoop再修改配置文件。 以下是自动部署脚本，需要复制下来制作成 .sh 文件，使用 sudo bash xxx.sh 执行 自动部署脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!/bin/bashrpm -Uvh https://centos6.iuscommunity.org/ius-release.rpmyum install epel-release -yyum install git wget screen vim -yyum update -yiptables -Fiptables-saveservice iptables saveip6tables -Fip6tables-saveservice ip6tables savecd /optwget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u102-b14/jdk-8u102-linux-x64.rpm&quot;rpm -ivh jdk-8u102-linux-x64.rpmrm -rf jdk-8u102-linux-x64.rpmwget http://archive.apache.org/dist/hbase/hbase-0.98.8/hbase-0.98.8-hadoop2-bin.tar.gztar xzf hbase-0.98.8-hadoop2-bin.tar.gzrm -rf hbase-0.98.8-hadoop2-bin.tar.gzmv hbase-0.98.8-hadoop2 /usr/hbasewget http://www-eu.apache.org/dist/nutch/2.3.1/apache-nutch-2.3.1-src.tar.gztar xzf apache-nutch-2.3.1-src.tar.gzrm -rf apache-nutch-2.3.1-src.tar.gzmv apache-nutch-2.3.1 /usr/nutch-2chmod -R 777 /usr/nutch-2wget http://www-us.apache.org/dist/ant/binaries/apache-ant-1.9.7-bin.tar.gztar xzf apache-ant-1.9.7-bin.tar.gzrm -rf apache-ant-1.9.7-bin.tar.gzmv apache-ant-1.9.7 /usr/antwget http://archive.apache.org/dist/lucene/solr/5.2.1/solr-5.2.1.tgztar xzf solr-5.2.1.tgzrm -rf solr-5.2.1.tgzmv solr-5.2.1 /usr/solrrm -rf ~/envtempcat &gt; ~/envtemp&lt;&lt;&#x27;EOF&#x27;#set JDK environmentJAVA_HOME=/usr/java/jdk1.8.0_102JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib#set ANT environmentANT_HOME=/usr/ant#set HBASE environmentHBASE_HOME=/usr/hbase#set LOCAL_NUTCH environmentNUTCH_HOME=/usr/nutch-2/runtime/local#set SOLR environmentSOLR_HOME=/usr/solr#set HADOOP environmentHADOOP_HOME=/usr/hadoopHADOOP_INSTALL=$HADOOP_HOMEHADOOP_MAPRED_HOME=$HADOOP_HOMEHADOOP_COMMON_HOME=$HADOOP_HOMEHADOOP_HDFS_HOME=$HADOOP_HOMEYARN_HOME=$HADOOP_HOMEHADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeHADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib:$HADOOP_COMMON_LIB_NATIVE_DIR&quot;PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$ANT_HOME/bin:$HBASE_HOME/bin:$NUTCH_HOME/bin:$SOLR_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbinexport JAVA_HOME JRE_HOMECLASS_PATH ANT_HOME HBASE_HOME NUTCH_HOME SOLR_HOME HADOOP_HOME HADOOP_INSTALL HADOOP_MAPRED_HOME HADOOP_COMMON_HOME HADOOP_HDFS_HOME YARN_HOME HADOOP_COMMON_LIB_NATIVE_DIR HADOOP_OPTS PATHEOFrm -rf ~/profilecp /etc/profile ~/profilecat ~/profile ~/envtemp &gt;/etc/profilerm -rf ~/envtemp ~/profilesource /etc/profilecd ~wget http://www.senra.me/nutch-solr/nutch-site.xmlwget http://www.senra.me/nutch-solr/gora.propertieswget http://www.senra.me/nutch-solr/ivy.xmlwget http://www.senra.me/nutch-solr/hbase-site.xmlwget http://www.senra.me/nutch-solr/solr.xml\\cp -a ~/nutch-site.xml /usr/nutch-2/conf/\\cp -a ~/gora.properties /usr/nutch-2/conf/\\cp -a ~/ivy.xml /usr/nutch-2/ivy/\\cp -a ~/hbase-site.xml /usr/hbase/conf/\\cp -a ~/solr.xml /usr/solr/rm -rf ~/nutch-site.xml ~/gora.properties ~/ivy.xml ~/hbase-site.xml ~/solr.xmlcd /usr/nutch-2ant runtime/usr/hbase/bin/start-hbase.sh/usr/solr/bin/solr start/usr/solr/bin/solr create_core -c demo 20号之后的大创答辩加油！争取国家级！","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.zi-c.wang/tags/markdown/"}]},{"title":"nutch-2.3.1+hbase-0.94+eclipse 环境搭建教程","slug":"nutch-2.3.1+hbase-0.94+eclipse环境搭建","date":"2016-03-08T15:52:10.000Z","updated":"2020-11-22T08:50:36.390Z","comments":true,"path":"2016/03/08/nutch-2.3.1+hbase-0.94+eclipse环境搭建/","link":"","permalink":"https://www.zi-c.wang/2016/03/08/nutch-2.3.1+hbase-0.94+eclipse%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"1.开发环境及软件版本 centos 6.7 apache-nutch-2.3.1 hbase-0.94 eclipse javaEE jdk8 2.安装并配置jdk","text":"1.开发环境及软件版本 centos 6.7 apache-nutch-2.3.1 hbase-0.94 eclipse javaEE jdk8 2.安装并配置jdk 1) 在Oracle网站wget下载jdk8jdk8_installing1wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense&#x3D;accept-securebackup-cookie&quot; http:&#x2F;&#x2F;download.oracle.com&#x2F;otn-pub&#x2F;java&#x2F;jdk&#x2F;8u73-b02&#x2F;jdk-8u73-linux-x64.tar.gz 由于Oracle需要点击accept licence的才能下载，所以必须使用下面的命令，才可以直接下载。否则下载的jdk文件将无法解压缩。 2) 配置JAVA_HOMEjdk8_installing1234mkdir&#x2F;usr&#x2F;java&#x2F;tar -zxf jdk-8u73-linux-x64.tar.gz &#x2F;&#x2F;不适用-v指令以加快解压缩速度mv jdk-8u73-linux-x64&#x2F; &#x2F;usr&#x2F;java&#x2F;vi &#x2F;etc&#x2F;profile &#x2F;&#x2F;打开vi文本编辑器编辑环境变量 按i开始编辑，在文件的末尾输入 jdk8_installing1234567 #set JDK environment JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_45JRE_HOME&#x3D;$JAVA_HOME&#x2F;jreCLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;libPATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;binexport JAVA_HOME JRE_HOMECLASS_PATH PATH 先按Esc退出编辑模式，然后输入 :wq 保存退出 jdk8_installing123source &#x2F;etc&#x2F;profile &#x2F;&#x2F;使环境生效echo $JAVA_HOME &#x2F;&#x2F;检验是否安装成功&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_45 &#x2F;&#x2F;环境生效！！！ 3.安装并配置hbase-0.941) 在hbase页面下载hbase-0.94解压缩并重命名hbase_installing12345678910111213141516171819wget http:&#x2F;&#x2F;www-eu.apache.org&#x2F;dist&#x2F;hbase&#x2F;hbase-0.94.27&#x2F;tar -zxf hbase-0.94.27&#x2F; &#x2F;&#x2F;减少输出，加快速度mv hbase-0.94.27&#x2F; hbase&#x2F; &#x2F;&#x2F;重命名，简短文件名称mv hbase&#x2F; &#x2F;usr&#x2F; &#x2F;&#x2F;将hbase&#x2F;文件夹移动到&#x2F;usr&#x2F;路径下cd &#x2F;usr&#x2F; &#x2F;&#x2F;进入&#x2F;usr目录chmod -R 777 hbase&#x2F; &#x2F;&#x2F;给hbase目录分配权限cd hbase&#x2F;vi conf&#x2F;hbase-site.xml &#x2F;&#x2F;配置hbase-site.xml文件&lt;configuration&gt;&lt;property&gt; &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;&#x2F;usr&#x2F;hbase&#x2F;hbase&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;&#x2F;name&gt; &lt;value&gt;&#x2F;usr&#x2F;hbase&#x2F;zookeeper&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 之后的nutch爬出的数据将存储到rootdir文件夹中，所以必须配置zookeeper的同理。测试是否安装成功 hbase_installing1234.&#x2F;bin&#x2F;start-hbase.sh &#x2F;&#x2F;打开hbase进程.&#x2F;bin&#x2F;hbase shell &#x2F;&#x2F;可以进入hbase命令行模式&#x2F;&#x2F;检验成功可以运行后暂时关闭hbase进程.&#x2F;stop-hbase.sh 至此hbase安装成功，hbase-0.94可以直接在本地运行，不需要hadoop集群（个人暂时是这么理解的欢迎指正） 4.安装并配置apache-nutch-2.3.11)wget下载apache-nutch-2.3.1并解压缩nutch-2_installing1234567wget http:&#x2F;&#x2F;www-eu.apache.org&#x2F;dist&#x2F;nutch&#x2F;2.3.1&#x2F;apache-nutch-2.3.1-src.tar.gz&#x2F;&#x2F;速度不够的话去官网看他给你推荐的链接tar -zxf apache-nutch-2.3.1-src.tar.gzmv apache-nutch-2.3.1&#x2F; nutch-2&#x2F;mv nutch-2&#x2F; &#x2F;usr&#x2F; &#x2F;&#x2F;移动文件cd &#x2F;usr&#x2F;chmod -R 777 nutch-2 下面开始重头戏，配置nutch文件(1)conf目录下的nutch-site.xml文件(我的配置)nutch-2_installing1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;configuration&gt;&lt;property&gt;&lt;name&gt;storage.data.store.class&lt;&#x2F;name&gt;&lt;value&gt;org.apache.gora.hbase.store.HBaseStore&lt;&#x2F;value&gt;&lt;description&gt;Default class for storing data&lt;&#x2F;description&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;plugin.includes&lt;&#x2F;name&gt; &lt;value&gt;protocol-httpclient|urlfilter-regex|index-(basic|more)|query-(basic|site|url|lang)|indexer-solr|nutch-extensionpoints|protocol-httpclient|urlfilter-regex|parse-(text|html|msexcel|msword|mspowerpoint|pdf)|summary-basic|scoring-opic|urlnormalizer-(pass|regex|basic)protocol-http|urlfilter-regex|parse-(html|tika|metatags)|index-(basic|anchor|more|metadata)&lt;&#x2F;value&gt;&lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;http.agent.name&lt;&#x2F;name&gt; &lt;value&gt;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;33.0.1750.117 Safari&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;http.agent.version&lt;&#x2F;name&gt; &lt;value&gt;537.36&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;http.robots.agents&lt;&#x2F;name&gt; &lt;value&gt;Test-Crawler&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;property&gt; &lt;name&gt;plugin.folders&lt;&#x2F;name&gt; &lt;value&gt;.&#x2F;build&#x2F;plugins&lt;&#x2F;value&gt; &lt;description&gt;Directories where nutch plugins are located. Each element may be a relative or absolute path. If absolute, it is used as is. If relative, it is searched for on the classpath.&lt;&#x2F;description&gt;&lt;&#x2F;property&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;plugin.includes&lt;&#x2F;name&gt; &lt;value&gt;protocol-http|urlfilter-regex|parse-(html|tika)|index-(basic|anchor)|urlnormalizer-(pass|regex|basic)|scoring-opic|index-anchor|index-more|languageidentifier|subcollection|feed|creativecommons|tld&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 留心plugin.folders，配置不对花式报错 (2)修改conf/gora.properties加入gora.datastore.default=org.apache.gora.hbase.store.HBaseStore之后注释掉所有其他内容 (3)修改ivy/ivy.xml文件取消注释 表示使用hbase数据库 另外regex-urlfliter.txt网页内容过滤等可以暂时不进行配置 返回nutch-2根目录 nutch-2_installing123yum -y install ant &#x2F;&#x2F;yum直接安装ant，对nutch进行搭建ant eclipseant runtime &#x2F;&#x2F;命令行操作方式构建，进入runtime&#x2F;local&#x2F;bin&#x2F;文件夹中有nutch和crawl感兴趣的关注文章结尾处推荐链接 maven资源被墙了，建议翻墙使用maven资源被墙了，建议翻墙使用maven资源被墙了，建议翻墙使用 重要的事情说三遍 安装完成之后就可以导入eclipse中了 革命尚未成功，同志仍需努力。 行百里者半九十 最后一步不认真的话可能会超级麻烦的！！（认真脸） 别忘了最后一步 在nutch根目录中新建文件夹urls/，在文件夹中新建seed.txt文件 http://www.zi-c.wang 保存退出 5.导入eclipse中（想导入idea也可以这样玩，貌似）1)创建工程java project进入eclipse-&gt;file-&gt;new-&gt;project-&gt;java project直接修改项目路径（/usr/nutch-2）点击next，在build path配置中order&amp;export选项卡，选中nutch-2/conf文件夹，单击top 2)配置run configuration点击run configurations，进入页面。右键java application，新建application命名为injectJobproject：nutch-2main class：org.apache.nutch.crawl.InjectorJob进入run configurations的arguments标签中，在Program Arguments中添加urls/seed.txt -crawlId search点击apply 同理application：generateJobmain class：org.apache.nutch.crawl.GeneratorJobarguments:-topN 10 -crawlId search application：fetcheJobmain class：org.apache.nutch.fetcher.FetcherJobarguments:-all -crawlId search -thread 10 application：parseJobmain class：org.apache.nutch.parse.ParserJobarguments:-all -crawlId search application：updatedbJobmain class：org.apache.nutch.crawl.DbUpdaterJobarguments:-all -crawlId search 3)跑起来吧！！奔放的eclipse4)查看爬取得数据nutch-2_installing12345cd &#x2F;usr&#x2F;hbase&#x2F;.&#x2F;bin&#x2F;hbase shelllist &#x2F;&#x2F;hbase指令请参考我的上一篇文章 hbase常用指令scan &#39;search_webpage&#39; &#x2F;&#x2F;灰常灰常壮观的数据闪过去了&#x3D;_+exit 成功！！！ 6.感想 搭建这套环境对我来说是很大的一个修行！！ 前前后后使用的时间可能超过50h了，真是笨死了。 耗时这么长的原因：主要是我太粗心了，很多应该完成的配置并没有实现成功，浪费了很多时间 另一方面：不会看log 现在看起来非常可笑的事情就是我的环境一旦搭建失败了首先看的是文档而不是日志，真是笨死了 同时我也终于意识到Android application中为什么强调写好log。 搭建这套环境确实提升了个人能力一大截，超级期待下一步的搜索引擎实践！！ 加油奔放的少年！！！ 7.推荐链接1.Apache Nutch Wiki2.【Nutch2.2.1基础教程之2.1】集成Nutch/Hbase/Solr构建搜索引擎之一：安装及运行【单机环境】3.在Eclipse中运行Nutch2.34.about云社区5.hbase wiki6. 杨尚川老师的nutch系列视频（虽然有点旧，但是给你仔细分析每个过程）7.Linux 使用wget 命令下载JDK的方法8.神圣网站stackoverflow，救过我无数次","categories":[],"tags":[{"name":"hbase","slug":"hbase","permalink":"https://www.zi-c.wang/tags/hbase/"},{"name":"nutch","slug":"nutch","permalink":"https://www.zi-c.wang/tags/nutch/"}]},{"title":"hbase的常用shell","slug":"hbase常用shell","date":"2016-01-20T02:43:10.000Z","updated":"2020-11-22T08:52:48.260Z","comments":true,"path":"2016/01/20/hbase常用shell/","link":"","permalink":"https://www.zi-c.wang/2016/01/20/hbase%E5%B8%B8%E7%94%A8shell/","excerpt":"1.打开hbase并进入hbase shell console $HBASE_HOME/bin/start-hbase.sh $HBASE_HOME/bin/hbase shell hbase(main)> whoami","text":"1.打开hbase并进入hbase shell console $HBASE_HOME/bin/start-hbase.sh $HBASE_HOME/bin/hbase shell hbase(main)> whoami 2.表的管理1）查看有哪些表 hbase(main)> list 2）创建表 语法：create , {NAME =&gt; , VERSIONS =&gt; } //例如：创建表t1，有两个family name：f1，f2，且版本数均为2 hbase(main)> create 't1',&#123;NAME => 'f1', VERSIONS => 2&#125;,&#123;NAME => 'f2', VERSIONS => 2&#125; 3）删除表 分两步：首先disable，然后drop //例如：删除表t1 hbase(main)> disable 't1' hbase(main)> drop 't1' 4）查看表的结构 语法：describe //例如：查看表t1的结构 hbase(main)> describe 't1' 5）修改表结构 修改表结构必须先disable 语法：alter ‘t1’, {NAME =&gt; ‘f1’}, {NAME =&gt; ‘f2’, METHOD =&gt; ‘delete’} hbase(main)> disable 'test1' hbase(main)> alter 'test1',&#123;NAME=>'body',TTL=>'15552000'&#125;,&#123;NAME=>'meta', TTL=>'15552000'&#125; hbase(main)> enable 'test1' 3.表数据的增删改查1）添加数据 语法：put ,,family:column,, //例如：给表t1的添加一行记录：rowkey是rowkey001，family name：f1，column name：col1，value：value01，timestamp：系统默认 hbase(main)> put 't1','rowkey001','f1:col1','value01' //用法比较单一。 2）查询数据a）查询某行记录 语法：get ,,[family:column,….] //例如：查询表t1，rowkey001中的f1下的col1的值 hbase(main)> get 't1','rowkey001', 'f1:col1' //或者： hbase(main)> get 't1','rowkey001', &#123;COLUMN=>'f1:col1'&#125; //查询表t1，rowke002中的f1下的所有列值 hbase(main)> get 't1','rowkey001' b）扫描表 语法：scan , {COLUMNS =&gt; [ family:column,…. ], LIMIT =&gt; num} 另外，还可以添加STARTROW、TIMERANGE和FITLER等高级功能 //例如：扫描表t1的前5条数据 hbase(main)&gt; scan ‘t1’,{LIMIT=&gt;5} c）查询表中的数据行数 语法：count , {INTERVAL =&gt; intervalNum, CACHE =&gt; cacheNum} INTERVAL设置多少行显示一次及对应的rowkey，默认1000；CACHE每次去取的缓存区大小，默认是10，调整该参数可提高查询速度 //例如，查询表t1中的行数，每100条显示一次，缓存区为500 hbase(main)> count 't1', &#123;INTERVAL => 100, CACHE => 500&#125; 3）删除数据a )删除行中的某个列值 语法：delete , , family:column , ,必须指定列名 //例如：删除表t1，rowkey001中的f1:col1的数据 hbase(main)> delete 't1','rowkey001','f1:col1' //注：将删除改行f1:col1列所有版本的数据 b )删除行 语法：deleteall , , family:column , ，可以不指定列名，删除整行数据 //例如：删除表t1，rowk001的数据 hbase(main)> deleteall 't1','rowkey001' c）删除表中的所有数据 语法： truncate 其具体过程是：disable table -&gt; drop table -&gt; create table //例如：删除表t1的所有数据 hbase(main)> truncate 't1'","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.zi-c.wang/tags/markdown/"},{"name":"hbase","slug":"hbase","permalink":"https://www.zi-c.wang/tags/hbase/"}]},{"title":"可能经常用到的markdown语法和标签插件","slug":"可能经常用到的markdown语法和标签插件","date":"2016-01-20T02:43:10.000Z","updated":"2020-11-22T08:50:48.340Z","comments":true,"path":"2016/01/20/可能经常用到的markdown语法和标签插件/","link":"","permalink":"https://www.zi-c.wang/2016/01/20/%E5%8F%AF%E8%83%BD%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84markdown%E8%AF%AD%E6%B3%95%E5%92%8C%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/","excerpt":"摘要 本文没有系统介绍markdown语法和标签插件，而是仅仅列举的可能经常使用的markdown语法和标签插件样式 l&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ol&gt;“ 都可以表示分点 First Second Third false","text":"摘要 本文没有系统介绍markdown语法和标签插件，而是仅仅列举的可能经常使用的markdown语法和标签插件样式 l&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ol&gt;“ 都可以表示分点 First Second Third false 关于换行 单一段落( &lt;p&gt;) 用一个空白行 连续两个空格 会变成一个 &lt;br&gt; 连续3个符号，然后是空行，表示 hr横线 关于插入代码 可以是使用&lt;pre&gt;&lt;code&gt;code&lt;/code&gt;&lt;/pre&gt;形式插入代码，不过比较简陋 cout < \"Hello World!!\" < endl;","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.zi-c.wang/tags/markdown/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://www.zi-c.wang/categories/python/"},{"name":"rss","slug":"python/rss","permalink":"https://www.zi-c.wang/categories/python/rss/"},{"name":"github","slug":"python/rss/github","permalink":"https://www.zi-c.wang/categories/python/rss/github/"},{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"},{"name":"raspberryPi","slug":"kernel/raspberryPi","permalink":"https://www.zi-c.wang/categories/kernel/raspberryPi/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/categories/linux/"},{"name":"bash","slug":"linux/bash","permalink":"https://www.zi-c.wang/categories/linux/bash/"},{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/categories/eBPF/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"},{"name":"binarytree","slug":"binarytree","permalink":"https://www.zi-c.wang/tags/binarytree/"},{"name":"python","slug":"python","permalink":"https://www.zi-c.wang/tags/python/"},{"name":"rss","slug":"rss","permalink":"https://www.zi-c.wang/tags/rss/"},{"name":"github","slug":"github","permalink":"https://www.zi-c.wang/tags/github/"},{"name":"NJU","slug":"NJU","permalink":"https://www.zi-c.wang/tags/NJU/"},{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"raspberryPi","slug":"raspberryPi","permalink":"https://www.zi-c.wang/tags/raspberryPi/"},{"name":"bash","slug":"bash","permalink":"https://www.zi-c.wang/tags/bash/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"tool","slug":"tool","permalink":"https://www.zi-c.wang/tags/tool/"},{"name":"lwn.net","slug":"lwn-net","permalink":"https://www.zi-c.wang/tags/lwn-net/"},{"name":"io_uring","slug":"io-uring","permalink":"https://www.zi-c.wang/tags/io-uring/"},{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/tags/eBPF/"},{"name":"markdown","slug":"markdown","permalink":"https://www.zi-c.wang/tags/markdown/"},{"name":"hbase","slug":"hbase","permalink":"https://www.zi-c.wang/tags/hbase/"},{"name":"nutch","slug":"nutch","permalink":"https://www.zi-c.wang/tags/nutch/"}]}