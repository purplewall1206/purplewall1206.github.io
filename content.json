{"meta":{"title":"purplewall1206 blog","subtitle":"","description":"something about kernel & programming","author":"purplewall1206","url":"https://www.zi-c.wang","root":"/"},"pages":[{"title":"","date":"2020-11-15T10:43:54.047Z","updated":"2020-11-15T10:43:54.047Z","comments":true,"path":"404.html","permalink":"https://www.zi-c.wang/404.html","excerpt":"","text":"+layout: false +--- 404"},{"title":"categories","date":"2020-11-15T10:40:07.000Z","updated":"2020-11-15T10:43:51.827Z","comments":false,"path":"categories/index.html","permalink":"https://www.zi-c.wang/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-11-15T10:38:51.000Z","updated":"2020-11-15T10:38:51.790Z","comments":true,"path":"about/index.html","permalink":"https://www.zi-c.wang/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-15T10:39:13.000Z","updated":"2020-11-15T10:43:56.047Z","comments":false,"path":"tags/index.html","permalink":"https://www.zi-c.wang/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"三剑客sed/awk/grep常用速查","slug":"三剑客sed-awk-grep常用速查","date":"2020-11-16T06:22:23.000Z","updated":"2020-11-16T06:24:22.817Z","comments":true,"path":"2020/11/16/三剑客sed-awk-grep常用速查/","link":"","permalink":"https://www.zi-c.wang/2020/11/16/%E4%B8%89%E5%89%91%E5%AE%A2sed-awk-grep%E5%B8%B8%E7%94%A8%E9%80%9F%E6%9F%A5/","excerpt":"sed和awk的区别，都是按行读入，但是awk会拆分行里面的元素，sed则直接用正则做匹配，基本上sed可以做到的awk都可以。 awkawk &#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39; netstat.txt awk 使用print和printf打印每行中按列分布的元素。 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot;&#39; netstat.txt 过滤记录 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot; || NR==1 &#123;printf &quot;%02s %s %-20s %-20s %s\\n&quot;,NR, FNR, $4,$5,$6&#125;&#39; netstat.txt 其中NR，FNR为内建变量","text":"sed和awk的区别，都是按行读入，但是awk会拆分行里面的元素，sed则直接用正则做匹配，基本上sed可以做到的awk都可以。 awkawk &#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39; netstat.txt awk 使用print和printf打印每行中按列分布的元素。 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot;&#39; netstat.txt 过滤记录 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot; || NR==1 &#123;printf &quot;%02s %s %-20s %-20s %s\\n&quot;,NR, FNR, $4,$5,$6&#125;&#39; netstat.txt 其中NR，FNR为内建变量 $0 当前记录（这个变量中存放着整个行的内容） $1~$n 当前记录的第n个字段，字段间由FS分隔 FS 输入字段分隔符 默认是空格或Tab NF 当前记录中的字段个数，就是有多少列 NR 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。 FNR 当前记录数，与NR不同的是，这个值会是各个文件自己的行号 RS 输入的记录分隔符， 默认为换行符 OFS 输出字段分隔符， 默认也是空格 ORS 输出的记录分隔符，默认为换行符 FILENAME 当前输入文件的名字 awk &#39;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1,$3,$6&#125;&#39; /etc/passwd 指定分隔符 awk &#39;$6 ~ /E/ || NR==1 &#123;print NR, $4,$5,$6&#125;&#39; netstat.txt ~表示开始，//表示匹配，这行命令表示匹配第六个元素开始包含E的行和第一行，然后输出行数和第456个元素。 awk &#39;NR!=1&#123;print $4,$5 &gt; $6&#125;&#39; netstat.txt 不处理第一行，按照第六列元素分类拆分成若干个文件，文件的内容是第45列元素。 awk 脚本123456789101112131415161718192021222324#!&#x2F;bin&#x2F;awk -f# 运行前BEGIN &#123; math &#x3D; 0 english &#x3D; 0 computer &#x3D; 0 printf &quot;NAME NO. MATH ENGLISH COMPUTER TOTAL\\n&quot; printf &quot;---------------------------------------------\\n&quot;&#125;# 运行中&#123; math +&#x3D; $3 english +&#x3D; $4 computer +&#x3D; $5 printf &quot;%-6s %-6s %4d %8d %8d %8d\\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5&#125;# 运行之后END &#123; printf &quot;---------------------------------------------\\n&quot; printf &quot; TOTAL:%10d %8d %8d \\n&quot;, math, english, computer printf &quot;AVERAGE:%10.2f %8.2f %8.2f\\n&quot;, math&#x2F;NR, english&#x2F;NR, computer&#x2F;NR&#125; awk -v val=$x &#39;&#123;print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]&#125;&#39; OFS=&quot;\\t&quot; score.txt 其中x，y为环境变量，为了使用环境变量需要 -v echo $PATH| awk &#39;BEGIN&#123;RS=&quot;:&quot;&#125;&#123;print NR,$0&#125;&#39; 把单行拆分成多行 sedsed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件] e&lt;script&gt;或–expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。 f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。 h或–help 显示帮助。 n或–quiet或–silent 仅显示script处理后的结果。 V或–version 显示版本信息。 a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～ s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ sed &quot;s/my/ppw &#39;s/g&quot; pets.txt 把pets.txt文件的my改成ppw’s，并不修改文件。/g 表示一行上的替换所有的匹配 加入-i sed -i &quot;s/my/ppw &#39;s/g&quot; pets.txt可以直接修改文件 sed &#39;s/^/---/g&#39; pets.txt 在开头加上— sed &#39;s/$/---/g&#39; pets.txt 在结尾加上— 同理类似的有： \\&lt; 表示词首。 如：&lt;abc 表示以 abc 为首的詞。 \\&gt; 表示词尾。 如：abc&gt; 表示以 abc 結尾的詞。 . 表示任何单个字符。 * 表示某个字符出现了0次或多次。 字符集合。 如：[abc] 表示匹配a或b或c，还有 [a-zA-Z] 表示匹配所有的26个字符。如果其中有^表示反，如 [^a] 表示非a的字符 sed &#39;s/&lt;[^&gt;]*&gt;//g&#39; html.txt 取消html文件中的&lt;&gt;tags,不能使用&#39;s/&lt;.*&gt;&#39;//g，因为会贪婪匹配掉第一个《和最后一个》之间所有的内容，现在给出的示例是匹配除了&gt;意外的字符。 sed &#39;3s/my/your/g&#39; pets.txt 和 sed &#39;3,6s/my/your/g&#39; pets.txt，分别表示匹配第三行和第三到六行。 sed &#39;s/s/S/1&#39; pets.txt 匹配每一行的第一个s sed &#39;1,3s/my/your/g; 3,$s/This/That/g&#39; pets.txt 匹配多个 sed &#39;s/my/[&amp;]/g&#39; pets.txt 使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西 sed &#39;s/This is my \\([^,]*\\),.*is \\(.*\\)/\\1:\\2/g&#39; my.txt 圆括号括起来的正则表达式所匹配的字符串会可以当成变量来使用，sed中使用的是\\1,\\2… sed &#39;N;s/my/your/&#39; pets.txt 原文本中的偶数行纳入奇数行匹配，而s只匹配并替换一次，所以最后只有奇数行被修改。 N命令把下一行的内容纳入当成缓冲区做匹配。 sed &quot;1 i This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 和 sed &quot;$ a This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 命令i和a分别表示insert 和 append，添加行 sed &quot;/my/a ----&quot; my.txt 在每行结尾都添加 —- sed &quot;2 c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 和 sed &quot;/fish/c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 命令c表示替换，这两个命令分别表示替换第二行和有’fish’存在的那一行。 sed &#39;/fish/d&#39; my.txt 和 sed &#39;2d&#39; my.txt 和 sed &#39;2,$d&#39; my.txt 命令d表示删除匹配行，这三个命令分别表示删除有fish的一行，删除第二行和删除第二到最后的所有行。 sed -n &#39;/dog/,/fish/p&#39; my.txt 命令-n表示只显示处理后的结果，命令p表示打印，图中命令表示打印有dog的一行和有fish的一行。 grepgrep -i -c &#39;.*ret.*&#39; linux-exec.s 统计内核二级制文件中ret命令的个数，不区分大小写，直接输出匹配行数。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/categories/linux/"},{"name":"bash","slug":"linux/bash","permalink":"https://www.zi-c.wang/categories/linux/bash/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://www.zi-c.wang/tags/bash/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"tool","slug":"tool","permalink":"https://www.zi-c.wang/tags/tool/"}]},{"title":"kernel contribution 统计","slug":"kernel-contribution-统计","date":"2020-11-16T06:19:37.000Z","updated":"2020-11-16T06:24:36.180Z","comments":true,"path":"2020/11/16/kernel-contribution-统计/","link":"","permalink":"https://www.zi-c.wang/2020/11/16/kernel-contribution-%E7%BB%9F%E8%AE%A1/","excerpt":"保存lwn.net发布的新版本开发统计文章，目前来看还是华为最屌。 Development statistics for the 5.0 kernelAs of this writing, 12,517 non-merge changesets have been pulled into the mainline repository for the 5.0 release Some 5.5 kernel development statistics5.5 saw the merging of 14,350 non-merge changesets from 1,885 developers","text":"保存lwn.net发布的新版本开发统计文章，目前来看还是华为最屌。 Development statistics for the 5.0 kernelAs of this writing, 12,517 non-merge changesets have been pulled into the mainline repository for the 5.0 release Some 5.5 kernel development statistics5.5 saw the merging of 14,350 non-merge changesets from 1,885 developers Some 5.6 kernel development statistics12,665 non-merge changesets had been accepted from 1,712 developers Development statistics for the 5.7 kernelWork on 5.7 arrived in the form of 13,901 non-merge changesets contributed by 1,878 developers;","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"lwn.net","slug":"lwn-net","permalink":"https://www.zi-c.wang/tags/lwn-net/"}]},{"title":"io_uring 系统性整理","slug":"io-uring-系统性整理","date":"2020-11-15T11:42:54.000Z","updated":"2020-11-15T11:52:18.240Z","comments":true,"path":"2020/11/15/io-uring-系统性整理/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/","excerpt":"io_uring 系统性整理 io_uring 系统性整理 I/O 模型 comparison Asynchronous I/O io_uring 总结邮件 这里有个误解，I/O模型其实是针对整个系统的所有I/O操作的，但是平时很少对文件系统使用异步读写，同步或直接映射的情况比较多。更别提多路复用了，这个机制基本只用在network中。 lwn Kernel article index","text":"io_uring 系统性整理 io_uring 系统性整理 I/O 模型 comparison Asynchronous I/O io_uring 总结邮件 这里有个误解，I/O模型其实是针对整个系统的所有I/O操作的，但是平时很少对文件系统使用异步读写，同步或直接映射的情况比较多。更别提多路复用了，这个机制基本只用在network中。 lwn Kernel article index I/O 模型 blocking I/O 同步阻塞，直到内核收到数据返回给线程。 nonblocking I/O 同步不阻塞，但是如果内核没收到数据会返回一个 EWOULDBLOCK I/O multiplexing (select and poll) 异步阻塞，使用selet（using select requires two system calls instead of one）、poll系统调用循环等待socket可读时，使用recvfrom收取数据。主要优势在于能够在单线程监控多个文件描述符fd。 初次之外还有epoll,使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次 优点有： 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。 这种方法基本等价于 一个进程创建多个线程，每个线程维护一个blocking I/O signal driven I/O (SIGIO) 非阻塞，通过sigaction系统调用安装signal handler，当datagram数据报可读时，向I/O接收进程发送SIGIO信号，可以在signal handler里面读这个数据，然后通知main loop；也可以先通知main loop，让main loop去读这个数据。 asynchronous I/O (the POSIX aio_functions) 异步非阻塞，也是调用aio_read之后立刻返回，和SIGIO的区别是直到接收到数据并将数据传输到用户时，才产生完成信号。 comparison 参考:io models彻底理解 IO多路复用聊聊IO多路复用之select、poll、epoll详解 Asynchronous I/O首先确定这里的AIO是内核态的，由libaio封装的系统调用运行库，而不是glibc用户态AIO，使用多线程模拟的。 linux kernel AIO的主要缺点在于项目泥潭，bug太多，项目设计和领导更换，而且实现比较复杂，直到现在只能比较稳定支持以O_DIRECT（直接映射修改，bypass page cache）方式打开文件，需要自己处理buffer、offset对其这些问题，不能用page cache层以bio的方式读写block数据。 因为使用page buffer层时涉及到block driver里面的队列，相比O_DIRECT多出很多阻塞点，因此实现起来比较令人恼火。因此这个项目根本就没实现起来。 因此io_uring的主要对比对象是多路复用和DPDK、SPDK，是一个事实上的新异步IO API Linux AIO does suffer from a number of ailments. The subsystem is quite complex and requires explicit code in any I/O target for it to be supported. 实现不了的地方基本上都开一个kernel thread跑，感觉开销更大了。 参考：Linux Asynchronous I/O Fixing asynchronous I/O, againLinux kernel AIO这个奇葩2017Toward non-blocking asynchronous I/O io_uring参考：Kernel Recipes 2019 - Faster IO through io_uring20190115Ringing in a new asynchronous I/O API20200715Operations restrictions for io_uring20200320Automatic buffer selection for io_uring20200124The rapid growth of io_uring20200511Hussain: Lord of the io_uringLinux异步IO新时代：io_uring20200716io_uring: add restrictions to support untrusted applications and guests20200225io_uring support for automatic buffersio_uring（1） – 我们为什么会需要 io_uringlinux “io_uring” 提权漏洞(CVE-2019-19241)分析io_uring（2）- 从创建必要的文件描述符 fd 开始 uring这个词没有翻译”something that looks a little less like io_urine”. 这是一个为了高速I/O提出的新的一系列系统调用，简单来说就是新的ring buffer。之前的异步I/O策略是libaio，这个机制饱受诟病，于是Jens Axboe直接提出io_uring，性能远超aio。 从5.7开始超出纯I/O的范畴，io_uring开始为一部接口提供FAST POLL机制，用户无需再像使用select、event poll等多路复用机制来监听文件句柄，只要把读写请求直接丢到io_uring的submission queue中提交 ，当文件句柄不可读写时，内核会主动添加poll handler，当文件句柄可读写时主动调用poll handler再次下发读写请求，从而减少系统调用次数提高性能 这是一个线程粒度的异步I/O机制，分为 submission queue和completion queue，在使用系统调用申请之后，直接返回可以使用mmap映射的file discriptor。 应用程序可以直接使用mmap映射的两个ring buffer直接与内核进行I/O数据传输交换，减少了大量系统调用的开销。 具体流程： setup int io_uring_setup(int entries, struct io_uring_params *params); 其中entries表示submission and completion queues两个队列的大小 param中设置两个队列和具体的状态 12345678struct io_uring_params &#123; __u32 sq_entries; __u32 cq_entries; __u32 flags; __u16 resv[10]; struct io_sqring_offsets sq_off; struct io_cqring_offsets cq_off;&#125;; 最终实现目的通过file descriptor与内核共享ring buffer 123456789101112subqueue &#x3D; mmap(0, params.sq_off.array + params.sq_entries*sizeof(__u32), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_SQ_RING);sqentries &#x3D; mmap(0, params.sq_entries*sizeof(struct io_uring_sqe), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_SQES);cqentries &#x3D; mmap(0, params.cq_off.cqes + params.cq_entries*sizeof(struct io_uring_cqe), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_CQ_RING); 相关资料：Ringing in a new asynchronous I/O APIThe rapid growth of io_uring 12345678910111213141516171819202122232425262728293031323334#include &lt;liburing.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main()&#123; struct io_uring ring; io_uring_queue_init(32, &amp;ring, 0); struct io_uring_sqe *sqe &#x3D; io_uring_get_sqe(&amp;ring); int fd &#x3D; open(&quot;&#x2F;home&#x2F;carter&#x2F;test.txt&quot;, O_WRONLY | O_CREAT); struct iovec iov &#x3D; &#123; .iov_base &#x3D; &quot;Hello world&quot;, .iov_len &#x3D; strlen(&quot;Hello world&quot;), &#125;; io_uring_prep_writev(sqe, fd, &amp;iov, 1, 0); io_uring_submit(&amp;ring); struct io_uring_cqe *cqe; for (;;) &#123; io_uring_peek_cqe(&amp;ring, &amp;cqe); if (!cqe) &#123; puts(&quot;Waiting...&quot;); &#x2F;&#x2F; accept 新连接，做其他事 &#125; else &#123; puts(&quot;Finished.&quot;); break; &#125; &#125; io_uring_cqe_seen(&amp;ring, cqe); io_uring_queue_exit(&amp;ring);&#125; 总结邮件今天重新思考了一下IO模型，并阅读了io_uring和多路复用相关代码，感觉突然想通了。io_uring取代了AIO而不是取代了usercopy，usercopy部署的安全策略未必适用擅长传输大量数据的io_uring，这个工作可以推后再进行。具体如下。 一、将I/O模型的设计和实现分离 I/O在操作系统中含义包括与I/O设备通信和输入输出数据，I/O模型是针对第一种含义提出的解决方案。 linux在实现I/O的过程中参考了这些模型进行实现，但并没有在同一层次进行实现。例如LKM开发中定义的file_operations实际只包括 read（同步）/read_iter（异步）/mmap/poll 等函数指针，在I/O模型中的阻塞同步和非阻塞同步的情况可以通过使用read/read_iter 附加O_NONBLOCK的方式实现。 select epoll 多路复用和AIO这些I/O模型，则是分别在与之相同或不同的层次对底层函数进行封装。 例如 select 系统调用是在内核层通过vfs_poll遍历相关的file_descriptor，glibc实现的AIO是在用户空间多线程调用这些阻塞/非阻塞的同步/异步系统调用，epoll（更像是一个通知机制）是将select/poll中需要每次都传递的file descriptor都保存在内核中，减少了usercopy；通过event监听callback进行通知，减少了对fd的遍历开销。 二、思考io_uring的设计和实现 io_uring的设计借鉴了以上的优点，在内核空间通过kthread实现对阻塞读写任务的托管，并加入了zero copy特性，开发者可以通过一次系统调用唤醒线程一直向共享ringbuffer中写数据，而不是每次写数据都需要系统调用，这在内核和用户通信范畴内很大程度上减少了系统调用的次数，消除了usercopy的负担。 但无法否认io_uring是对下层file_operations的封装，下层函数又是device driver file_operations的封装（甚至对buffer I/O中间还有一层page cache、一层block layer、一层I/O schedule），因此io_uring在许多情况无法获得SPDK用户空间直通driver的性能优势。 三、对安全问题的思考 我目前理解的安全风险主要来自于usercopy造成的out-of-bound、information/pointer leakage和race情况，尤其是struct结构可能存在的函数/数据指针，但是io_uring消除掉的usercopy主要负责大量I/O数据的传输，而非带有指针的控制数据结构（io_uring中的控制数据也在用copy_*_user传输，如图），因此对安全问题的认识比我预期要复杂一些（主要问题可能是OOB和Iago攻击），需要加深对漏洞形式的理解，但好处是急迫程度下降了。 我只能继续积累漏洞阅读量提升认知水平，思考copy_*_user可以部署的安全机制和策略。 四、总结 我这阶段应该继续把重点放在kernel extension问题的描述上，对这个问题我已经基本有了一定想法，大致是将威胁模型定位为kernel rootkits，通过修改页表或切换地址空间构建运行时沙箱，使用可信基截获、保护gateway，使用hook方式监控driver相关函数和数据I/O。可以将性能的提升和对DPDK/SPDK使用的UIO和VFIO保护作为贡献点（这可能是这次突发奇想的意外收获），现在面临的问题是不确定相关方案是否有实现、近期driver保护方案相关只有四篇。","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"io_uring","slug":"io-uring","permalink":"https://www.zi-c.wang/tags/io-uring/"},{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"}]},{"title":"eBPF 简介","slug":"eBPF-简介","date":"2020-11-15T11:17:06.000Z","updated":"2020-11-15T11:52:20.424Z","comments":true,"path":"2020/11/15/eBPF-简介/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/eBPF-%E7%AE%80%E4%BB%8B/","excerpt":"eBPF eBPF 1. 简介 2. 参考材料 3. in-kernel virtual machine 4. JIT just-in-time compile 5. kprobe 实现原理 ebpf summit 2020峰会 这个有时间应该看一下 1. 简介eBPF由BPF（berkeley packet filter发展而来，BPF现在也叫classic-BPF由于区别BPF），到目前为止被引入了linux内核并且使用了JIT just in time comilper进行加速，类似于浏览器的javascript脚本执行语言。 eBPF定义了一个内核内运行的虚拟机 使用bcc进行bpf的开发，bcc和bpftrace项目的维护放在 iovisor","text":"eBPF eBPF 1. 简介 2. 参考材料 3. in-kernel virtual machine 4. JIT just-in-time compile 5. kprobe 实现原理 ebpf summit 2020峰会 这个有时间应该看一下 1. 简介eBPF由BPF（berkeley packet filter发展而来，BPF现在也叫classic-BPF由于区别BPF），到目前为止被引入了linux内核并且使用了JIT just in time comilper进行加速，类似于浏览器的javascript脚本执行语言。 eBPF定义了一个内核内运行的虚拟机 使用bcc进行bpf的开发，bcc和bpftrace项目的维护放在 iovisor 2. 参考材料 A thorough introduction to eBPF A JIT for packet filters BPF: the universal in-kernel virtual machine LECTURE BPF: Tracing and More TUTORIAL Learn eBPF Tracing: Tutorial and Examples TUTORIAL The bpftrace One-Liner Tutorial TUTORIAL bpftrace Reference Guide Linux内核攻击面之eBPF模块 3. in-kernel virtual machineThings started to change in the 3.0 release, when Eric Dumazet added a just-in-time compiler to the BPF interpreter. In the 3.4 kernel, the “secure computing” (seccomp) facility was enhanced to support a user-supplied filter for system calls; that filter, too, is written in the BPF language. 4. JIT just-in-time compileEric Dumazet’s patch is a fundamental change: it puts a just-in-time compiler into the kernel to translate BPF code directly into the host system’s assembly code. The simplicity of the BPF machine makes the JIT translation relatively simple; every BPF instruction maps to a straightforward x86 instruction sequence. 5. kprobe 实现原理这里仅做猜测，应该是直接使用kprobe技术，int3 打断点到指定位置，截取控制流到相应的probe callback 函数。","categories":[{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/categories/eBPF/"}],"tags":[{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/tags/eBPF/"}]},{"title":"内核近期改变","slug":"内核近期改变","date":"2020-11-15T11:09:13.000Z","updated":"2020-11-15T11:52:26.240Z","comments":true,"path":"2020/11/15/内核近期改变/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/%E5%86%85%E6%A0%B8%E8%BF%91%E6%9C%9F%E6%94%B9%E5%8F%98/","excerpt":"内核近期改变 内核近期改变 ioctl 1.原始版本的ioctl 2.内核改进后的ioctl 3.在编写过程中的处理办法 4. 原因分析 异步I/O read_iter 1.具体变化 2.原因分析 3.问题 timer计时器发生改变 block 驱动在5.0后进行了非常大的变化 原因 blk-mq 设计了两层队列 在架构层面 具体到函数 内核计时接口发生变化 系统调用初始化接口变化（未解决） 文件系统减少定义数量 （未解决） jprobe 被取消","text":"内核近期改变 内核近期改变 ioctl 1.原始版本的ioctl 2.内核改进后的ioctl 3.在编写过程中的处理办法 4. 原因分析 异步I/O read_iter 1.具体变化 2.原因分析 3.问题 timer计时器发生改变 block 驱动在5.0后进行了非常大的变化 原因 blk-mq 设计了两层队列 在架构层面 具体到函数 内核计时接口发生变化 系统调用初始化接口变化（未解决） 文件系统减少定义数量 （未解决） jprobe 被取消 ioctl1.原始版本的ioctl1int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long); 2.内核改进后的ioctl123long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);long (*compat_ioctl) (struct file *, unsigned int, unsigned long); 3.在编写过程中的处理办法 将原先的写的 ioctl 函数声明给改成下面的 unlocked_ioctl 或者 compat_ioctl, 在 file_operations 结构体的初始化中也是一样. 修改为unlocked_ioctl 或者 compat_ioctl, 注意参数的兼容性问题, 新的ioctl() 接口没有 struct inode* 参数, 如果ioctl 接口中使用了 inode, 因此需要通过其他方式获取 inode 123456789101112131415161718192021#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36)static int XXX_ioctl( struct inode *indoe, struct file *filp, unsigned int cmd, unsigned long arg)&#123;#else&#x2F;&#x2F;long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);&#x2F;&#x2F;long (*compat_ioctl) (struct file *, unsigned int cmd, unsigned long arg)static long XXX_unlocked_ioctl( struct file *filp, unsigned int cmd, unsigned long arg)&#123; &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;f_dentry-&gt;d_inode; &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;d_inode; struct inode *inode &#x3D; inode &#x3D; file_inode(filp);#endif &#x2F;* 此处是ioctl() 函数结构的具体实现 *&#x2F;&#125; 同理，file_operations中也进行同样修改。 123456789101112static struct file_operations fpga_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; fpga_open, .read &#x3D; fpga_read, .write &#x3D; fpga_write, .llseek &#x3D; fpga_llseek,#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36) .ioctl &#x3D; XXX_ioctl,#else .unlocked_ioctl &#x3D; XXX_unlocked_ioctl,#endif&#125;; 4. 原因分析file_operations (include/linux/fs.h) 结构变化,ioctl本身并不安全，且之前的ioctl使用了大内核锁延迟太大，因此进行修改。具体内容见The new way of ioctl() 异步I/O read_iter1.具体变化file_operations (include/linux/fs.h) 结构变化，导致 read_iter 和 write_iter 负责设备驱动的异步读写，取代了之前的 aio_read 和 aio_write,只需要将资料中二者进行转换即可。 2.原因分析The iov_iter interface iov_iter 功能增强了，并且试图合并 read(write)_iter 和 splice_read(write)，不过截至2020年5月13日来看这俩似乎还存在着 3.问题fs/ramfs/file-mmu.c 中为什么 file_operations 里面没有定义 read 和 write， 而只有异步I/O。 timer计时器发生改变Improving the kernel timers API用 timer_setup 替换了 init_timer,替换内核版本为4.14(2017)，属于较新的替换 1234567891011#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0) init_timer(&amp;dev-&gt;getIntrTimer); dev-&gt;getIntrTimer.data &#x3D; (unsigned long) dev; dev-&gt;getIntrTimer.function &#x3D; GetIntrTimerCallback; &#x2F;* ... *&#x2F; add_timer(&amp;dev-&gt;getIntrTimer);#else timer_setup(&amp;dev-&gt;getIntrTimer, GetIntrTimerCallback, 0); &#x2F;* the third argument may include TIMER_* flags *&#x2F; &#x2F;* ... *&#x2F;#endif callback function的变化 参数类型发生变化，否则会编译失败 12345678910#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0)void GetIntrTimerCallback(unsigned long devAddr)&#123; myDevice *dev &#x3D; (myDevice *) devAddr;#elsevoid GetIntrTimerCallback(struct timer_list *t)&#123; myDevice *dev &#x3D; from_timer(dev, t, getIntrTimer);#endif &#x2F;* Do something with &quot;dev&quot; *&#x2F; block 驱动在5.0后进行了非常大的变化In kernel V5 blk_fetch_request() and blk_init_queue() gone. Now What? Linux Kernel 5.0 – we write Simple Block Device under blk-mq block: remove __bio_kmap_atomic 内核工匠 公众号 Multiqueue架构分析 block 驱动在5.0后进行了非常大的变化 原因是使用了 multi-queue block layer 即 blk-mq 完全取代了之前的 blk-sq（single-queue），因为从前的IO速度瓶颈在硬件方面，因此可以使用单一队列，即使多个cpu竞争自旋锁获取队列写入权限依旧不过分影响性能。而最近的高IOPS（io per second）硬件逐渐增多比如ssd，nvme等硬件设备开始大量使用，那么从前的single queue在高IOPS场景下80% cpu时间耗费在锁获取上了，因此设计了新的blk-mq 获取锁仅占用 3% cpu时间。 blk-mq 设计了两层队列 首先为每个cpu分配了一个软件暂存队列（software staging queue），负责完成bio 提交/完成处理，IO请求暂存（合并、排序等）、IO请求标记、调度、记账（和新的IO调度算法BFS有关） 硬件派发队列（Hardware Dispatch Queue） 为每个硬件队列分派一个硬件派发队列，负责存放软件队列向硬件派发的IO请求，一个和多个软件队列和一个硬件队列存在固定映射关系 在架构层面mq 将 request 和 tag 绑定，request内存分配在块设备驱动初始化时完成（调用blk_mq_alloc_tag_set）避免IO时分配request内存带来消耗 tag作为request（static_rqs/rqs）的索引。 具体到函数有 blk_fetch_request , __blk_end_request_cur ,blk_init_queue, __bio_kmap_atomic(bio, iter) , __bio_kunmap_atomic(buffer) 等 其中 取代 __bio_kmap_atomic(bio, iter) , __bio_kunmap_atomic(buffer) 如下 123456789- char *buffer &#x3D; __bio_kmap_atomic(bio, iter);+ char *buffer &#x3D; kmap_atomic(bvec.bv_page) + bvec.bv_offset; unsigned len &#x3D; bvec.bv_len &gt;&gt; SECTOR_SHIFT; simdisk_transfer(dev, sector, len, buffer, bio_data_dir(bio) &#x3D;&#x3D; WRITE); sector +&#x3D; len;- __bio_kunmap_atomic(buffer);+ kunmap_atomic(buffer) 除此之外 BLK_MQ_F_SG_MERGE 和 QUEUE_FLAG_NO_SG_MERGE 都可以被省略了block: kill BLK_MQ_F_SG_MERGE 12- lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;+ lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE; 内核计时接口发生变化64位系统中,由于2038问题 时间戳 timespec 在 inode数据结构中的i_*time 中弃用，转而使用 timespec64 相应的 getnstimeofday 等函数也被弃用， 转而使用 ktime_get_ts64(struct timespec64 *ts) 等函数获取时间，另外需要注意 这个函数必须使用 GPL协议才能成功加载。 详见内核时间api文件，ktime accessors 最新设计的时间数据结构为 ktime_t 获取方式为 ktime_t ktime_get(void) 系统调用初始化接口变化（未解决）系统调用初始化接口代码越变越少，而且有点难以理解，除了在arch/x86/entry/syscall 目录下定义之外，还用了同目录下的脚本直接生成了ni代码 具体的解决办法是直接ftrace跟踪一波，看看syscall最新的调用路径 文件系统减少定义数量 （未解决）文件系统减少了大量file_operations定义数量，例如 aio_read aio_write 等异步代码直接被省略掉，read 和 write 接口基本也不定义了， 似乎使用了 read_iter 和 write_iter 替代了前两类接口 具体原因还没搞清楚，但是在 [V5,17/30] fs: use read_iter and write_iter rather than aio_read and aio_write 中显示 aio被明确删除掉，用iter替代。 此外 file_operations 当中的 readdir 等接口也被取消，直接由read/read_iter和 iterate 替代,iterate基本上可以理解为负责执行ls命令， filldentry_t 由 dir_context 替代。 jprobe 被取消在 kprobe中只剩下kprobe和kretprobe，jprobe及相关的一套函数被取消，替代方式如下： /source/samples/kprobes/kprobe_example.c 和 /source/samples/kprobes/kretprobe_example.c 中示例 使用kprobe中的handler_pre和handler_post替代。","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"}]},{"title":"dynamicprogramming.md","slug":"dynamicprogramming-md","date":"2020-11-15T10:36:17.000Z","updated":"2020-11-15T11:52:25.507Z","comments":true,"path":"2020/11/15/dynamicprogramming-md/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/dynamicprogramming-md/","excerpt":"动态规划 Dynamic Programming动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 tricky一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。 如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。","text":"动态规划 Dynamic Programming动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 tricky一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。 如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。 硬币找零问题 coin changeleetcode-322 You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:Input: coins = [1, 2, 5], amount = 11Output: 3Explanation: 11 = 5 + 5 + 1 解析：每种coins的数量是不限的，因此假设dp[i]是从0到金额i，所需要的最小硬币的数量初始化假设dp值均为 amount+1dp[i] = min(dp[i-coin[x]]+1, dp[i])循环遍历每个coin的值，获得dp最后的值，即相应的结果 123456789101112131415161718int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; &#x2F;&#x2F; dp[i] &#x3D; min(dp[i-coink]+1, dp[i]) if (amount &#x3D;&#x3D; 0) return 0; vector&lt;int&gt; dp(amount+1, amount+1); &#x2F;&#x2F; 此处初始化为amount+1，便于之后取最小值 dp[0] &#x3D; 0; for (int i &#x3D; 1;i &lt;&#x3D; amount;i++) &#123; for (int j &#x3D; 0;j &lt; coins.size();j++) &#123; if (i &gt;&#x3D; coins[j]) &#123; &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; coins[j] &lt;&lt;&quot; &quot; &lt;&lt; dp[i] &lt;&lt; &quot; &quot;; dp[i] &#x3D; min(dp[i], dp[i-coins[j]]+1); &#x2F;&#x2F; cout &lt;&lt; dp[i] &lt;&lt; endl; &#125; &#125; &#125; return (dp[amount] &#x3D;&#x3D; amount+1) ? -1 : dp[amount]; &#125; 01背包问题01背包是解决什么问题？ 答：当书包容量大小固定，面对1堆重量固定而且带有价格的物品。在不超出包容量前提下，选择那些物品使包里物品总价值最大。 其中代表重量的数组 w[0…i….n], 代表价值的数组 v[0…i…n]。 一般可以通过画表格确定解空间（还没研究明白） 动态规划的思路是设计 dp[N+1][S+1] 其中N代表物品数量，S代表背包总重量，即在N件物品，重量为S的情况下，物品的价值多大当w[i-1] &lt; j(当前剩余重量)时间分别代表装入或不装入dp[i][j] = min(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1]) 例题 target sumleetcode-494 You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1:Input: nums is [1, 1, 1, 1, 1], S is 3.Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. 根据题意可以假设集合nums有两个真子集A,B，其中集合A表示所有为正数的集合，集合B表示所有未负数的集合，目标值未target，那么有 123sum(A) + sum(B) &#x3D; sum(nums)sum(A) - sum(B) &#x3D; target2 * sum(A) &#x3D; sum(nums) + target 由上述递推公式将该问题转化为01背包问题，题解如下 123456789101112131415161718192021222324252627int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n &#x3D; nums.size(); long sum &#x3D; 0; for (int i : nums) sum +&#x3D; i; if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123; return 0; &#125; S &#x3D; (sum + S) &#x2F; 2; &#x2F;&#x2F; 传统dp &#x2F;&#x2F; 对于dp(i,j)就表示可选物品为i到n且背包容量为j(总重量)时背包中所放物品的最大价值 vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(S+1, 0)); &#x2F;&#x2F; 0个数和为0的个数为1 dp[0][0] &#x3D; 1; for (int i &#x3D; 1;i &lt;&#x3D;n;i++ ) &#123; for (int j &#x3D; 0;j &lt; S+1;j++) &#123; if(j-nums[i-1] &lt; 0)&#x2F;&#x2F;背包容量不足，不能放入第i个物品 &#123; dp[i][j] &#x3D; dp[i-1][j];&#x2F;&#x2F;其实就是表格的左边界 &#125; else &#123; dp[i][j] &#x3D; dp[i-1][j-nums[i-1]] + dp[i-1][j];&#x2F;&#x2F;装入第i个物品或者不装入 &#125; &#125; &#125; return dp[n][S]; &#125; 根据上述代码我们发现 dp[i][j] = dp[i-1][...] 的关系，即i至于i-1有关系，因此我们可以减少一维向量，用一维向量记录上一轮的运算结果。 12345678910111213141516171819int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n &#x3D; nums.size(); long sum &#x3D; 0; for (int i : nums) sum +&#x3D; i; if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123; return 0; &#125; S &#x3D; (sum + S) &#x2F; 2; &#x2F;&#x2F; dp优化 vector&lt;int&gt; dp(S+1, 0); dp[0] &#x3D; 1; for (int i &#x3D; 0;i &lt; n;i++) &#123; for (int j &#x3D; S;j &gt;&#x3D; nums[i];j--) &#123; dp[j] +&#x3D; dp[j-nums[i]]; &#125; &#125; return dp[S]; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-14T08:54:12.760Z","updated":"2020-11-15T11:22:11.557Z","comments":true,"path":"2020/11/14/hello-world/","link":"","permalink":"https://www.zi-c.wang/2020/11/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Next-theme ConfigHexo-NexT (v7.0+) 主题配置","categories":[],"tags":[]}],"categories":[{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/categories/linux/"},{"name":"bash","slug":"linux/bash","permalink":"https://www.zi-c.wang/categories/linux/bash/"},{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"},{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/categories/eBPF/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/categories/leetcode/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://www.zi-c.wang/tags/bash/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"tool","slug":"tool","permalink":"https://www.zi-c.wang/tags/tool/"},{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"lwn.net","slug":"lwn-net","permalink":"https://www.zi-c.wang/tags/lwn-net/"},{"name":"io_uring","slug":"io-uring","permalink":"https://www.zi-c.wang/tags/io-uring/"},{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/tags/eBPF/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"}]}