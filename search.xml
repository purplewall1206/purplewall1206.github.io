<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dynamicprogramming.md</title>
    <url>/2020/11/15/dynamicprogramming-md/</url>
    <content><![CDATA[<h1 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h1><p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。</p>
<h2 id="tricky"><a href="#tricky" class="headerlink" title="tricky"></a>tricky</h2><p>一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。</p>
<p>如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。</p>
<a id="more"></a>
<h2 id="硬币找零问题-coin-change"><a href="#硬币找零问题-coin-change" class="headerlink" title="硬币找零问题 coin change"></a>硬币找零问题 coin change</h2><p><a href="https://leetcode-cn.com/problems/coin-change/">leetcode-322</a></p>
<blockquote>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.  </p>
<blockquote>
<p>Example 1:<br>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1      </p>
</blockquote>
</blockquote>
<p>解析：每种coins的数量是不限的，因此假设dp[i]是从0到金额i，所需要的最小硬币的数量<br>初始化假设dp值均为 amount+1<br><code>dp[i] = min(dp[i-coin[x]]+1, dp[i])</code><br>循环遍历每个coin的值，获得dp最后的值，即相应的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        &#x2F;&#x2F; dp[i] &#x3D; min(dp[i-coink]+1, dp[i])</span><br><span class="line">        if (amount &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        vector&lt;int&gt; dp(amount+1, amount+1);</span><br><span class="line">        &#x2F;&#x2F; 此处初始化为amount+1，便于之后取最小值</span><br><span class="line">        dp[0] &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1;i &lt;&#x3D; amount;i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0;j &lt; coins.size();j++) &#123;</span><br><span class="line">                if (i &gt;&#x3D; coins[j]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot;  &quot; &lt;&lt; coins[j] &lt;&lt;&quot;  &quot; &lt;&lt; dp[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">                    dp[i] &#x3D; min(dp[i], dp[i-coins[j]]+1);</span><br><span class="line">                    &#x2F;&#x2F; cout &lt;&lt; dp[i] &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (dp[amount] &#x3D;&#x3D; amount+1) ? -1 : dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>01背包是解决什么问题？</p>
<p>答：当书包容量大小固定，面对1堆重量固定而且带有价格的物品。在不超出包容量前提下，选择那些物品使包里物品总价值最大。</p>
<p>其中代表重量的数组 w[0…i….n], 代表价值的数组 v[0…i…n]。</p>
<p><strong>一般可以通过画表格确定解空间（还没研究明白）</strong></p>
<p>动态规划的思路是设计 dp[N+1][S+1] 其中N代表物品数量，S代表背包总重量，即在N件物品，重量为S的情况下，物品的价值多大<br>当w[i-1] &lt; j(当前剩余重量)时间<br>分别代表装入或不装入<br><code>dp[i][j] = min(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1])</code></p>
<h3 id="例题-target-sum"><a href="#例题-target-sum" class="headerlink" title="例题 target sum"></a>例题 target sum</h3><p><a href="https://leetcode-cn.com/problems/target-sum/">leetcode-494</a></p>
<blockquote>
<p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.<br>Find out how many ways to assign symbols to make sum of integers equal to target S.  </p>
<blockquote>
<p>Example 1:<br>Input: nums is [1, 1, 1, 1, 1], S is 3.<br>Output: 5<br>Explanation:   </p>
<blockquote>
<p>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3<br>There are 5 ways to assign symbols to make the sum of nums be target 3.  </p>
</blockquote>
</blockquote>
</blockquote>
<p>根据题意可以假设集合nums有两个真子集A,B，其中集合A表示所有为正数的集合，集合B表示所有未负数的集合，目标值未target，那么有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum(A) + sum(B) &#x3D; sum(nums)</span><br><span class="line">sum(A) - sum(B) &#x3D; target</span><br><span class="line">2 * sum(A) &#x3D; sum(nums) + target</span><br></pre></td></tr></table></figure>
<p>由上述递推公式将该问题转化为01背包问题，题解如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123;</span><br><span class="line">        int n &#x3D; nums.size();</span><br><span class="line">        long sum &#x3D; 0;</span><br><span class="line">        for (int i : nums) sum +&#x3D; i;</span><br><span class="line">        if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; </span><br><span class="line">        S &#x3D; (sum + S) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 传统dp</span><br><span class="line">        &#x2F;&#x2F; 对于dp(i,j)就表示可选物品为i到n且背包容量为j(总重量)时背包中所放物品的最大价值</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(S+1, 0));</span><br><span class="line">        &#x2F;&#x2F; 0个数和为0的个数为1</span><br><span class="line">        dp[0][0] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1;i &lt;&#x3D;n;i++ ) &#123;</span><br><span class="line">            for (int j &#x3D; 0;j &lt; S+1;j++) &#123;</span><br><span class="line">                if(j-nums[i-1] &lt; 0)&#x2F;&#x2F;背包容量不足，不能放入第i个物品</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i-1][j];&#x2F;&#x2F;其实就是表格的左边界</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i-1][j-nums[i-1]] + dp[i-1][j];&#x2F;&#x2F;装入第i个物品或者不装入</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][S];      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据上述代码我们发现 <code>dp[i][j] = dp[i-1][...]</code> 的关系，即i至于i-1有关系，因此我们可以减少一维向量，用一维向量记录上一轮的运算结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123;</span><br><span class="line">        int n &#x3D; nums.size();</span><br><span class="line">        long sum &#x3D; 0;</span><br><span class="line">        for (int i : nums) sum +&#x3D; i;</span><br><span class="line">        if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; </span><br><span class="line">        S &#x3D; (sum + S) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; dp优化</span><br><span class="line">        vector&lt;int&gt; dp(S+1, 0);</span><br><span class="line">        dp[0] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">            for (int j &#x3D; S;j &gt;&#x3D; nums[i];j--) &#123;</span><br><span class="line">                dp[j] +&#x3D; dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return dp[S];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>eBPF 简介</title>
    <url>/2020/11/15/eBPF-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h1><ul>
<li><a href="#ebpf">eBPF</a><ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="#2-%E5%8F%82%E8%80%83%E6%9D%90%E6%96%99">2. 参考材料</a></li>
<li><a href="#3-in-kernel-virtual-machine">3. in-kernel virtual machine</a></li>
<li><a href="#4-jit-just-in-time-compile">4. JIT just-in-time compile</a></li>
<li><a href="#5-kprobe-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5. kprobe 实现原理</a></li>
</ul>
</li>
</ul>
<p><a href="https://ebpf.io/summit-2020/">ebpf summit 2020峰会</a> 这个有时间应该看一下</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>eBPF由BPF（berkeley packet filter发展而来，BPF现在也叫classic-BPF由于区别BPF），到目前为止被引入了linux内核并且使用了JIT just in time comilper进行加速，类似于浏览器的javascript脚本执行语言。</p>
<p>eBPF定义了一个内核内运行的虚拟机</p>
<p><img src="/2020/11/15/eBPF-%E7%AE%80%E4%BB%8B/ebpf-arch.png" alt="ebpf-arch"></p>
<p>使用bcc进行bpf的开发，bcc和bpftrace项目的维护放在 <strong>iovisor</strong></p>
<a id="more"></a>
<h2 id="2-参考材料"><a href="#2-参考材料" class="headerlink" title="2. 参考材料"></a>2. 参考材料</h2><ol>
<li><a href="https://lwn.net/Articles/740157/">A thorough introduction to eBPF</a></li>
<li><a href="https://lwn.net/Articles/437981/">A JIT for packet filters</a></li>
<li><a href="https://lwn.net/Articles/599755/">BPF: the universal in-kernel virtual machine</a></li>
<li><a href="https://www.youtube.com/watch?v=JRFNIKUROPE">LECTURE BPF: Tracing and More</a></li>
<li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">TUTORIAL Learn eBPF Tracing: Tutorial and Examples</a></li>
<li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners.md">TUTORIAL The bpftrace One-Liner Tutorial</a></li>
<li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">TUTORIAL bpftrace Reference Guide</a></li>
<li><a href="https://www.anquanke.com/post/id/220047">Linux内核攻击面之eBPF模块</a></li>
</ol>
<h2 id="3-in-kernel-virtual-machine"><a href="#3-in-kernel-virtual-machine" class="headerlink" title="3. in-kernel virtual machine"></a>3. in-kernel virtual machine</h2><p>Things started to change in the 3.0 release, when Eric Dumazet added a <strong>just-in-time compiler</strong> to the <strong>BPF interpreter</strong>. In the 3.4 kernel, the <strong>“secure computing” (seccomp)</strong> facility was enhanced to support a user-supplied filter for system calls; that filter, too, is written in the BPF language.</p>
<h2 id="4-JIT-just-in-time-compile"><a href="#4-JIT-just-in-time-compile" class="headerlink" title="4. JIT just-in-time compile"></a>4. JIT just-in-time compile</h2><p>Eric Dumazet’s patch is a fundamental change: it puts a just-in-time compiler into the kernel to <strong>translate BPF code directly into the host system’s assembly code.</strong> The simplicity of the BPF machine makes the JIT translation relatively simple; every BPF instruction maps to a straightforward <strong>x86 instruction sequence</strong>. </p>
<h2 id="5-kprobe-实现原理"><a href="#5-kprobe-实现原理" class="headerlink" title="5. kprobe 实现原理"></a>5. kprobe 实现原理</h2><p>这里仅做猜测，应该是直接使用kprobe技术，int3 打断点到指定位置，截取控制流到相应的probe callback 函数。</p>
]]></content>
      <categories>
        <category>eBPF</category>
      </categories>
      <tags>
        <tag>eBPF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="Next-theme-Config"><a href="#Next-theme-Config" class="headerlink" title="Next-theme Config"></a>Next-theme Config</h3><p><a href="https://tding.top/archives/42c38b10.html">Hexo-NexT (v7.0+) 主题配置</a></p>
]]></content>
  </entry>
  <entry>
    <title>io_uring 系统性整理</title>
    <url>/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="io-uring-系统性整理"><a href="#io-uring-系统性整理" class="headerlink" title="io_uring 系统性整理"></a>io_uring 系统性整理</h1><ul>
<li><a href="#io_uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86">io_uring 系统性整理</a><ul>
<li><a href="#io-%E6%A8%A1%E5%9E%8B">I/O 模型</a><ul>
<li><a href="#comparison">comparison</a></li>
</ul>
</li>
<li><a href="#asynchronous-io">Asynchronous I/O</a></li>
<li><a href="#io_uring">io_uring</a></li>
<li><a href="#%E6%80%BB%E7%BB%93%E9%82%AE%E4%BB%B6">总结邮件</a></li>
</ul>
</li>
</ul>
<p>这里有个误解，I/O模型其实是针对整个系统的所有I/O操作的，但是平时很少对文件系统使用异步读写，同步或直接映射的情况比较多。更别提多路复用了，这个机制基本只用在network中。</p>
<p><a href="https://lwn.net/Kernel/Index/">lwn Kernel article index</a></p>
<a id="more"></a>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><ul>
<li>blocking I/O</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-blocking.gif" alt="blocking"></p>
<p>同步阻塞，直到内核收到数据返回给线程。</p>
<ul>
<li>nonblocking I/O</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-nonblocking.gif" alt="nonblocking"></p>
<p>同步不阻塞，但是如果内核没收到数据会返回一个 <code>EWOULDBLOCK</code></p>
<ul>
<li>I/O multiplexing (select and poll)</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-multiplex.gif" alt="multiplex"></p>
<p>异步阻塞，使用selet（using select requires two system calls instead of one）、poll系统调用循环等待socket可读时，使用recvfrom收取数据。主要优势在于能够在单线程监控多个文件描述符fd。</p>
<p>初次之外还有epoll,使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</p>
<p>优点有：<br>    没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。<br>    效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。<br>    内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>
<p>这种方法基本等价于 一个进程创建多个线程，每个线程维护一个blocking I/O</p>
<ul>
<li>signal driven I/O (SIGIO)</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-sigio.gif" alt="multiplex"></p>
<p>非阻塞，通过sigaction系统调用安装signal handler，当datagram数据报可读时，向I/O接收进程发送SIGIO信号，可以在signal handler里面读这个数据，然后通知main loop；也可以先通知main loop，让main loop去读这个数据。</p>
<ul>
<li>asynchronous I/O (the POSIX aio_functions)</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-aio.gif" alt="aio"></p>
<p>异步非阻塞，也是调用aio_read之后立刻返回，和SIGIO的区别是直到接收到数据并将数据传输到用户时，才产生完成信号。</p>
<h3 id="comparison"><a href="#comparison" class="headerlink" title="comparison"></a>comparison</h3><p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-comparison.gif" alt="comparison"></p>
<p>参考:<br><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html">io models</a><br><a href="https://juejin.im/post/6844904200141438984">彻底理解 IO多路复用</a><br><a href="https://www.jianshu.com/p/dfd940e7fca2">聊聊IO多路复用之select、poll、epoll详解</a></p>
<h2 id="Asynchronous-I-O"><a href="#Asynchronous-I-O" class="headerlink" title="Asynchronous I/O"></a>Asynchronous I/O</h2><p>首先确定这里的AIO是内核态的，由libaio封装的系统调用运行库，而不是glibc用户态AIO，使用多线程模拟的。</p>
<p>linux kernel AIO的主要缺点在于项目泥潭，bug太多，项目设计和领导更换，而且实现比较复杂，直到现在只能比较稳定支持以O_DIRECT（直接映射修改，bypass page cache）方式打开文件，需要自己处理buffer、offset对其这些问题，不能用page cache层以bio的方式读写block数据。</p>
<p>因为使用page buffer层时涉及到block driver里面的队列，相比O_DIRECT多出很多阻塞点，因此实现起来比较令人恼火。因此这个项目根本就没实现起来。</p>
<p>因此io_uring的主要对比对象是多路复用和DPDK、SPDK，是一个事实上的新异步IO API</p>
<p>Linux AIO does suffer from a number of ailments. The subsystem is quite complex and requires explicit code in any I/O target for it to be supported.</p>
<p>实现不了的地方基本上都开一个kernel thread跑，感觉开销更大了。</p>
<p>参考：<br><a href="https://oxnz.github.io/2016/10/13/linux-aio/">Linux Asynchronous I/O</a>   </p>
<p><a href="https://lwn.net/Articles/671649/">Fixing asynchronous I/O, again</a><br><a href="https://www.aikaiyuan.com/4556.html">Linux kernel AIO这个奇葩</a><br><a href="https://lwn.net/Articles/724198/">2017Toward non-blocking asynchronous I/O</a>   </p>
<h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><p>参考：<br><a href="https://www.youtube.com/watch?v=-5T4Cjw46ys">Kernel Recipes 2019 - Faster IO through io_uring</a><br><a href="https://lwn.net/Articles/776703/">20190115Ringing in a new asynchronous I/O API</a><br><a href="https://lwn.net/Articles/826053/">20200715Operations restrictions for io_uring</a><br><a href="https://lwn.net/Articles/815491/">20200320Automatic buffer selection for io_uring</a><br><a href="https://lwn.net/Articles/810414/">20200124The rapid growth of io_uring</a><br><a href="https://lwn.net/Articles/820220/">20200511Hussain: Lord of the io_uring</a><br><a href="https://kernel.taobao.org/2019/06/io_uring-a-new-linux-asynchronous-io-API/">Linux异步IO新时代：io_uring</a><br><a href="https://lwn.net/Articles/826255/">20200716io_uring: add restrictions to support untrusted applications and guests</a><br><a href="https://lwn.net/Articles/813311/">20200225io_uring support for automatic buffers</a><br><a href="https://www.byteisland.com/io_uring%EF%BC%881%EF%BC%89-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%9C%80%E8%A6%81-io_uring/">io_uring（1） – 我们为什么会需要 io_uring</a><br><a href="https://www.anquanke.com/post/id/200486">linux “io_uring” 提权漏洞(CVE-2019-19241)分析</a><br><a href="https://www.byteisland.com/io_uring%ef%bc%882%ef%bc%89-%e4%bb%8e%e5%88%9b%e5%bb%ba%e5%bf%85%e8%a6%81%e7%9a%84%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6-fd-%e5%bc%80%e5%a7%8b/">io_uring（2）- 从创建必要的文件描述符 fd 开始</a><br><a href></a>   </p>
<p>uring这个词没有翻译”something that looks a little less like io_urine”.</p>
<p>这是一个为了高速I/O提出的新的一系列系统调用，简单来说就是新的ring buffer。之前的异步I/O策略是libaio，这个机制饱受诟病，于是Jens Axboe直接提出io_uring，性能远超aio。</p>
<p>从5.7开始超出纯I/O的范畴，io_uring开始为一部接口提供FAST POLL机制，用户无需再像使用select、event poll等多路复用机制来监听文件句柄，只要把读写请求直接丢到io_uring的submission queue中提交 ，当文件句柄不可读写时，内核会主动添加poll handler，当文件句柄可读写时主动调用poll handler再次下发读写请求，从而减少系统调用次数提高性能</p>
<p>这是一个线程粒度的异步I/O机制，分为 submission queue和completion queue，在使用系统调用申请之后，直接返回可以使用mmap映射的file discriptor。</p>
<p>应用程序可以直接使用mmap映射的两个ring buffer直接与内核进行I/O数据传输交换，减少了大量系统调用的开销。</p>
<p>具体流程：</p>
<ul>
<li>setup <code>int io_uring_setup(int entries, struct io_uring_params *params);</code></li>
</ul>
<p>其中entries表示submission and completion queues两个队列的大小</p>
<p>param中设置两个队列和具体的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct io_uring_params &#123;</span><br><span class="line">	__u32 sq_entries;</span><br><span class="line">	__u32 cq_entries;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u16 resv[10];</span><br><span class="line">	struct io_sqring_offsets sq_off;</span><br><span class="line">	struct io_cqring_offsets cq_off;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最终实现目的通过file descriptor与内核共享ring buffer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subqueue &#x3D; mmap(0, params.sq_off.array + params.sq_entries*sizeof(__u32),</span><br><span class="line">    PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,</span><br><span class="line">             ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line"></span><br><span class="line">sqentries &#x3D; mmap(0, params.sq_entries*sizeof(struct io_uring_sqe),</span><br><span class="line">    PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,</span><br><span class="line">		    ring_fd, IORING_OFF_SQES);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cqentries &#x3D; mmap(0, params.cq_off.cqes + params.cq_entries*sizeof(struct io_uring_cqe),</span><br><span class="line">      PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,</span><br><span class="line">		    ring_fd, IORING_OFF_CQ_RING);</span><br></pre></td></tr></table></figure>

<p>相关资料：<br><a href="https://lwn.net/Articles/776703/">Ringing in a new asynchronous I/O API</a><br><a href="https://lwn.net/Articles/810414/">The rapid growth of io_uring</a>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;liburing.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct io_uring ring;</span><br><span class="line">    io_uring_queue_init(32, &amp;ring, 0);</span><br><span class="line"></span><br><span class="line">    struct io_uring_sqe *sqe &#x3D; io_uring_get_sqe(&amp;ring);</span><br><span class="line">    int fd &#x3D; open(&quot;&#x2F;home&#x2F;carter&#x2F;test.txt&quot;, O_WRONLY | O_CREAT);</span><br><span class="line">    struct iovec iov &#x3D; &#123;</span><br><span class="line">        .iov_base &#x3D; &quot;Hello world&quot;,</span><br><span class="line">        .iov_len &#x3D; strlen(&quot;Hello world&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    io_uring_prep_writev(sqe, fd, &amp;iov, 1, 0);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line">    struct io_uring_cqe *cqe;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        io_uring_peek_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">        if (!cqe) &#123;</span><br><span class="line">            puts(&quot;Waiting...&quot;);</span><br><span class="line">            &#x2F;&#x2F; accept 新连接，做其他事</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            puts(&quot;Finished.&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结邮件"><a href="#总结邮件" class="headerlink" title="总结邮件"></a>总结邮件</h2><p>今天重新思考了一下IO模型，并阅读了io_uring和多路复用相关代码，感觉突然想通了。io_uring取代了AIO而不是取代了usercopy，usercopy部署的安全策略未必适用擅长传输大量数据的io_uring，这个工作可以推后再进行。具体如下。</p>
<p>一、将I/O模型的设计和实现分离</p>
<p>I/O在操作系统中含义包括与I/O设备通信和输入输出数据，I/O模型是针对第一种含义提出的解决方案。</p>
<p>linux在实现I/O的过程中参考了这些模型进行实现，但并没有在同一层次进行实现。例如LKM开发中定义的file_operations实际只包括 read（同步）/read_iter（异步）/mmap/poll 等函数指针，在I/O模型中的阻塞同步和非阻塞同步的情况可以通过使用read/read_iter 附加O_NONBLOCK的方式实现。</p>
<p>select epoll 多路复用和AIO这些I/O模型，则是分别在与之相同或不同的层次对底层函数进行封装。</p>
<p>例如 select 系统调用是在内核层通过vfs_poll遍历相关的file_descriptor，glibc实现的AIO是在用户空间多线程调用这些阻塞/非阻塞的同步/异步系统调用，epoll（更像是一个通知机制）是将select/poll中需要每次都传递的file descriptor都保存在内核中，减少了usercopy；通过event监听callback进行通知，减少了对fd的遍历开销。</p>
<p>二、思考io_uring的设计和实现</p>
<p>io_uring的设计借鉴了以上的优点，在内核空间通过kthread实现对阻塞读写任务的托管，并加入了zero copy特性，开发者可以通过一次系统调用唤醒线程一直向共享ringbuffer中写数据，而不是每次写数据都需要系统调用，这在内核和用户通信范畴内很大程度上减少了系统调用的次数，消除了usercopy的负担。</p>
<p>但无法否认io_uring是对下层file_operations的封装，下层函数又是device driver file_operations的封装（甚至对buffer I/O中间还有一层page cache、一层block layer、一层I/O schedule），因此io_uring在许多情况无法获得SPDK用户空间直通driver的性能优势。</p>
<p>三、对安全问题的思考</p>
<p>我目前理解的安全风险主要来自于usercopy造成的out-of-bound、information/pointer leakage和race情况，尤其是struct结构可能存在的函数/数据指针，但是io_uring消除掉的usercopy主要负责大量I/O数据的传输，而非带有指针的控制数据结构（io_uring中的控制数据也在用copy_*_user传输，如图），因此对安全问题的认识比我预期要复杂一些（主要问题可能是OOB和Iago攻击），需要加深对漏洞形式的理解，但好处是急迫程度下降了。</p>
<p>我只能继续积累漏洞阅读量提升认知水平，思考copy_*_user可以部署的安全机制和策略。</p>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/usercopy.PNG" alt="usercopy"></p>
<p>四、总结</p>
<p>我这阶段应该继续把重点放在kernel extension问题的描述上，对这个问题我已经基本有了一定想法，大致是将威胁模型定位为kernel rootkits，通过修改页表或切换地址空间构建运行时沙箱，使用可信基截获、保护gateway，使用hook方式监控driver相关函数和数据I/O。可以将性能的提升和对DPDK/SPDK使用的UIO和VFIO保护作为贡献点（这可能是这次突发奇想的意外收获），现在面临的问题是不确定相关方案是否有实现、近期driver保护方案相关只有四篇。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>io_uring</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>内核近期改变</title>
    <url>/2020/11/15/%E5%86%85%E6%A0%B8%E8%BF%91%E6%9C%9F%E6%94%B9%E5%8F%98/</url>
    <content><![CDATA[<h1 id="内核近期改变"><a href="#内核近期改变" class="headerlink" title="内核近期改变"></a>内核近期改变</h1><ul>
<li><a href="#%E5%86%85%E6%A0%B8%E8%BF%91%E6%9C%9F%E6%94%B9%E5%8F%98">内核近期改变</a><ul>
<li><a href="#ioctl">ioctl</a><ul>
<li><a href="#1%E5%8E%9F%E5%A7%8B%E7%89%88%E6%9C%AC%E7%9A%84ioctl">1.原始版本的ioctl</a></li>
<li><a href="#2%E5%86%85%E6%A0%B8%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84ioctl">2.内核改进后的ioctl</a></li>
<li><a href="#3%E5%9C%A8%E7%BC%96%E5%86%99%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95">3.在编写过程中的处理办法</a></li>
<li><a href="#4-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90">4. 原因分析</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5io-read_iter">异步I/O read_iter</a><ul>
<li><a href="#1%E5%85%B7%E4%BD%93%E5%8F%98%E5%8C%96">1.具体变化</a></li>
<li><a href="#2%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90">2.原因分析</a></li>
<li><a href="#3%E9%97%AE%E9%A2%98">3.问题</a></li>
</ul>
</li>
<li><a href="#timer%E8%AE%A1%E6%97%B6%E5%99%A8%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98">timer计时器发生改变</a></li>
<li><a href="#block-%E9%A9%B1%E5%8A%A8%E5%9C%A850%E5%90%8E%E8%BF%9B%E8%A1%8C%E4%BA%86%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E5%8F%98%E5%8C%96">block 驱动在5.0后进行了非常大的变化</a><ul>
<li><a href="#%E5%8E%9F%E5%9B%A0">原因</a></li>
<li><a href="#blk-mq-%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%A4%E5%B1%82%E9%98%9F%E5%88%97">blk-mq 设计了两层队列</a></li>
<li><a href="#%E5%9C%A8%E6%9E%B6%E6%9E%84%E5%B1%82%E9%9D%A2">在架构层面</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E5%88%B0%E5%87%BD%E6%95%B0">具体到函数</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E6%A0%B8%E8%AE%A1%E6%97%B6%E6%8E%A5%E5%8F%A3%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96">内核计时接口发生变化</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3%E5%8F%98%E5%8C%96%E6%9C%AA%E8%A7%A3%E5%86%B3">系统调用初始化接口变化（未解决）</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%87%8F%E5%B0%91%E5%AE%9A%E4%B9%89%E6%95%B0%E9%87%8F-%E6%9C%AA%E8%A7%A3%E5%86%B3">文件系统减少定义数量 （未解决）</a></li>
<li><a href="#jprobe-%E8%A2%AB%E5%8F%96%E6%B6%88">jprobe 被取消</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><h3 id="1-原始版本的ioctl"><a href="#1-原始版本的ioctl" class="headerlink" title="1.原始版本的ioctl"></a>1.原始版本的ioctl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long);</span><br></pre></td></tr></table></figure>

<h3 id="2-内核改进后的ioctl"><a href="#2-内核改进后的ioctl" class="headerlink" title="2.内核改进后的ioctl"></a>2.内核改进后的ioctl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line"></span><br><span class="line">long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br></pre></td></tr></table></figure>

<h3 id="3-在编写过程中的处理办法"><a href="#3-在编写过程中的处理办法" class="headerlink" title="3.在编写过程中的处理办法"></a>3.在编写过程中的处理办法</h3><ul>
<li><p>将原先的写的 ioctl 函数声明给改成下面的 unlocked_ioctl 或者 compat_ioctl,</p>
</li>
<li><p>在 file_operations 结构体的初始化中也是一样. 修改为unlocked_ioctl 或者 compat_ioctl,</p>
</li>
<li><p>注意参数的兼容性问题, 新的ioctl() 接口没有 struct inode* 参数, 如果ioctl 接口中使用了 inode, 因此需要通过其他方式获取 inode</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36)</span><br><span class="line">static int XXX_ioctl(</span><br><span class="line">        struct inode *indoe,</span><br><span class="line">        struct file *filp,</span><br><span class="line">        unsigned int cmd,</span><br><span class="line">        unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">#else</span><br><span class="line">&#x2F;&#x2F;long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">&#x2F;&#x2F;long (*compat_ioctl) (struct file *, unsigned int cmd, unsigned long arg)</span><br><span class="line">static long XXX_unlocked_ioctl(</span><br><span class="line">        struct file *filp,</span><br><span class="line">        unsigned int cmd,</span><br><span class="line">        unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;f_dentry-&gt;d_inode;</span><br><span class="line">    &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;d_inode;</span><br><span class="line">    struct inode *inode &#x3D; inode &#x3D; file_inode(filp);</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;*  此处是ioctl() 函数结构的具体实现  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，file_operations中也进行同样修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct file_operations fpga_fops &#x3D; &#123;</span><br><span class="line">    .owner  &#x3D; THIS_MODULE,</span><br><span class="line">    .open   &#x3D; fpga_open,</span><br><span class="line">    .read   &#x3D; fpga_read,</span><br><span class="line">    .write &#x3D; fpga_write,</span><br><span class="line">    .llseek &#x3D; fpga_llseek,</span><br><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36)</span><br><span class="line">    .ioctl &#x3D; XXX_ioctl,</span><br><span class="line">#else</span><br><span class="line">    .unlocked_ioctl &#x3D; XXX_unlocked_ioctl,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="4-原因分析"><a href="#4-原因分析" class="headerlink" title="4. 原因分析"></a>4. 原因分析</h3><p><code>file_operations (include/linux/fs.h)</code> 结构变化,ioctl本身并不安全，且之前的ioctl使用了大内核锁延迟太大，因此进行修改。具体内容见<br><a href="https://lwn.net/Articles/119652/">The new way of ioctl()</a></p>
<h2 id="异步I-O-read-iter"><a href="#异步I-O-read-iter" class="headerlink" title="异步I/O read_iter"></a>异步I/O read_iter</h2><h3 id="1-具体变化"><a href="#1-具体变化" class="headerlink" title="1.具体变化"></a>1.具体变化</h3><p><code>file_operations (include/linux/fs.h)</code> 结构变化，导致</p>
<p><code>read_iter</code> 和 <code>write_iter</code> 负责设备驱动的异步读写，取代了之前的 <code>aio_read</code> 和 <code>aio_write</code>,只需要将资料中二者进行转换即可。</p>
<h3 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2.原因分析"></a>2.原因分析</h3><p><a href="https://lwn.net/Articles/625077/">The iov_iter interface</a></p>
<p>iov_iter 功能增强了，并且试图合并 read(write)_iter 和 splice_read(write)，不过截至2020年5月13日来看这俩似乎还存在着</p>
<h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h3><p><code>fs/ramfs/file-mmu.c</code> 中为什么 <code>file_operations</code> 里面没有定义 read 和 write， 而只有异步I/O。</p>
<h2 id="timer计时器发生改变"><a href="#timer计时器发生改变" class="headerlink" title="timer计时器发生改变"></a>timer计时器发生改变</h2><p><a href="https://lwn.net/Articles/735887/">Improving the kernel timers API</a><br>用 <code>timer_setup</code> 替换了 <code>init_timer</code>,替换内核版本为4.14(2017)，属于较新的替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0)</span><br><span class="line">    init_timer(&amp;dev-&gt;getIntrTimer);</span><br><span class="line">    dev-&gt;getIntrTimer.data &#x3D; (unsigned long) dev;</span><br><span class="line">    dev-&gt;getIntrTimer.function &#x3D; GetIntrTimerCallback;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">    add_timer(&amp;dev-&gt;getIntrTimer);</span><br><span class="line">#else</span><br><span class="line">    timer_setup(&amp;dev-&gt;getIntrTimer, GetIntrTimerCallback, 0);</span><br><span class="line">    &#x2F;* the third argument may include TIMER_* flags *&#x2F;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>callback function的变化 <strong>参数类型发生变化，否则会编译失败</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0)</span><br><span class="line">void GetIntrTimerCallback(unsigned long devAddr)</span><br><span class="line">&#123;</span><br><span class="line">    myDevice *dev &#x3D; (myDevice *) devAddr;</span><br><span class="line">#else</span><br><span class="line">void GetIntrTimerCallback(struct timer_list *t)</span><br><span class="line">&#123;</span><br><span class="line">    myDevice *dev &#x3D; from_timer(dev, t, getIntrTimer);</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* Do something with &quot;dev&quot; *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="block-驱动在5-0后进行了非常大的变化"><a href="#block-驱动在5-0后进行了非常大的变化" class="headerlink" title="block 驱动在5.0后进行了非常大的变化"></a>block 驱动在5.0后进行了非常大的变化</h2><p><a href="https://www.linuxquestions.org/questions/linux-kernel-70/in-kernel-v5-blk_fetch_request-and-blk_init_queue-gone-now-what-4175670215/">In kernel V5 blk_fetch_request() and blk_init_queue() gone. Now What?</a>  </p>
<p><a href="https://prog.world/linux-kernel-5-0-we-write-simple-block-device-under-blk-mq/">Linux Kernel 5.0 – we write Simple Block Device under blk-mq</a>  </p>
<p><a href="https://patchwork.kernel.org/patch/10048915/">block: remove __bio_kmap_atomic</a></p>
<p><strong>内核工匠 公众号 Multiqueue架构分析</strong></p>
<p>block 驱动在5.0后进行了非常大的变化</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>是使用了 multi-queue block layer 即 blk-mq 完全取代了之前的 blk-sq（single-queue），<br>因为从前的IO速度瓶颈在硬件方面，因此可以使用单一队列，即使多个cpu竞争自旋锁获取队列写入权限依旧不过分影响性能。<br>而最近的高IOPS（io per second）硬件逐渐增多比如ssd，nvme等硬件设备开始大量使用，那么从前的single queue在高IOPS场景下80% cpu时间耗费在锁获取上了，因此设计了新的blk-mq 获取锁仅占用 3% cpu时间。</p>
<h3 id="blk-mq-设计了两层队列"><a href="#blk-mq-设计了两层队列" class="headerlink" title="blk-mq 设计了两层队列"></a>blk-mq 设计了两层队列</h3><ol>
<li><p>首先为每个cpu分配了一个软件暂存队列（software staging queue），负责完成bio 提交/完成处理，IO请求暂存（合并、排序等）、IO请求标记、调度、记账（和新的IO调度算法BFS有关）</p>
</li>
<li><p>硬件派发队列（Hardware Dispatch Queue） 为每个硬件队列分派一个硬件派发队列，负责存放软件队列向硬件派发的IO请求，一个和多个软件队列和一个硬件队列存在固定映射关系</p>
</li>
</ol>
<h3 id="在架构层面"><a href="#在架构层面" class="headerlink" title="在架构层面"></a>在架构层面</h3><p>mq 将 request 和 tag 绑定，request内存分配在块设备驱动初始化时完成（调用blk_mq_alloc_tag_set）避免IO时分配request内存带来消耗</p>
<p>tag作为request（static_rqs/rqs）的索引。</p>
<h3 id="具体到函数"><a href="#具体到函数" class="headerlink" title="具体到函数"></a>具体到函数</h3><p>有 <code>blk_fetch_request</code> , <code>__blk_end_request_cur</code>  ,<code>blk_init_queue</code>, <code>__bio_kmap_atomic(bio, iter)</code> , <code>__bio_kunmap_atomic(buffer)</code> 等</p>
<p>其中 取代 <code>__bio_kmap_atomic(bio, iter)</code> , <code>__bio_kunmap_atomic(buffer)</code> 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-		char *buffer &#x3D; __bio_kmap_atomic(bio, iter);</span><br><span class="line">+		char *buffer &#x3D; kmap_atomic(bvec.bv_page) + bvec.bv_offset;</span><br><span class="line"> 		unsigned len &#x3D; bvec.bv_len &gt;&gt; SECTOR_SHIFT;</span><br><span class="line"> </span><br><span class="line"> 		simdisk_transfer(dev, sector, len, buffer,</span><br><span class="line"> 				bio_data_dir(bio) &#x3D;&#x3D; WRITE);</span><br><span class="line"> 		sector +&#x3D; len;</span><br><span class="line">-		__bio_kunmap_atomic(buffer);</span><br><span class="line">+		kunmap_atomic(buffer)</span><br></pre></td></tr></table></figure>

<p>除此之外 <code>BLK_MQ_F_SG_MERGE</code> 和 <code>QUEUE_FLAG_NO_SG_MERGE</code>  都可以被省略了<br><a href="https://lore.kernel.org/patchwork/patch/1042759/">block: kill BLK_MQ_F_SG_MERGE</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-	lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;</span><br><span class="line">+	lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE;</span><br></pre></td></tr></table></figure>

<h2 id="内核计时接口发生变化"><a href="#内核计时接口发生变化" class="headerlink" title="内核计时接口发生变化"></a>内核计时接口发生变化</h2><p>64位系统中,由于<a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038问题</a> 时间戳 timespec 在 inode数据结构中的i_*time 中弃用，转而使用 timespec64</p>
<p>相应的 getnstimeofday 等函数也被弃用， 转而使用 <code>ktime_get_ts64(struct timespec64 *ts)</code> 等函数获取时间，另外需要注意 这个函数必须使用 GPL协议才能成功加载。</p>
<p>详见内核时间api文件，<br><a href="https://www.kernel.org/doc/html/latest/core-api/timekeeping.html">ktime accessors</a></p>
<p>最新设计的时间数据结构为 <code>ktime_t</code> 获取方式为 <code>ktime_t ktime_get(void)</code></p>
<h2 id="系统调用初始化接口变化（未解决）"><a href="#系统调用初始化接口变化（未解决）" class="headerlink" title="系统调用初始化接口变化（未解决）"></a>系统调用初始化接口变化（未解决）</h2><p>系统调用初始化接口代码越变越少，而且有点难以理解，除了在<code>arch/x86/entry/syscall</code> 目录下定义之外，还用了同目录下的脚本直接生成了ni代码</p>
<p>具体的解决办法是直接ftrace跟踪一波，看看syscall最新的调用路径</p>
<h2 id="文件系统减少定义数量-（未解决）"><a href="#文件系统减少定义数量-（未解决）" class="headerlink" title="文件系统减少定义数量 （未解决）"></a>文件系统减少定义数量 （未解决）</h2><p>文件系统减少了大量file_operations定义数量，例如 aio_read  aio_write 等异步代码直接被省略掉，read 和 write 接口基本也不定义了， 似乎使用了 read_iter 和 write_iter 替代了前两类接口</p>
<p>具体原因还没搞清楚，但是在 <a href="https://lore.kernel.org/patchwork/patch/350494/">[V5,17/30] fs: use read_iter and write_iter rather than aio_read and aio_write</a> 中显示 aio被明确删除掉，用iter替代。</p>
<p>此外 <code>file_operations</code> 当中的 readdir 等接口也被取消，直接由read/read_iter和 iterate 替代,iterate基本上可以理解为负责执行ls命令， filldentry_t 由 dir_context 替代。</p>
<h2 id="jprobe-被取消"><a href="#jprobe-被取消" class="headerlink" title="jprobe 被取消"></a>jprobe 被取消</h2><p>在 kprobe中只剩下kprobe和kretprobe，jprobe及相关的一套函数被取消，替代方式如下：</p>
<p><code>/source/samples/kprobes/kprobe_example.c</code> 和 <code>/source/samples/kprobes/kretprobe_example.c</code> 中示例</p>
<p>使用kprobe中的handler_pre和handler_post替代。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel contribution 统计</title>
    <url>/2020/11/16/kernel-contribution-%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>保存lwn.net发布的新版本开发统计文章，目前来看还是华为最屌。</p>
<p><a href="https://lwn.net/Articles/780271/">Development statistics for the 5.0 kernel</a><br>As of this writing, 12,517 non-merge changesets have been pulled into the mainline repository for the 5.0 release</p>
<p><a href="https://lwn.net/Articles/810639/">Some 5.5 kernel development statistics</a><br>5.5 saw the merging of 14,350 non-merge changesets from 1,885 developers</p>
<a id="more"></a>

<p><a href="https://lwn.net/Articles/816162/">Some 5.6 kernel development statistics</a><br>12,665 non-merge changesets had been accepted from 1,712 developers</p>
<p><a href="https://lwn.net/Articles/821813/">Development statistics for the 5.7 kernel</a><br>Work on 5.7 arrived in the form of 13,901 non-merge changesets contributed by 1,878 developers;</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>lwn.net</tag>
      </tags>
  </entry>
  <entry>
    <title>三剑客sed/awk/grep常用速查</title>
    <url>/2020/11/16/%E4%B8%89%E5%89%91%E5%AE%A2sed-awk-grep%E5%B8%B8%E7%94%A8%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<p>sed和awk的区别，都是按行读入，但是awk会拆分行里面的元素，sed则直接用正则做匹配，基本上sed可以做到的awk都可以。</p>
<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p><code>awk &#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39; netstat.txt</code> awk 使用print和printf打印每行中按列分布的元素。</p>
<p><code>awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot;&#39; netstat.txt</code> 过滤记录</p>
<p><code>awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot; || NR==1 &#123;printf &quot;%02s %s %-20s %-20s %s\n&quot;,NR, FNR, $4,$5,$6&#125;&#39; netstat.txt</code> 其中NR，FNR为内建变量</p>
<a id="more"></a>
<ul>
<li>$0    当前记录（这个变量中存放着整个行的内容）</li>
<li>$1~$n    当前记录的第n个字段，字段间由FS分隔</li>
<li>FS    输入字段分隔符 默认是空格或Tab</li>
<li>NF    当前记录中的字段个数，就是有多少列</li>
<li>NR    已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。</li>
<li>FNR    当前记录数，与NR不同的是，这个值会是各个文件自己的行号</li>
<li>RS    输入的记录分隔符， 默认为换行符</li>
<li>OFS    输出字段分隔符， 默认也是空格</li>
<li>ORS    输出的记录分隔符，默认为换行符</li>
<li>FILENAME    当前输入文件的名字</li>
</ul>
<p><code>awk  &#39;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1,$3,$6&#125;&#39; /etc/passwd</code> 指定分隔符</p>
<p><code>awk &#39;$6 ~ /E/ || NR==1 &#123;print NR, $4,$5,$6&#125;&#39; netstat.txt</code> ~表示开始，//表示匹配，这行命令表示匹配第六个元素开始包含E的行和第一行，然后输出行数和第456个元素。</p>
<p><code>awk &#39;NR!=1&#123;print $4,$5 &gt; $6&#125;&#39; netstat.txt</code> 不处理第一行，按照第六列元素分类拆分成若干个文件，文件的内容是第45列元素。</p>
<h2 id="awk-脚本"><a href="#awk-脚本" class="headerlink" title="awk 脚本"></a>awk 脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;awk -f</span><br><span class="line"># 运行前</span><br><span class="line">BEGIN &#123;</span><br><span class="line">	math &#x3D; 0</span><br><span class="line">	english &#x3D; 0</span><br><span class="line">	computer &#x3D; 0</span><br><span class="line"></span><br><span class="line">	printf &quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;</span><br><span class="line">	printf &quot;---------------------------------------------\n&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 运行中</span><br><span class="line">&#123;</span><br><span class="line">	math +&#x3D; $3</span><br><span class="line">	english +&#x3D; $4</span><br><span class="line">	computer +&#x3D; $5</span><br><span class="line">	printf &quot;%-6s %-6s %4d %8d %8d %8d\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5</span><br><span class="line">&#125;</span><br><span class="line"># 运行之后</span><br><span class="line">END &#123;</span><br><span class="line">	printf &quot;---------------------------------------------\n&quot;</span><br><span class="line">	printf &quot;  TOTAL:%10d %8d %8d \n&quot;, math, english, computer</span><br><span class="line">	printf &quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;, math&#x2F;NR, english&#x2F;NR, computer&#x2F;NR</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>awk -v val=$x &#39;&#123;print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]&#125;&#39; OFS=&quot;\t&quot; score.txt</code> 其中x，y为环境变量，为了使用环境变量需要 -v</p>
<p><code>echo $PATH| awk &#39;BEGIN&#123;RS=&quot;:&quot;&#125;&#123;print NR,$0&#125;&#39;</code> 把单行拆分成多行</p>
<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p><code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code></p>
<ul>
<li><p>e&lt;script&gt;或–expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。</p>
</li>
<li><p>f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</p>
</li>
<li><p>h或–help 显示帮助。</p>
</li>
<li><p>n或–quiet或–silent 仅显示script处理后的结果。</p>
</li>
<li><p>V或–version 显示版本信息。</p>
</li>
<li><p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</p>
</li>
<li><p>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</p>
</li>
<li><p>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</p>
</li>
<li><p>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</p>
</li>
<li><p>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</p>
</li>
<li><p>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</p>
</li>
</ul>
<p><code>sed &quot;s/my/ppw &#39;s/g&quot; pets.txt</code> 把pets.txt文件的my改成ppw’s，并不修改文件。/g 表示一行上的替换所有的匹配</p>
<p>加入-i <code>sed -i &quot;s/my/ppw &#39;s/g&quot; pets.txt</code>可以直接修改文件</p>
<p><code>sed &#39;s/^/---/g&#39; pets.txt</code> 在开头加上—</p>
<p><code>sed &#39;s/$/---/g&#39; pets.txt</code> 在结尾加上—</p>
<p>同理类似的有：</p>
<ul>
<li>\&lt; 表示词首。 如：&lt;abc 表示以 abc 为首的詞。</li>
<li>\&gt; 表示词尾。 如：abc&gt; 表示以 abc 結尾的詞。</li>
<li>. 表示任何单个字符。</li>
<li>* 表示某个字符出现了0次或多次。</li>
<li><input disabled type="checkbox"> 字符集合。 如：[abc] 表示匹配a或b或c，还有 [a-zA-Z] 表示匹配所有的26个字符。如果其中有^表示反，如 [^a] 表示非a的字符</li>
</ul>
<p><code>sed &#39;s/&lt;[^&gt;]*&gt;//g&#39; html.txt</code> 取消html文件中的&lt;&gt;tags,不能使用<code>&#39;s/&lt;.*&gt;&#39;//g</code>，因为会贪婪匹配掉第一个《和最后一个》之间所有的内容，现在给出的示例是匹配除了&gt;意外的字符。</p>
<p><code>sed &#39;3s/my/your/g&#39; pets.txt</code> 和 <code>sed &#39;3,6s/my/your/g&#39; pets.txt</code>，分别表示匹配第三行和第三到六行。</p>
<p><code>sed &#39;s/s/S/1&#39; pets.txt</code> 匹配每一行的第一个s</p>
<p><code>sed &#39;1,3s/my/your/g; 3,$s/This/That/g&#39; pets.txt</code> 匹配多个</p>
<p><code>sed &#39;s/my/[&amp;]/g&#39; pets.txt</code> 使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西</p>
<p><code>sed &#39;s/This is my \([^,]*\),.*is \(.*\)/\1:\2/g&#39; my.txt</code> 圆括号括起来的正则表达式所匹配的字符串会可以当成变量来使用，sed中使用的是\1,\2…</p>
<p><code>sed &#39;N;s/my/your/&#39; pets.txt</code> 原文本中的偶数行纳入奇数行匹配，而s只匹配并替换一次，所以最后只有奇数行被修改。 N命令把下一行的内容纳入当成缓冲区做匹配。</p>
<p><code>sed &quot;1 i This is my monkey, my monkey&#39;s name is wukong&quot; my.txt</code> 和 <code>sed &quot;$ a This is my monkey, my monkey&#39;s name is wukong&quot; my.txt</code>  命令i和a分别表示insert 和 append，添加行</p>
<p><code>sed &quot;/my/a ----&quot; my.txt</code> 在每行结尾都添加 —-</p>
<p><code>sed &quot;2 c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt</code> 和 <code>sed &quot;/fish/c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt</code> 命令c表示替换，这两个命令分别表示替换第二行和有’fish’存在的那一行。</p>
<p><code>sed &#39;/fish/d&#39; my.txt</code> 和 <code>sed &#39;2d&#39; my.txt</code> 和 <code>sed &#39;2,$d&#39; my.txt</code> 命令d表示删除匹配行，这三个命令分别表示删除有fish的一行，删除第二行和删除第二到最后的所有行。</p>
<p><code>sed -n &#39;/dog/,/fish/p&#39; my.txt</code> 命令-n表示只显示处理后的结果，命令p表示打印，图中命令表示打印有dog的一行和有fish的一行。</p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p><code>grep -i -c &#39;.*ret.*&#39; linux-exec.s</code> 统计内核二级制文件中ret命令的个数，不区分大小写，直接输出匹配行数。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>linux</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry Pi 内核编译</title>
    <url>/2020/11/16/Raspberry-Pi-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p><strong>我的版本 : 树莓派3</strong></p>
<h1 id="1-内核获取"><a href="#1-内核获取" class="headerlink" title="1.内核获取"></a>1.内核获取</h1><h2 id="1-1-软件下载"><a href="#1-1-软件下载" class="headerlink" title="1.1.软件下载"></a>1.1.软件下载</h2><p><code>sudo apt install git bc bison flex libssl-dev make</code></p>
<a id="more"></a>

<h3 id="关于libssl-dev的小问题"><a href="#关于libssl-dev的小问题" class="headerlink" title="关于libssl-dev的小问题"></a>关于libssl-dev的小问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install aptitude</span><br><span class="line"></span><br><span class="line">dpkg -l *libssl*</span><br><span class="line"></span><br><span class="line">sudo aptitude install libssl-dev</span><br></pre></td></tr></table></figure>


<h2 id="1-2-源码获取"><a href="#1-2-源码获取" class="headerlink" title="1.2.源码获取"></a>1.2.源码获取</h2><p><code>git clone --depth=1 https://github.com/raspberrypi/linux</code></p>
<h1 id="2-内核编译"><a href="#2-内核编译" class="headerlink" title="2.内核编译"></a>2.内核编译</h1><p>预设环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd linux</span><br><span class="line">KERNEL&#x3D;kernel7</span><br><span class="line">make bcm2709_defconfig</span><br><span class="line">或者 zcat &#x2F;proc&#x2F;config.gz &gt; .config   #从现在原有版本的内核中复制配置文件</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j4 zImage modules dtbs</span><br><span class="line">sudo make modules_install</span><br><span class="line">sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;*.dtb &#x2F;boot&#x2F;</span><br><span class="line">sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;*.dtb* &#x2F;boot&#x2F;overlays&#x2F;</span><br><span class="line">sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;README &#x2F;boot&#x2F;overlays&#x2F;</span><br><span class="line">sudo cp arch&#x2F;arm&#x2F;boot&#x2F;zImage &#x2F;boot&#x2F;$KERNEL.img</span><br></pre></td></tr></table></figure>

<h1 id="3-更换内核"><a href="#3-更换内核" class="headerlink" title="3.更换内核"></a>3.更换内核</h1><p>修改 <code>/boot/config.txt</code> 文件中内容</p>
<p><code>kernel=kernel-myconfig.img</code></p>
<p>myconfig的版本在<code>/lib/modules/</code> 文件夹中。</p>
<h1 id="4-参考文件"><a href="#4-参考文件" class="headerlink" title="4.参考文件"></a>4.参考文件</h1><p><a href="https://www.raspberrypi.org/documentation/linux/kernel/building.md" title="building">DOCUMENTATION &gt; LINUX &gt; KERNEL &gt; BUILDING</a></p>
]]></content>
      <categories>
        <category>kernel</category>
        <category>raspberryPi</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>raspberryPi</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU研究生通知RSS</title>
    <url>/2020/11/19/NJU%E7%A0%94%E7%A9%B6%E7%94%9F%E9%80%9A%E7%9F%A5RSS/</url>
    <content><![CDATA[<h1 id="NJU-notifeed"><a href="#NJU-notifeed" class="headerlink" title="NJU-notifeed"></a>NJU-notifeed</h1><p>Nanjing University notification feed</p>
<p><a href="https://github.com/purplewall1206/NJU-notifeed">https://github.com/purplewall1206/NJU-notifeed</a></p>
<p><strong>直接订阅：</strong><br><a href="http://idcvz.zi-c.wang:8000/rss">http://idcvz.zi-c.wang:8000/rss</a></p>
<a id="more"></a>


<p>主要收集以下两个网站的最新通知，生成统一的feed提供给本地部署的RSS阅读器（i.e. Thunderbird） </p>
<p><a href="https://grawww.nju.edu.cn/">https://grawww.nju.edu.cn</a></p>
<p><a href="http://pyb.nju.edu.cn/">http://pyb.nju.edu.cn/</a></p>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>使用requests和beautifulsoup4制作爬虫，获取通知页面的信息条目news</p>
<p>使用PyRSS2Gen生成feed条目，并写到feed.xml文件中（这里有个问题，lib好像只提供文件写入函数了，暂时没找到其他的output方式）</p>
<p>使用Flask构建RESTful API，访问 <a href="http://url/rss">http://url/rss</a> 获取feed</p>
<p>使用多线程其中一个线程运行爬虫，主线程（flask单线程）维护API</p>
<p>文件结构：</p>
<ul>
<li>news.py news struct，存储消息的属性</li>
<li>crawlerPYB/GRA.py 两个网站的爬虫策略</li>
<li>__init__.py 主函数，通过多线程的方式每小时更新一次feed。</li>
<li>logging.txt 记录调用日志</li>
<li>requirement.txt 安装的python lib，<code>sudo pip install -r requirement.txt</code></li>
</ul>
<p>ubuntu 运行面对的问题 <code>sudo apt-get install python3-html5lib</code></p>
]]></content>
      <categories>
        <category>python</category>
        <category>rss</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>rss</tag>
        <tag>github</tag>
        <tag>NJU</tag>
      </tags>
  </entry>
</search>
