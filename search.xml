<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux User-mode Driver</title>
    <url>/2020/11/28/Linux-User-mode-Driver/</url>
    <content><![CDATA[<h2 id="UIO-userspace-i-o"><a href="#UIO-userspace-i-o" class="headerlink" title="UIO userspace i/o"></a>UIO userspace i/o</h2><p><a href="https://lwn.net/Articles/825190/">20200702Make the user mode driver code a better citizen</a><br><a href="https://lwn.net/Articles/66829/">20040120User-space device drivers</a><br><a href="https://tldp.org/LDP/khg/HyperNews/get/devices/fake.html">tldp userspace device driver</a><br><a href="https://lwn.net/Articles/703785/">20161019Linux drivers in user space — a survey</a><br><a href="https://lwn.net/Articles/232575/">UIO: user-space drivers</a><br><a href="https://www.kernel.org/doc/html/latest/driver-api/uio-howto.html?highlight=uio">The Userspace I/O HOWTO</a></p>
<a id="more"></a>

<p>UIO因为不支持DMA已经被vfio取代了,zd 2.6.22被引入</p>
<p>UIO的目的，对于有些设备来说创建Linux kernel driver有点多余了，这些设备只是需要处理中断和提供对device内存区域的访问，例如industrial I/O card。</p>
<p>UIO不完全排除内核空间代码的使用，需要一个小的模块负责device设置，PCI总线接口、注册interrupt handler等</p>
<p>相关数据结构在<code>linux/uio_driver.h</code>,在sysfs和/dev/uioX 导出用户接口，使用dev的接口进行设备控制，mmap映射设备的寄存器或者RAM，通过读dev/uioX处理中断（可以通过select），每个UIO设备可以创建一个或多个内存区域能够进行内存映射，因为一些industrial I/O card在driver中需要访问超过一个PCI内存区域</p>
<p>UIO驱动是char drivers，没有block和network drivers，不能在用户态设置DMA</p>
<p><img src="/2020/11/28/Linux-User-mode-Driver/usermodedriver-UIO.gif" alt="usermodedriver-UIO"></p>
<h2 id="VFIO"><a href="#VFIO" class="headerlink" title="VFIO"></a>VFIO</h2><p><a href="https://www.kernel.org/doc/Documentation/vfio.txt">vfio-kernel document</a><br><a href="https://lwn.net/Articles/473234/">VFIO core framework</a><br><a href="https://lwn.net/Articles/499240/">VFIO</a><br><a href="https://lwn.net/Articles/815745/">vfio: expose virtual Shared Virtual Addressing to VMs</a><br><a href="https://lwn.net/Articles/474088/">Safe device assignment with VFIO</a><br><a href="https://www.cnblogs.com/yi-mu-xi/p/10515609.html">IOMMU &amp; iomap &amp;VFIO &amp; uio</a><br><a href="https://www.kernel.org/doc/Documentation/vfio.txt">VFIO - “Virtual Function I/O”</a></p>
<p>VFIO 把内核态的和IO相关的内存区域、IO port和DMA暴露给用户态，可以用KVM做设备直通，也可以构建用户态driver。也是通过 /dev/vfio暴露接口，通过IOCTL系统调用发送操作device的command</p>
<p>在VFIO中虚拟机直通的最小单元不再是单独的设备，而是同一group里面的所有设备，而仅仅通过IOMMU设置直通则无法处理多个有联系的PCI设备的相互访问。因此VFIO集成了IOMMU和UIO的优点。</p>
<p><img src="/2020/11/28/Linux-User-mode-Driver/usermodedriver-vfio.png" alt="usermodedriver-vfio"></p>
<h2 id="DPDK-Data-Plane-Development-Kit"><a href="#DPDK-Data-Plane-Development-Kit" class="headerlink" title="DPDK Data Plane Development Kit"></a>DPDK Data Plane Development Kit</h2><p><a href="https://www.jianshu.com/p/86af81a10195">DPDK介绍</a><br><a href="https://lwn.net/Articles/725254/">Network acceleration with DPDK</a>   </p>
<p>是一种intel使用intel硬件提供的用户空间的网络驱动解决方案。用于快速数据包处理的函数库与驱动集合，可以极大提高数据处理性能和吞吐量，提高数据平面应用程序的工作效率。</p>
<p>DPDK使用了轮询(polling)而不是中断来处理数据包。在收到数据包时，经DPDK重载的网卡驱动不会通过中断通知CPU，而是直接将数据包存入内存，交付应用层软件通过DPDK提供的接口来直接处理，这样节省了大量的CPU中断时间和内存拷贝时间</p>
<p> DPDK defines an execution environment which contains user-space network drivers.</p>
<p>具体优点是使用了HUGEPAGE和numa，CPU亲和等硬件技术，加快运行速度，还有使用了UIO或VFIO技术直接暴露设备内存通过zero copy的方式减少系统调用和复制数据开销。</p>
<p><img src="/2020/11/28/Linux-User-mode-Driver/usermodedriver-dpdk.PNG" alt="dpdk"></p>
<h2 id="SPDK-storage-performance-development-kit"><a href="#SPDK-storage-performance-development-kit" class="headerlink" title="SPDK  storage performance development kit"></a>SPDK  storage performance development kit</h2><p>给NVME-ssd设计的高速工具包，intel提供的使用intel网络、处理、存取技术，充分发挥固态存储的优势，采用了UIO和polling，将驱动代码运行在内核态，多路复用取代阻塞I/O。</p>
<p>其中也涉及不少实现细节，但总之是当下速度比较快的一种I/O工具。实现思路和DPDK一样，也是取消get/put_user，mmap直接干。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://lwn.net/Articles/703785/">Linux drivers in user space — a survey</a><br><a href="https://tldp.org/LDP/khg/HyperNews/get/devices/fake.html">User-space device drivers</a><br><a href="https://lwn.net/Articles/66829/">User-space device drivers</a><br><a href="https://lwn.net/Articles/825190/">Make the user mode driver code a better citizen</a></p>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>Driver</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU研究生通知RSS</title>
    <url>/2020/11/19/NJU%E7%A0%94%E7%A9%B6%E7%94%9F%E9%80%9A%E7%9F%A5RSS/</url>
    <content><![CDATA[<h1 id="NJU-notifeed"><a href="#NJU-notifeed" class="headerlink" title="NJU-notifeed"></a>NJU-notifeed</h1><p>Nanjing University notification feed</p>
<p><a href="https://github.com/purplewall1206/NJU-notifeed">https://github.com/purplewall1206/NJU-notifeed</a></p>
<p><strong>直接订阅：</strong><br><a href="http://idcvz.zi-c.wang:8000/rss">http://idcvz.zi-c.wang:8000/rss</a></p>
<a id="more"></a>


<p>主要收集以下两个网站的最新通知，生成统一的feed提供给本地部署的RSS阅读器（i.e. Thunderbird） </p>
<p><a href="https://grawww.nju.edu.cn/">https://grawww.nju.edu.cn</a></p>
<p><a href="http://pyb.nju.edu.cn/">http://pyb.nju.edu.cn/</a></p>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>使用requests和beautifulsoup4制作爬虫，获取通知页面的信息条目news</p>
<p>使用PyRSS2Gen生成feed条目，并写到feed.xml文件中（这里有个问题，lib好像只提供文件写入函数了，暂时没找到其他的output方式）</p>
<p>使用Flask构建RESTful API，访问 <a href="http://url/rss">http://url/rss</a> 获取feed</p>
<p>使用多线程其中一个线程运行爬虫，主线程（flask单线程）维护API</p>
<p>文件结构：</p>
<ul>
<li>news.py news struct，存储消息的属性</li>
<li>crawlerPYB/GRA.py 两个网站的爬虫策略</li>
<li>__init__.py 主函数，通过多线程的方式每小时更新一次feed。</li>
<li>logging.txt 记录调用日志</li>
<li>requirement.txt 安装的python lib，<code>sudo pip install -r requirement.txt</code></li>
</ul>
<p>ubuntu 运行面对的问题 <code>sudo apt-get install python3-html5lib</code></p>
<h1 id="启动问题"><a href="#启动问题" class="headerlink" title="启动问题"></a>启动问题</h1><p>加入description信息获取之后，服务器往往无法立即反应，需要等到logging中显示出爬虫已经完全获取信息的日志之后，才能通过网站访问。需要处理一下这个问题，应该是global被锁住，服务器比爬虫先启动导致的。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>rss</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>rss</tag>
        <tag>github</tag>
        <tag>NJU</tag>
      </tags>
  </entry>
  <entry>
    <title>Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1的自动部署脚本</title>
    <url>/2016/10/18/Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>在阳总的帮助下，终于搞出了这个自动部署脚本，感谢阳总让我第一次看到真人写的bash脚本，很涨姿势。</p>
<ul>
<li><p>hbase-0.98-hadoop 的选择原因是[<a href="http://wiki.apache.org/nutch/Nutch2Tutorial">http://wiki.apache.org/nutch/Nutch2Tutorial</a> ](nutch turorial)上这么推荐的</p>
</li>
<li><p>solr5.x 的玩法似乎和solr4.9 差别不小，之后应该会单独写一篇分析的</p>
</li>
<li><p>测试环境是 centos6环境，使用ubuntu或者其他发行版的兄弟记得改下 那堆yum，rpm</p>
<a id="more"></a>
<pre><code> #!/bin/bash </code></pre>
<p>这个写到一开头表示这是<strong>.sh</strong>那一类文件，剩下的就是用重定向之类的linux下的特殊写法追加写入文本的</p>
</li>
<li><p>脚本中的所有文件都将被部署到 <strong>/usr</strong> 目录下，如果改目录需要连着配置文件一起改，权限不够加<strong>sudo</strong></p>
</li>
<li><p>nutch crawl solr hbase 都写入环境变量，可以在任何目录下运行。</p>
</li>
<li><p>nutch 执行的是 /usr/nutch-2/runtime/local/bin/nutch 目录的文件，而不是deploy中</p>
</li>
<li><p>之后集成hadoop再修改配置文件。</p>
</li>
</ul>
<p>以下是自动部署脚本，需要复制下来制作成 <strong>.sh</strong> 文件，使用 <pre><code> sudo bash xxx.sh </code></pre> 执行</p>
<figure class="highlight bash"><figcaption><span>自动部署脚本</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">rpm -Uvh https://centos6.iuscommunity.org/ius-release.rpm</span><br><span class="line">yum install epel-release -y</span><br><span class="line">yum install git wget screen vim -y</span><br><span class="line">yum update -y</span><br><span class="line"></span><br><span class="line">iptables -F</span><br><span class="line">iptables-save</span><br><span class="line">service iptables save</span><br><span class="line">ip6tables -F</span><br><span class="line">ip6tables-save</span><br><span class="line">service ip6tables save</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">wget --no-cookies --no-check-certificate --header <span class="string">&quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot;</span> <span class="string">&quot;http://download.oracle.com/otn-pub/java/jdk/8u102-b14/jdk-8u102-linux-x64.rpm&quot;</span></span><br><span class="line">rpm -ivh jdk-8u102-linux-x64.rpm</span><br><span class="line">rm -rf jdk-8u102-linux-x64.rpm</span><br><span class="line"></span><br><span class="line">wget http://archive.apache.org/dist/hbase/hbase-0.98.8/hbase-0.98.8-hadoop2-bin.tar.gz</span><br><span class="line">tar xzf hbase-0.98.8-hadoop2-bin.tar.gz</span><br><span class="line">rm -rf hbase-0.98.8-hadoop2-bin.tar.gz</span><br><span class="line">mv hbase-0.98.8-hadoop2 /usr/hbase</span><br><span class="line"></span><br><span class="line">wget http://www-eu.apache.org/dist/nutch/2.3.1/apache-nutch-2.3.1-src.tar.gz</span><br><span class="line">tar xzf apache-nutch-2.3.1-src.tar.gz</span><br><span class="line">rm -rf apache-nutch-2.3.1-src.tar.gz</span><br><span class="line">mv apache-nutch-2.3.1 /usr/nutch-2</span><br><span class="line">chmod -R 777 /usr/nutch-2</span><br><span class="line"></span><br><span class="line">wget http://www-us.apache.org/dist/ant/binaries/apache-ant-1.9.7-bin.tar.gz</span><br><span class="line">tar xzf apache-ant-1.9.7-bin.tar.gz</span><br><span class="line">rm -rf apache-ant-1.9.7-bin.tar.gz</span><br><span class="line">mv apache-ant-1.9.7 /usr/ant</span><br><span class="line"></span><br><span class="line">wget http://archive.apache.org/dist/lucene/solr/5.2.1/solr-5.2.1.tgz</span><br><span class="line">tar xzf solr-5.2.1.tgz</span><br><span class="line">rm -rf solr-5.2.1.tgz</span><br><span class="line">mv solr-5.2.1 /usr/solr</span><br><span class="line"></span><br><span class="line">rm -rf ~/envtemp</span><br><span class="line">cat &gt; ~/envtemp&lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#set JDK environment</span></span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_102</span><br><span class="line">JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">CLASS_PATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="comment">#set ANT environment</span></span><br><span class="line">ANT_HOME=/usr/ant</span><br><span class="line"><span class="comment">#set HBASE environment</span></span><br><span class="line">HBASE_HOME=/usr/hbase</span><br><span class="line"><span class="comment">#set LOCAL_NUTCH environment</span></span><br><span class="line">NUTCH_HOME=/usr/nutch-2/runtime/<span class="built_in">local</span></span><br><span class="line"><span class="comment">#set SOLR environment</span></span><br><span class="line">SOLR_HOME=/usr/solr</span><br><span class="line"><span class="comment">#set HADOOP environment</span></span><br><span class="line">HADOOP_HOME=/usr/hadoop</span><br><span class="line">HADOOP_INSTALL=<span class="variable">$HADOOP_HOME</span></span><br><span class="line">HADOOP_MAPRED_HOME=<span class="variable">$HADOOP_HOME</span></span><br><span class="line">HADOOP_COMMON_HOME=<span class="variable">$HADOOP_HOME</span></span><br><span class="line">HADOOP_HDFS_HOME=<span class="variable">$HADOOP_HOME</span></span><br><span class="line">YARN_HOME=<span class="variable">$HADOOP_HOME</span></span><br><span class="line">HADOOP_COMMON_LIB_NATIVE_DIR=<span class="variable">$HADOOP_HOME</span>/lib/native</span><br><span class="line">HADOOP_OPTS=<span class="string">&quot;-Djava.library.path=<span class="variable">$HADOOP_HOME</span>/lib:<span class="variable">$HADOOP_COMMON_LIB_NATIVE_DIR</span>&quot;</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$ANT_HOME</span>/bin:<span class="variable">$HBASE_HOME</span>/bin:<span class="variable">$NUTCH_HOME</span>/bin:<span class="variable">$SOLR_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME JRE_HOMECLASS_PATH ANT_HOME HBASE_HOME NUTCH_HOME SOLR_HOME HADOOP_HOME HADOOP_INSTALL HADOOP_MAPRED_HOME HADOOP_COMMON_HOME HADOOP_HDFS_HOME YARN_HOME HADOOP_COMMON_LIB_NATIVE_DIR HADOOP_OPTS PATH</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">rm -rf ~/profile</span><br><span class="line">cp /etc/profile ~/profile</span><br><span class="line">cat ~/profile ~/envtemp &gt;/etc/profile</span><br><span class="line"></span><br><span class="line">rm -rf ~/envtemp ~/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget http://www.senra.me/nutch-solr/nutch-site.xml</span><br><span class="line">wget http://www.senra.me/nutch-solr/gora.properties</span><br><span class="line">wget http://www.senra.me/nutch-solr/ivy.xml</span><br><span class="line">wget http://www.senra.me/nutch-solr/hbase-site.xml</span><br><span class="line">wget http://www.senra.me/nutch-solr/solr.xml</span><br><span class="line">\cp -a ~/nutch-site.xml /usr/nutch-2/conf/</span><br><span class="line">\cp -a ~/gora.properties /usr/nutch-2/conf/</span><br><span class="line">\cp -a ~/ivy.xml /usr/nutch-2/ivy/</span><br><span class="line">\cp -a ~/hbase-site.xml /usr/hbase/conf/</span><br><span class="line">\cp -a ~/solr.xml /usr/solr/</span><br><span class="line">rm -rf ~/nutch-site.xml ~/gora.properties ~/ivy.xml ~/hbase-site.xml ~/solr.xml</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/nutch-2</span><br><span class="line">ant runtime</span><br><span class="line"></span><br><span class="line">/usr/hbase/bin/start-hbase.sh</span><br><span class="line">/usr/solr/bin/solr start</span><br><span class="line">/usr/solr/bin/solr create_core -c demo</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>20号之后的大创答辩加油！争取国家级！</li>
</ul>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry Pi 内核编译</title>
    <url>/2020/11/16/Raspberry-Pi-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p><strong>我的版本 : 树莓派3</strong></p>
<h1 id="1-内核获取"><a href="#1-内核获取" class="headerlink" title="1.内核获取"></a>1.内核获取</h1><h2 id="1-1-软件下载"><a href="#1-1-软件下载" class="headerlink" title="1.1.软件下载"></a>1.1.软件下载</h2><p><code>sudo apt install git bc bison flex libssl-dev make</code></p>
<a id="more"></a>

<h3 id="关于libssl-dev的小问题"><a href="#关于libssl-dev的小问题" class="headerlink" title="关于libssl-dev的小问题"></a>关于libssl-dev的小问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install aptitude</span><br><span class="line"></span><br><span class="line">dpkg -l *libssl*</span><br><span class="line"></span><br><span class="line">sudo aptitude install libssl-dev</span><br></pre></td></tr></table></figure>


<h2 id="1-2-源码获取"><a href="#1-2-源码获取" class="headerlink" title="1.2.源码获取"></a>1.2.源码获取</h2><p><code>git clone --depth=1 https://github.com/raspberrypi/linux</code></p>
<h1 id="2-内核编译"><a href="#2-内核编译" class="headerlink" title="2.内核编译"></a>2.内核编译</h1><p>预设环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd linux</span><br><span class="line">KERNEL&#x3D;kernel7</span><br><span class="line">make bcm2709_defconfig</span><br><span class="line">或者 zcat &#x2F;proc&#x2F;config.gz &gt; .config   #从现在原有版本的内核中复制配置文件</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make -j4 zImage modules dtbs</span><br><span class="line">sudo make modules_install</span><br><span class="line">sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;*.dtb &#x2F;boot&#x2F;</span><br><span class="line">sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;*.dtb* &#x2F;boot&#x2F;overlays&#x2F;</span><br><span class="line">sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;README &#x2F;boot&#x2F;overlays&#x2F;</span><br><span class="line">sudo cp arch&#x2F;arm&#x2F;boot&#x2F;zImage &#x2F;boot&#x2F;$KERNEL.img</span><br></pre></td></tr></table></figure>

<h1 id="3-更换内核"><a href="#3-更换内核" class="headerlink" title="3.更换内核"></a>3.更换内核</h1><p>修改 <code>/boot/config.txt</code> 文件中内容</p>
<p><code>kernel=kernel-myconfig.img</code></p>
<p>myconfig的版本在<code>/lib/modules/</code> 文件夹中。</p>
<h1 id="4-参考文件"><a href="#4-参考文件" class="headerlink" title="4.参考文件"></a>4.参考文件</h1><p><a href="https://www.raspberrypi.org/documentation/linux/kernel/building.md" title="building">DOCUMENTATION &gt; LINUX &gt; KERNEL &gt; BUILDING</a></p>
]]></content>
      <categories>
        <category>kernel</category>
        <category>raspberryPi</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>raspberryPi</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamicprogramming.md</title>
    <url>/2020/11/15/dynamicprogramming-md/</url>
    <content><![CDATA[<h1 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h1><p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。</p>
<h2 id="tricky"><a href="#tricky" class="headerlink" title="tricky"></a>tricky</h2><p>一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。</p>
<p>如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。</p>
<a id="more"></a>
<h2 id="硬币找零问题-coin-change"><a href="#硬币找零问题-coin-change" class="headerlink" title="硬币找零问题 coin change"></a>硬币找零问题 coin change</h2><p><a href="https://leetcode-cn.com/problems/coin-change/">leetcode-322</a></p>
<blockquote>
<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.  </p>
<blockquote>
<p>Example 1:<br>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1      </p>
</blockquote>
</blockquote>
<p>解析：每种coins的数量是不限的，因此假设dp[i]是从0到金额i，所需要的最小硬币的数量<br>初始化假设dp值均为 amount+1<br><code>dp[i] = min(dp[i-coin[x]]+1, dp[i])</code><br>循环遍历每个coin的值，获得dp最后的值，即相应的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        &#x2F;&#x2F; dp[i] &#x3D; min(dp[i-coink]+1, dp[i])</span><br><span class="line">        if (amount &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        vector&lt;int&gt; dp(amount+1, amount+1);</span><br><span class="line">        &#x2F;&#x2F; 此处初始化为amount+1，便于之后取最小值</span><br><span class="line">        dp[0] &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1;i &lt;&#x3D; amount;i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0;j &lt; coins.size();j++) &#123;</span><br><span class="line">                if (i &gt;&#x3D; coins[j]) &#123;</span><br><span class="line">                    &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot;  &quot; &lt;&lt; coins[j] &lt;&lt;&quot;  &quot; &lt;&lt; dp[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">                    dp[i] &#x3D; min(dp[i], dp[i-coins[j]]+1);</span><br><span class="line">                    &#x2F;&#x2F; cout &lt;&lt; dp[i] &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (dp[amount] &#x3D;&#x3D; amount+1) ? -1 : dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>01背包是解决什么问题？</p>
<p>答：当书包容量大小固定，面对1堆重量固定而且带有价格的物品。在不超出包容量前提下，选择那些物品使包里物品总价值最大。</p>
<p>其中代表重量的数组 w[0…i….n], 代表价值的数组 v[0…i…n]。</p>
<p><strong>一般可以通过画表格确定解空间（还没研究明白）</strong></p>
<p>动态规划的思路是设计 dp[N+1][S+1] 其中N代表物品数量，S代表背包总重量，即在N件物品，重量为S的情况下，物品的价值多大<br>当w[i-1] &lt; j(当前剩余重量)时间<br>分别代表装入或不装入<br><code>dp[i][j] = min(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1])</code></p>
<h3 id="例题-target-sum"><a href="#例题-target-sum" class="headerlink" title="例题 target sum"></a>例题 target sum</h3><p><a href="https://leetcode-cn.com/problems/target-sum/">leetcode-494</a></p>
<blockquote>
<p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.<br>Find out how many ways to assign symbols to make sum of integers equal to target S.  </p>
<blockquote>
<p>Example 1:<br>Input: nums is [1, 1, 1, 1, 1], S is 3.<br>Output: 5<br>Explanation:   </p>
<blockquote>
<p>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3<br>There are 5 ways to assign symbols to make the sum of nums be target 3.  </p>
</blockquote>
</blockquote>
</blockquote>
<p>根据题意可以假设集合nums有两个真子集A,B，其中集合A表示所有为正数的集合，集合B表示所有未负数的集合，目标值未target，那么有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum(A) + sum(B) &#x3D; sum(nums)</span><br><span class="line">sum(A) - sum(B) &#x3D; target</span><br><span class="line">2 * sum(A) &#x3D; sum(nums) + target</span><br></pre></td></tr></table></figure>
<p>由上述递推公式将该问题转化为01背包问题，题解如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123;</span><br><span class="line">        int n &#x3D; nums.size();</span><br><span class="line">        long sum &#x3D; 0;</span><br><span class="line">        for (int i : nums) sum +&#x3D; i;</span><br><span class="line">        if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; </span><br><span class="line">        S &#x3D; (sum + S) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; 传统dp</span><br><span class="line">        &#x2F;&#x2F; 对于dp(i,j)就表示可选物品为i到n且背包容量为j(总重量)时背包中所放物品的最大价值</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(S+1, 0));</span><br><span class="line">        &#x2F;&#x2F; 0个数和为0的个数为1</span><br><span class="line">        dp[0][0] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1;i &lt;&#x3D;n;i++ ) &#123;</span><br><span class="line">            for (int j &#x3D; 0;j &lt; S+1;j++) &#123;</span><br><span class="line">                if(j-nums[i-1] &lt; 0)&#x2F;&#x2F;背包容量不足，不能放入第i个物品</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i-1][j];&#x2F;&#x2F;其实就是表格的左边界</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i-1][j-nums[i-1]] + dp[i-1][j];&#x2F;&#x2F;装入第i个物品或者不装入</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][S];      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据上述代码我们发现 <code>dp[i][j] = dp[i-1][...]</code> 的关系，即i至于i-1有关系，因此我们可以减少一维向量，用一维向量记录上一轮的运算结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123;</span><br><span class="line">        int n &#x3D; nums.size();</span><br><span class="line">        long sum &#x3D; 0;</span><br><span class="line">        for (int i : nums) sum +&#x3D; i;</span><br><span class="line">        if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; </span><br><span class="line">        S &#x3D; (sum + S) &#x2F; 2;</span><br><span class="line">        &#x2F;&#x2F; dp优化</span><br><span class="line">        vector&lt;int&gt; dp(S+1, 0);</span><br><span class="line">        dp[0] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">            for (int j &#x3D; S;j &gt;&#x3D; nums[i];j--) &#123;</span><br><span class="line">                dp[j] +&#x3D; dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return dp[S];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>eBPF 简介</title>
    <url>/2020/11/15/eBPF-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h1><ul>
<li><a href="#ebpf">eBPF</a><ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="#2-%E5%8F%82%E8%80%83%E6%9D%90%E6%96%99">2. 参考材料</a></li>
<li><a href="#3-in-kernel-virtual-machine">3. in-kernel virtual machine</a></li>
<li><a href="#4-jit-just-in-time-compile">4. JIT just-in-time compile</a></li>
<li><a href="#5-kprobe-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">5. kprobe 实现原理</a></li>
</ul>
</li>
</ul>
<p><a href="https://ebpf.io/summit-2020/">ebpf summit 2020峰会</a> 这个有时间应该看一下</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>eBPF由BPF（berkeley packet filter发展而来，BPF现在也叫classic-BPF由于区别BPF），到目前为止被引入了linux内核并且使用了JIT just in time comilper进行加速，类似于浏览器的javascript脚本执行语言。</p>
<p>eBPF定义了一个内核内运行的虚拟机</p>
<p><img src="/2020/11/15/eBPF-%E7%AE%80%E4%BB%8B/ebpf-arch.png" alt="ebpf-arch"></p>
<p>使用bcc进行bpf的开发，bcc和bpftrace项目的维护放在 <strong>iovisor</strong></p>
<a id="more"></a>
<h2 id="2-参考材料"><a href="#2-参考材料" class="headerlink" title="2. 参考材料"></a>2. 参考材料</h2><ol>
<li><a href="https://lwn.net/Articles/740157/">A thorough introduction to eBPF</a></li>
<li><a href="https://lwn.net/Articles/437981/">A JIT for packet filters</a></li>
<li><a href="https://lwn.net/Articles/599755/">BPF: the universal in-kernel virtual machine</a></li>
<li><a href="https://www.youtube.com/watch?v=JRFNIKUROPE">LECTURE BPF: Tracing and More</a></li>
<li><a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">TUTORIAL Learn eBPF Tracing: Tutorial and Examples</a></li>
<li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners.md">TUTORIAL The bpftrace One-Liner Tutorial</a></li>
<li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">TUTORIAL bpftrace Reference Guide</a></li>
<li><a href="https://www.anquanke.com/post/id/220047">Linux内核攻击面之eBPF模块</a></li>
</ol>
<h2 id="3-in-kernel-virtual-machine"><a href="#3-in-kernel-virtual-machine" class="headerlink" title="3. in-kernel virtual machine"></a>3. in-kernel virtual machine</h2><p>Things started to change in the 3.0 release, when Eric Dumazet added a <strong>just-in-time compiler</strong> to the <strong>BPF interpreter</strong>. In the 3.4 kernel, the <strong>“secure computing” (seccomp)</strong> facility was enhanced to support a user-supplied filter for system calls; that filter, too, is written in the BPF language.</p>
<h2 id="4-JIT-just-in-time-compile"><a href="#4-JIT-just-in-time-compile" class="headerlink" title="4. JIT just-in-time compile"></a>4. JIT just-in-time compile</h2><p>Eric Dumazet’s patch is a fundamental change: it puts a just-in-time compiler into the kernel to <strong>translate BPF code directly into the host system’s assembly code.</strong> The simplicity of the BPF machine makes the JIT translation relatively simple; every BPF instruction maps to a straightforward <strong>x86 instruction sequence</strong>. </p>
<h2 id="5-kprobe-实现原理"><a href="#5-kprobe-实现原理" class="headerlink" title="5. kprobe 实现原理"></a>5. kprobe 实现原理</h2><p>这里仅做猜测，应该是直接使用kprobe技术，int3 打断点到指定位置，截取控制流到相应的probe callback 函数。</p>
]]></content>
      <categories>
        <category>eBPF</category>
      </categories>
      <tags>
        <tag>eBPF</tag>
      </tags>
  </entry>
  <entry>
    <title>hbase的常用shell</title>
    <url>/2016/01/20/hbase%E5%B8%B8%E7%94%A8shell/</url>
    <content><![CDATA[<h2 id="1-打开hbase并进入hbase-shell-console"><a href="#1-打开hbase并进入hbase-shell-console" class="headerlink" title="1.打开hbase并进入hbase shell console"></a>1.打开hbase并进入hbase shell console</h2><pre><code>
$HBASE_HOME/bin/start-hbase.sh
$HBASE_HOME/bin/hbase shell
hbase(main)> whoami
</code></pre>
<a id="more"></a>
<h2 id="2-表的管理"><a href="#2-表的管理" class="headerlink" title="2.表的管理"></a>2.表的管理</h2><h3 id="1）查看有哪些表"><a href="#1）查看有哪些表" class="headerlink" title="1）查看有哪些表"></a>1）查看有哪些表</h3><pre><code>
hbase(main)> list
</code></pre>

<h3 id="2）创建表"><a href="#2）创建表" class="headerlink" title="2）创建表"></a>2）创建表</h3><blockquote><ul>
<li>语法：create <table>, {NAME =&gt; <family>, VERSIONS =&gt; <VERSIONS>}</VERSIONS></family></table></li>
</ul>
</blockquote>
<pre><code>
//例如：创建表t1，有两个family name：f1，f2，且版本数均为2
hbase(main)> create 't1',&#123;NAME => 'f1', VERSIONS => 2&#125;,&#123;NAME => 'f2', VERSIONS => 2&#125;
</code></pre>

<h3 id="3）删除表"><a href="#3）删除表" class="headerlink" title="3）删除表"></a>3）删除表</h3><blockquote><ul>
<li> 分两步：首先disable，然后drop</li>
</ul>
</blockquote>
<pre><code>
//例如：删除表t1
hbase(main)> disable 't1'
hbase(main)> drop 't1'
</code></pre>

<h3 id="4）查看表的结构"><a href="#4）查看表的结构" class="headerlink" title="4）查看表的结构"></a>4）查看表的结构</h3><blockquote><ul>
<li>语法：describe <table></table></li>
</ul>
</blockquote>
<pre><code>
//例如：查看表t1的结构
hbase(main)> describe 't1'
</code></pre>

<h3 id="5）修改表结构"><a href="#5）修改表结构" class="headerlink" title="5）修改表结构"></a>5）修改表结构</h3><blockquote><ul>
<li>修改表结构必须先disable</li>
<li>语法：alter ‘t1’, {NAME =&gt; ‘f1’}, {NAME =&gt; ‘f2’, METHOD =&gt; ‘delete’}</li>
</ul>
</blockquote>

<pre><code>
hbase(main)> disable 'test1'
hbase(main)> alter 'test1',&#123;NAME=>'body',TTL=>'15552000'&#125;,&#123;NAME=>'meta', TTL=>'15552000'&#125;
hbase(main)> enable 'test1'
</code></pre>

<h2 id="3-表数据的增删改查"><a href="#3-表数据的增删改查" class="headerlink" title="3.表数据的增删改查"></a>3.表数据的增删改查</h2><h3 id="1）添加数据"><a href="#1）添加数据" class="headerlink" title="1）添加数据"></a>1）添加数据</h3><blockquote><ul>
<li>语法：put <table>,<rowkey>,<a href="family:column">family:column</a>,<value>,<timestamp></timestamp></value></rowkey></table></li>
</ul>
</blockquote>
<pre><code>
//例如：给表t1的添加一行记录：rowkey是rowkey001，family name：f1，column name：col1，value：value01，timestamp：系统默认
hbase(main)> put 't1','rowkey001','f1:col1','value01'
//用法比较单一。
</code></pre>

<h3 id="2）查询数据"><a href="#2）查询数据" class="headerlink" title="2）查询数据"></a>2）查询数据</h3><h4 id="a）查询某行记录"><a href="#a）查询某行记录" class="headerlink" title="a）查询某行记录"></a>a）查询某行记录</h4><blockquote><ul>
<li>语法：get <table>,<rowkey>,[<a href="family:column">family:column</a>,….]</rowkey></table></li>
</ul>
</blockquote>
<pre><code>
//例如：查询表t1，rowkey001中的f1下的col1的值
hbase(main)> get 't1','rowkey001', 'f1:col1'
//或者：
hbase(main)> get 't1','rowkey001', &#123;COLUMN=>'f1:col1'&#125;
//查询表t1，rowke002中的f1下的所有列值
hbase(main)> get 't1','rowkey001'
</code></pre>

<h4 id="b）扫描表"><a href="#b）扫描表" class="headerlink" title="b）扫描表"></a>b）扫描表</h4><blockquote><ul>
<li>语法：scan <table>, {COLUMNS =&gt; [ <a href="family:column">family:column</a>,…. ], LIMIT =&gt; num}</table></li>
<li>另外，还可以添加STARTROW、TIMERANGE和FITLER等高级功能</li>
</ul>
</blockquote>
<pre><code>
//例如：扫描表t1的前5条数据
</code></pre>
<p>hbase(main)&gt; scan ‘t1’,{LIMIT=&gt;5}<br></p>
<h4 id="c）查询表中的数据行数"><a href="#c）查询表中的数据行数" class="headerlink" title="c）查询表中的数据行数"></a>c）查询表中的数据行数</h4><blockquote><ul>
<li>语法：count <table>, {INTERVAL =&gt; intervalNum, CACHE =&gt; cacheNum}</table></li>
<li>INTERVAL设置多少行显示一次及对应的rowkey，默认1000；CACHE每次去取的缓存区大小，默认是10，调整该参数可提高查询速度</li>
</ul>
</blockquote>
<pre><code>
//例如，查询表t1中的行数，每100条显示一次，缓存区为500
hbase(main)> count 't1', &#123;INTERVAL => 100, CACHE => 500&#125;
</code></pre>
<h3 id="3）删除数据"><a href="#3）删除数据" class="headerlink" title="3）删除数据"></a>3）删除数据</h3><h4 id="a-删除行中的某个列值"><a href="#a-删除行中的某个列值" class="headerlink" title="a )删除行中的某个列值"></a>a )删除行中的某个列值</h4><blockquote><ul>
<li>语法：delete <table>, <rowkey>,  <a href="family:column">family:column</a> , <timestamp>,必须指定列名</timestamp></rowkey></table></li>
</ul>
</blockquote>
<pre><code>
//例如：删除表t1，rowkey001中的f1:col1的数据
hbase(main)> delete 't1','rowkey001','f1:col1'
//注：将删除改行f1:col1列所有版本的数据
</code></pre>

<h4 id="b-删除行"><a href="#b-删除行" class="headerlink" title="b )删除行"></a>b )删除行</h4><blockquote><ul>
<li>语法：deleteall <table>, <rowkey>,  <a href="family:column">family:column</a> , <timestamp>，可以不指定列名，删除整行数据</timestamp></rowkey></table></li>
</ul>
</blockquote>
<pre><code>
//例如：删除表t1，rowk001的数据
hbase(main)> deleteall 't1','rowkey001'
</code></pre>

<h4 id="c）删除表中的所有数据"><a href="#c）删除表中的所有数据" class="headerlink" title="c）删除表中的所有数据"></a>c）删除表中的所有数据</h4><blockquote><ul>
<li>语法： truncate <table></table></li>
<li>其具体过程是：disable table -&gt; drop table -&gt; create table</li>
</ul>
</blockquote>
<pre><code>
//例如：删除表t1的所有数据
hbase(main)> truncate 't1'
</code></pre>
]]></content>
      <tags>
        <tag>markdown</tag>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="Next-theme-Config"><a href="#Next-theme-Config" class="headerlink" title="Next-theme Config"></a>Next-theme Config</h3><p><a href="https://tding.top/archives/42c38b10.html">Hexo-NexT (v7.0+) 主题配置</a></p>
]]></content>
  </entry>
  <entry>
    <title>io_uring 系统性整理</title>
    <url>/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="io-uring-系统性整理"><a href="#io-uring-系统性整理" class="headerlink" title="io_uring 系统性整理"></a>io_uring 系统性整理</h1><ul>
<li><a href="#io_uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86">io_uring 系统性整理</a><ul>
<li><a href="#io-%E6%A8%A1%E5%9E%8B">I/O 模型</a><ul>
<li><a href="#comparison">comparison</a></li>
</ul>
</li>
<li><a href="#asynchronous-io">Asynchronous I/O</a></li>
<li><a href="#io_uring">io_uring</a></li>
<li><a href="#%E6%80%BB%E7%BB%93%E9%82%AE%E4%BB%B6">总结邮件</a></li>
</ul>
</li>
</ul>
<p>这里有个误解，I/O模型其实是针对整个系统的所有I/O操作的，但是平时很少对文件系统使用异步读写，同步或直接映射的情况比较多。更别提多路复用了，这个机制基本只用在network中。</p>
<p><a href="https://lwn.net/Kernel/Index/">lwn Kernel article index</a></p>
<a id="more"></a>
<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><ul>
<li>blocking I/O</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-blocking.gif" alt="blocking"></p>
<p>同步阻塞，直到内核收到数据返回给线程。</p>
<ul>
<li>nonblocking I/O</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-nonblocking.gif" alt="nonblocking"></p>
<p>同步不阻塞，但是如果内核没收到数据会返回一个 <code>EWOULDBLOCK</code></p>
<ul>
<li>I/O multiplexing (select and poll)</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-multiplex.gif" alt="multiplex"></p>
<p>异步阻塞，使用selet（using select requires two system calls instead of one）、poll系统调用循环等待socket可读时，使用recvfrom收取数据。主要优势在于能够在单线程监控多个文件描述符fd。</p>
<p>初次之外还有epoll,使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</p>
<p>优点有：<br>    没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。<br>    效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。<br>    内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>
<p>这种方法基本等价于 一个进程创建多个线程，每个线程维护一个blocking I/O</p>
<ul>
<li>signal driven I/O (SIGIO)</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-sigio.gif" alt="multiplex"></p>
<p>非阻塞，通过sigaction系统调用安装signal handler，当datagram数据报可读时，向I/O接收进程发送SIGIO信号，可以在signal handler里面读这个数据，然后通知main loop；也可以先通知main loop，让main loop去读这个数据。</p>
<ul>
<li>asynchronous I/O (the POSIX aio_functions)</li>
</ul>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-aio.gif" alt="aio"></p>
<p>异步非阻塞，也是调用aio_read之后立刻返回，和SIGIO的区别是直到接收到数据并将数据传输到用户时，才产生完成信号。</p>
<h3 id="comparison"><a href="#comparison" class="headerlink" title="comparison"></a>comparison</h3><p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/io-comparison.gif" alt="comparison"></p>
<p>参考:<br><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html">io models</a><br><a href="https://juejin.im/post/6844904200141438984">彻底理解 IO多路复用</a><br><a href="https://www.jianshu.com/p/dfd940e7fca2">聊聊IO多路复用之select、poll、epoll详解</a></p>
<h2 id="Asynchronous-I-O"><a href="#Asynchronous-I-O" class="headerlink" title="Asynchronous I/O"></a>Asynchronous I/O</h2><p>首先确定这里的AIO是内核态的，由libaio封装的系统调用运行库，而不是glibc用户态AIO，使用多线程模拟的。</p>
<p>linux kernel AIO的主要缺点在于项目泥潭，bug太多，项目设计和领导更换，而且实现比较复杂，直到现在只能比较稳定支持以O_DIRECT（直接映射修改，bypass page cache）方式打开文件，需要自己处理buffer、offset对其这些问题，不能用page cache层以bio的方式读写block数据。</p>
<p>因为使用page buffer层时涉及到block driver里面的队列，相比O_DIRECT多出很多阻塞点，因此实现起来比较令人恼火。因此这个项目根本就没实现起来。</p>
<p>因此io_uring的主要对比对象是多路复用和DPDK、SPDK，是一个事实上的新异步IO API</p>
<p>Linux AIO does suffer from a number of ailments. The subsystem is quite complex and requires explicit code in any I/O target for it to be supported.</p>
<p>实现不了的地方基本上都开一个kernel thread跑，感觉开销更大了。</p>
<p>参考：<br><a href="https://oxnz.github.io/2016/10/13/linux-aio/">Linux Asynchronous I/O</a>   </p>
<p><a href="https://lwn.net/Articles/671649/">Fixing asynchronous I/O, again</a><br><a href="https://www.aikaiyuan.com/4556.html">Linux kernel AIO这个奇葩</a><br><a href="https://lwn.net/Articles/724198/">2017Toward non-blocking asynchronous I/O</a>   </p>
<h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><p>参考：<br><a href="https://www.youtube.com/watch?v=-5T4Cjw46ys">Kernel Recipes 2019 - Faster IO through io_uring</a><br><a href="https://lwn.net/Articles/776703/">20190115Ringing in a new asynchronous I/O API</a><br><a href="https://lwn.net/Articles/826053/">20200715Operations restrictions for io_uring</a><br><a href="https://lwn.net/Articles/815491/">20200320Automatic buffer selection for io_uring</a><br><a href="https://lwn.net/Articles/810414/">20200124The rapid growth of io_uring</a><br><a href="https://lwn.net/Articles/820220/">20200511Hussain: Lord of the io_uring</a><br><a href="https://kernel.taobao.org/2019/06/io_uring-a-new-linux-asynchronous-io-API/">Linux异步IO新时代：io_uring</a><br><a href="https://lwn.net/Articles/826255/">20200716io_uring: add restrictions to support untrusted applications and guests</a><br><a href="https://lwn.net/Articles/813311/">20200225io_uring support for automatic buffers</a><br><a href="https://www.byteisland.com/io_uring%EF%BC%881%EF%BC%89-%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%9C%80%E8%A6%81-io_uring/">io_uring（1） – 我们为什么会需要 io_uring</a><br><a href="https://www.anquanke.com/post/id/200486">linux “io_uring” 提权漏洞(CVE-2019-19241)分析</a><br><a href="https://www.byteisland.com/io_uring%ef%bc%882%ef%bc%89-%e4%bb%8e%e5%88%9b%e5%bb%ba%e5%bf%85%e8%a6%81%e7%9a%84%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6-fd-%e5%bc%80%e5%a7%8b/">io_uring（2）- 从创建必要的文件描述符 fd 开始</a><br><a href></a>   </p>
<p>uring这个词没有翻译”something that looks a little less like io_urine”.</p>
<p>这是一个为了高速I/O提出的新的一系列系统调用，简单来说就是新的ring buffer。之前的异步I/O策略是libaio，这个机制饱受诟病，于是Jens Axboe直接提出io_uring，性能远超aio。</p>
<p>从5.7开始超出纯I/O的范畴，io_uring开始为一部接口提供FAST POLL机制，用户无需再像使用select、event poll等多路复用机制来监听文件句柄，只要把读写请求直接丢到io_uring的submission queue中提交 ，当文件句柄不可读写时，内核会主动添加poll handler，当文件句柄可读写时主动调用poll handler再次下发读写请求，从而减少系统调用次数提高性能</p>
<p>这是一个线程粒度的异步I/O机制，分为 submission queue和completion queue，在使用系统调用申请之后，直接返回可以使用mmap映射的file discriptor。</p>
<p>应用程序可以直接使用mmap映射的两个ring buffer直接与内核进行I/O数据传输交换，减少了大量系统调用的开销。</p>
<p>具体流程：</p>
<ul>
<li>setup <code>int io_uring_setup(int entries, struct io_uring_params *params);</code></li>
</ul>
<p>其中entries表示submission and completion queues两个队列的大小</p>
<p>param中设置两个队列和具体的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct io_uring_params &#123;</span><br><span class="line">	__u32 sq_entries;</span><br><span class="line">	__u32 cq_entries;</span><br><span class="line">	__u32 flags;</span><br><span class="line">	__u16 resv[10];</span><br><span class="line">	struct io_sqring_offsets sq_off;</span><br><span class="line">	struct io_cqring_offsets cq_off;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最终实现目的通过file descriptor与内核共享ring buffer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subqueue &#x3D; mmap(0, params.sq_off.array + params.sq_entries*sizeof(__u32),</span><br><span class="line">    PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,</span><br><span class="line">             ring_fd, IORING_OFF_SQ_RING);</span><br><span class="line"></span><br><span class="line">sqentries &#x3D; mmap(0, params.sq_entries*sizeof(struct io_uring_sqe),</span><br><span class="line">    PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,</span><br><span class="line">		    ring_fd, IORING_OFF_SQES);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cqentries &#x3D; mmap(0, params.cq_off.cqes + params.cq_entries*sizeof(struct io_uring_cqe),</span><br><span class="line">      PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,</span><br><span class="line">		    ring_fd, IORING_OFF_CQ_RING);</span><br></pre></td></tr></table></figure>

<p>相关资料：<br><a href="https://lwn.net/Articles/776703/">Ringing in a new asynchronous I/O API</a><br><a href="https://lwn.net/Articles/810414/">The rapid growth of io_uring</a>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;liburing.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct io_uring ring;</span><br><span class="line">    io_uring_queue_init(32, &amp;ring, 0);</span><br><span class="line"></span><br><span class="line">    struct io_uring_sqe *sqe &#x3D; io_uring_get_sqe(&amp;ring);</span><br><span class="line">    int fd &#x3D; open(&quot;&#x2F;home&#x2F;carter&#x2F;test.txt&quot;, O_WRONLY | O_CREAT);</span><br><span class="line">    struct iovec iov &#x3D; &#123;</span><br><span class="line">        .iov_base &#x3D; &quot;Hello world&quot;,</span><br><span class="line">        .iov_len &#x3D; strlen(&quot;Hello world&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    io_uring_prep_writev(sqe, fd, &amp;iov, 1, 0);</span><br><span class="line">    io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line">    struct io_uring_cqe *cqe;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        io_uring_peek_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">        if (!cqe) &#123;</span><br><span class="line">            puts(&quot;Waiting...&quot;);</span><br><span class="line">            &#x2F;&#x2F; accept 新连接，做其他事</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            puts(&quot;Finished.&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结邮件"><a href="#总结邮件" class="headerlink" title="总结邮件"></a>总结邮件</h2><p>今天重新思考了一下IO模型，并阅读了io_uring和多路复用相关代码，感觉突然想通了。io_uring取代了AIO而不是取代了usercopy，usercopy部署的安全策略未必适用擅长传输大量数据的io_uring，这个工作可以推后再进行。具体如下。</p>
<p>一、将I/O模型的设计和实现分离</p>
<p>I/O在操作系统中含义包括与I/O设备通信和输入输出数据，I/O模型是针对第一种含义提出的解决方案。</p>
<p>linux在实现I/O的过程中参考了这些模型进行实现，但并没有在同一层次进行实现。例如LKM开发中定义的file_operations实际只包括 read（同步）/read_iter（异步）/mmap/poll 等函数指针，在I/O模型中的阻塞同步和非阻塞同步的情况可以通过使用read/read_iter 附加O_NONBLOCK的方式实现。</p>
<p>select epoll 多路复用和AIO这些I/O模型，则是分别在与之相同或不同的层次对底层函数进行封装。</p>
<p>例如 select 系统调用是在内核层通过vfs_poll遍历相关的file_descriptor，glibc实现的AIO是在用户空间多线程调用这些阻塞/非阻塞的同步/异步系统调用，epoll（更像是一个通知机制）是将select/poll中需要每次都传递的file descriptor都保存在内核中，减少了usercopy；通过event监听callback进行通知，减少了对fd的遍历开销。</p>
<p>二、思考io_uring的设计和实现</p>
<p>io_uring的设计借鉴了以上的优点，在内核空间通过kthread实现对阻塞读写任务的托管，并加入了zero copy特性，开发者可以通过一次系统调用唤醒线程一直向共享ringbuffer中写数据，而不是每次写数据都需要系统调用，这在内核和用户通信范畴内很大程度上减少了系统调用的次数，消除了usercopy的负担。</p>
<p>但无法否认io_uring是对下层file_operations的封装，下层函数又是device driver file_operations的封装（甚至对buffer I/O中间还有一层page cache、一层block layer、一层I/O schedule），因此io_uring在许多情况无法获得SPDK用户空间直通driver的性能优势。</p>
<p>三、对安全问题的思考</p>
<p>我目前理解的安全风险主要来自于usercopy造成的out-of-bound、information/pointer leakage和race情况，尤其是struct结构可能存在的函数/数据指针，但是io_uring消除掉的usercopy主要负责大量I/O数据的传输，而非带有指针的控制数据结构（io_uring中的控制数据也在用copy_*_user传输，如图），因此对安全问题的认识比我预期要复杂一些（主要问题可能是OOB和Iago攻击），需要加深对漏洞形式的理解，但好处是急迫程度下降了。</p>
<p>我只能继续积累漏洞阅读量提升认知水平，思考copy_*_user可以部署的安全机制和策略。</p>
<p><img src="/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/usercopy.PNG" alt="usercopy"></p>
<p>四、总结</p>
<p>我这阶段应该继续把重点放在kernel extension问题的描述上，对这个问题我已经基本有了一定想法，大致是将威胁模型定位为kernel rootkits，通过修改页表或切换地址空间构建运行时沙箱，使用可信基截获、保护gateway，使用hook方式监控driver相关函数和数据I/O。可以将性能的提升和对DPDK/SPDK使用的UIO和VFIO保护作为贡献点（这可能是这次突发奇想的意外收获），现在面临的问题是不确定相关方案是否有实现、近期driver保护方案相关只有四篇。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>io_uring</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel contribution 统计</title>
    <url>/2020/11/16/kernel-contribution-%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>保存lwn.net发布的新版本开发统计文章，目前来看还是华为最屌。</p>
<p><a href="https://lwn.net/Articles/780271/">Development statistics for the 5.0 kernel</a><br>As of this writing, 12,517 non-merge changesets have been pulled into the mainline repository for the 5.0 release</p>
<p><a href="https://lwn.net/Articles/810639/">Some 5.5 kernel development statistics</a><br>5.5 saw the merging of 14,350 non-merge changesets from 1,885 developers</p>
<a id="more"></a>

<p><a href="https://lwn.net/Articles/816162/">Some 5.6 kernel development statistics</a><br>12,665 non-merge changesets had been accepted from 1,712 developers</p>
<p><a href="https://lwn.net/Articles/821813/">Development statistics for the 5.7 kernel</a><br>Work on 5.7 arrived in the form of 13,901 non-merge changesets contributed by 1,878 developers;</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
        <tag>lwn.net</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel-exploit-vm搭建</title>
    <url>/2020/11/28/kernel-exploit-vm%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<ul>
<li>环境：Manjaro(archlinux)18   Linux wangzc-pc 4.14.193-1-MANJARO  x86_64 GNU/Linux</li>
</ul>
<a id="more"></a>

<h2 id="1-内核编译"><a href="#1-内核编译" class="headerlink" title="1. 内核编译"></a>1. 内核编译</h2><h3 id="1-1-linux-3-7-1"><a href="#1-1-linux-3-7-1" class="headerlink" title="1.1 linux-3.7.1"></a>1.1 linux-3.7.1</h3><ul>
<li><p>使用gcc-4.9编译</p>
<p>  由于 kernel 3.x 开发时间较早，因此不适用PIC PIE等加载机制，尤其在gcc-10环境下已经变成默认设置。</p>
<p>  因此我们最好使用 <strong>gcc-4.9</strong> 进行编译，可以使用 aur 库中的自动安装（编译时间较长），安装之后修改 kernel3.x 的 Makefile。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装gcc-4.9</span><br><span class="line">yay -S gcc49</span><br><span class="line"></span><br><span class="line"># 修改 Makefile</span><br><span class="line">CC           &#x3D; $(CROSS_COMPILE)gcc  -&gt;   gcc-4.9</span><br><span class="line"></span><br><span class="line">HOSTCC       &#x3D; gcc                  -&gt;   gcc-4.9</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译选项</p>
<p>  Kernel hacking —&gt; Compile the kernel with debug info </p>
<p>  Kernel hacking —&gt; Compile the kernel with frame pointer</p>
<p>  Kernel hacking —&gt; KGDB: kernel debugger</p>
</li>
<li><p>perl 脚本修改</p>
<p>  <code>kernel/timeconst.pl</code> 脚本中出现 <code>if (!define(@val))</code> 无法执行的问题，解决办法是修改为 <code>if (!@val)</code> 即可</p>
</li>
<li><p>设置默认配置</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make x86_64_defconfig</span><br></pre></td></tr></table></figure>
<p>  <code>make -j4</code> 进行编译，在 <code>arch/x86_64/boot</code> 目录下，生成bzImage</p>
</li>
</ul>
<h3 id="1-2-linux-4-4-232"><a href="#1-2-linux-4-4-232" class="headerlink" title="1.2 linux-4.4.232"></a>1.2 linux-4.4.232</h3><ul>
<li><p>设置默认配置</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make x86_64_defconfig</span><br><span class="line">make kvmconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改编译选项</p>
<p>  Kernel hacking → Compile-time checks and compiler options  </p>
<pre><code>  -&gt; Compile the kernel with debug info 
  -&gt; Compile the kernel with frame pointers</code></pre>
<p>  Kernel hacking → KGDB: kernel debugger</p>
</li>
</ul>
<h3 id="1-3-linux-5-8-2"><a href="#1-3-linux-5-8-2" class="headerlink" title="1.3 linux-5.8.2"></a>1.3 linux-5.8.2</h3><ul>
<li><p>设置默认配置</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make x86_64_defconfig</span><br><span class="line">make kvm_guest.config</span><br><span class="line"># &#39;make kvmconfig&#39; will be removed after Linux 5.10</span><br></pre></td></tr></table></figure></li>
<li><p>修改编译选项</p>
<p>  Kernel hacking &gt; Compile-time checks and compiler options</p>
<p>  Kernel hacking &gt; Kernel debugging</p>
</li>
</ul>
<h2 id="2-编译busybox-1-32-0"><a href="#2-编译busybox-1-32-0" class="headerlink" title="2. 编译busybox-1.32.0"></a>2. 编译busybox-1.32.0</h2><ul>
<li><p>编译选项 </p>
<p>  选中 setting &gt; Build static binary (no shared libs)  </p>
<p>  取消 inetd</p>
<p>  <code>make install -j2</code></p>
</li>
<li><p>打包</p>
<p>  编译成功后进入 <code>_install</code> 目录，创建</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir proc sys dev etc etc&#x2F;init.d</span><br><span class="line">vim etc&#x2F;init.d&#x2F;rcS</span><br><span class="line"></span><br><span class="line"># 写入</span><br><span class="line">mkdir &#x2F;home</span><br><span class="line">mkdir &#x2F;home&#x2F;ppw</span><br><span class="line">touch &#x2F;etc&#x2F;passwd</span><br><span class="line">touch &#x2F;etc&#x2F;group</span><br><span class="line">adduser ppw</span><br><span class="line">cat &#x2F;proc&#x2F;kallsyms | grep start_kernelmkdir &#x2F;home</span><br><span class="line">mkdir &#x2F;home&#x2F;ppw</span><br><span class="line">touch &#x2F;etc&#x2F;passwd</span><br><span class="line">touch &#x2F;etc&#x2F;group</span><br><span class="line">adduser ppw</span><br><span class="line">cat &#x2F;proc&#x2F;kallsyms | grep start_kernel</span><br><span class="line"></span><br><span class="line">find . | cpio -o --format&#x3D;newc &gt; rootfs.cpio</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-qemu-启动，调试"><a href="#3-qemu-启动，调试" class="headerlink" title="3. qemu 启动，调试"></a>3. qemu 启动，调试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"># linux-5.8.2&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImage</span><br><span class="line"># linux-4.4.232&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImage</span><br><span class="line"># linux-3.7.1&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImage</span><br><span class="line">qemu-system-x86_64 -kernel linux-3.7.1&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImage \</span><br><span class="line">-initrd busybox-1.32.0&#x2F;_install&#x2F;rootfs.img                \</span><br><span class="line">-append &quot;nokalsr  console&#x3D;ttyS0  root&#x3D;&#x2F;dev&#x2F;ram rdinit&#x3D;&#x2F;sbin&#x2F;init&quot;   \</span><br><span class="line">-cpu kvm64,+smep                                          \</span><br><span class="line">--nographic -gdb tcp::1234                                \</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>共享目录还没有进行测试。2.6内核测试不成功，不知道为啥。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -kernel bzImage </span><br><span class="line">-s </span><br><span class="line">-append nokaslr </span><br><span class="line">-initrd initramfs.img </span><br><span class="line">-fsdev local,security_model&#x3D;passthrough,id&#x3D;fsdev-fs0,path&#x3D;&#x2F;home&#x2F;error404&#x2F;Desktop&#x2F;CTF_question&#x2F;Kernel&#x2F;Buffer_overflow_basic_1&#x2F;Share </span><br><span class="line">-device virtio-9p-pci,id&#x3D;fs0,fsdev&#x3D;fsdev-fs0,mount_tag&#x3D;rootme</span><br></pre></td></tr></table></figure>

<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir rootfs</span><br><span class="line"># 解压缩</span><br><span class="line">cpio -idvm &lt; ..&#x2F;rootfs.cpio</span><br><span class="line"># 压缩</span><br><span class="line">find . | cpio -o --format&#x3D;newc &gt; rootfs.cpio</span><br></pre></td></tr></table></figure>


<p>另一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t proc proc &#x2F;proc</span><br><span class="line">mount -t sysfs sysfs &#x2F;sys</span><br><span class="line">mount -t devtmpfs none &#x2F;dev</span><br><span class="line">&#x2F;sbin&#x2F;mdev -s</span><br><span class="line">mkdir -p &#x2F;dev&#x2F;pts</span><br><span class="line">mount -vt devpts -o gid&#x3D;4,mode&#x3D;620 none &#x2F;dev&#x2F;pts</span><br><span class="line">chmod 666 &#x2F;dev&#x2F;ptmx</span><br><span class="line">cat &#x2F;proc&#x2F;kallsyms &gt; &#x2F;tmp&#x2F;kallsyms</span><br><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;kptr_restrict</span><br><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod &#x2F;core.ko</span><br><span class="line"> </span><br><span class="line">poweroff -d 1200000 -f &amp;</span><br><span class="line">setsid &#x2F;bin&#x2F;cttyhack setuidgid 0 &#x2F;bin&#x2F;sh</span><br><span class="line">echo &#39;sh end!\n&#39;</span><br><span class="line">umount &#x2F;proc</span><br><span class="line">umount &#x2F;sys</span><br><span class="line"> </span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>


<ul>
<li>变量kptr_restrict是可以用来限制内核地址的打印，当kptr_restrict=0时，会直接打印内核地址（%p和%pK效果一样）；</li>
<li>当kptr_restrict=1时，若在中断上下文或软中断时，%pK打印“pK-error”，否则内核地址打印全0；</li>
<li>当kptr_restrict=2时，%pK打印内核地址为全0；</li>
</ul>
<p>dmesg能够输出kernel ring buffer中的内容，这些内容中可能会包含一些敏感信息，我们可以通过设置内核参数 dmesg_restrict 为 1 的方式来禁止普通用户查看demsg信息。</p>
<ul>
<li><p>mmap_min_addr</p>
<p>  指定用户进程通过mmap可使用的最小虚拟内存地址，以避免其在低地址空间产生映射导致安全问题。</p>
</li>
<li><p>kptr_restrict / dmesg_restrict</p>
<p>  在linux内核漏洞利用中常常使用commit_creds和prepare_kernel_cred来完成提权，它们的地址可以从/proc/kallsyms中读取。/proc/sys/kernel/kptr_restrict被默认设置为1以阻止通过这种方式泄露内核地址。dmesg_restrict限制非特权读dmesg（Restrict unprivileged access to kernel syslog）</p>
</li>
<li><p>SMEP/SMAP<br>  SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)和SMAP(Supervisor Mode Access Prevention，管理模式访问保护)，其作用分别是禁止内核执行用户空间的代码和禁止内核访问用户空间的数据。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>vm</tag>
        <tag>exploit</tag>
      </tags>
  </entry>
  <entry>
    <title>nutch-2.3.1+hbase-0.94+eclipse 环境搭建教程</title>
    <url>/2016/03/08/nutch-2.3.1+hbase-0.94+eclipse%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="1-开发环境及软件版本"><a href="#1-开发环境及软件版本" class="headerlink" title="1.开发环境及软件版本"></a>1.开发环境及软件版本</h2><ul>
<li>centos 6.7</li>
<li>apache-nutch-2.3.1</li>
<li>hbase-0.94</li>
<li>eclipse javaEE</li>
<li>jdk8</li>
</ul>
<h2 id="2-安装并配置jdk"><a href="#2-安装并配置jdk" class="headerlink" title="2.安装并配置jdk"></a>2.安装并配置jdk</h2><a id="more"></a>
<h3 id="1-在Oracle网站wget下载jdk8"><a href="#1-在Oracle网站wget下载jdk8" class="headerlink" title="1) 在Oracle网站wget下载jdk8"></a>1) 在Oracle网站wget下载jdk8</h3><figure class="highlight plain"><figcaption><span>jdk8_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense&#x3D;accept-securebackup-cookie&quot; http:&#x2F;&#x2F;download.oracle.com&#x2F;otn-pub&#x2F;java&#x2F;jdk&#x2F;8u73-b02&#x2F;jdk-8u73-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>由于Oracle需要点击accept licence的才能下载，所以必须使用下面的命令，才可以直接下载。<br>否则下载的jdk文件将无法解压缩。</p>
<h3 id="2-配置JAVA-HOME"><a href="#2-配置JAVA-HOME" class="headerlink" title="2) 配置JAVA_HOME"></a>2) 配置JAVA_HOME</h3><figure class="highlight plain"><figcaption><span>jdk8_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir&#x2F;usr&#x2F;java&#x2F;</span><br><span class="line">tar -zxf jdk-8u73-linux-x64.tar.gz &#x2F;&#x2F;不适用-v指令以加快解压缩速度</span><br><span class="line">mv jdk-8u73-linux-x64&#x2F; &#x2F;usr&#x2F;java&#x2F;</span><br><span class="line">vi &#x2F;etc&#x2F;profile  &#x2F;&#x2F;打开vi文本编辑器编辑环境变量</span><br></pre></td></tr></table></figure>

<p>按i开始编辑，在文件的末尾输入</p>
<figure class="highlight plain"><figcaption><span>jdk8_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">  #set JDK environment</span><br><span class="line">  </span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_45</span><br><span class="line">JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</span><br><span class="line">CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">export JAVA_HOME JRE_HOMECLASS_PATH PATH</span><br></pre></td></tr></table></figure>
<p>先按Esc退出编辑模式，然后输入 :wq 保存退出</p>
<figure class="highlight plain"><figcaption><span>jdk8_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile  &#x2F;&#x2F;使环境生效</span><br><span class="line">echo $JAVA_HOME &#x2F;&#x2F;检验是否安装成功</span><br><span class="line">&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_45  &#x2F;&#x2F;环境生效！！！</span><br></pre></td></tr></table></figure>

<h2 id="3-安装并配置hbase-0-94"><a href="#3-安装并配置hbase-0-94" class="headerlink" title="3.安装并配置hbase-0.94"></a>3.安装并配置hbase-0.94</h2><h3 id="1-在hbase页面下载hbase-0-94解压缩并重命名"><a href="#1-在hbase页面下载hbase-0-94解压缩并重命名" class="headerlink" title="1) 在hbase页面下载hbase-0.94解压缩并重命名"></a>1) 在hbase页面下载hbase-0.94解压缩并重命名</h3><figure class="highlight plain"><figcaption><span>hbase_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;www-eu.apache.org&#x2F;dist&#x2F;hbase&#x2F;hbase-0.94.27&#x2F;</span><br><span class="line">tar -zxf hbase-0.94.27&#x2F;   &#x2F;&#x2F;减少输出，加快速度</span><br><span class="line">mv hbase-0.94.27&#x2F; hbase&#x2F;  &#x2F;&#x2F;重命名，简短文件名称</span><br><span class="line">mv hbase&#x2F; &#x2F;usr&#x2F;           &#x2F;&#x2F;将hbase&#x2F;文件夹移动到&#x2F;usr&#x2F;路径下</span><br><span class="line">cd &#x2F;usr&#x2F;                  &#x2F;&#x2F;进入&#x2F;usr目录</span><br><span class="line">chmod -R 777 hbase&#x2F;       &#x2F;&#x2F;给hbase目录分配权限</span><br><span class="line"></span><br><span class="line">cd hbase&#x2F;</span><br><span class="line">vi conf&#x2F;hbase-site.xml    &#x2F;&#x2F;配置hbase-site.xml文件</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;file:&#x2F;&#x2F;&#x2F;&#x2F;usr&#x2F;hbase&#x2F;hbase&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;&#x2F;usr&#x2F;hbase&#x2F;zookeeper&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>之后的nutch爬出的数据将存储到rootdir文件夹中，所以必须配置zookeeper的同理。<br>测试是否安装成功</p>
<figure class="highlight plain"><figcaption><span>hbase_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;start-hbase.sh &#x2F;&#x2F;打开hbase进程</span><br><span class="line">.&#x2F;bin&#x2F;hbase shell &#x2F;&#x2F;可以进入hbase命令行模式</span><br><span class="line">&#x2F;&#x2F;检验成功可以运行后暂时关闭hbase进程</span><br><span class="line">.&#x2F;stop-hbase.sh</span><br></pre></td></tr></table></figure>
<p>至此hbase安装成功，hbase-0.94可以直接在本地运行，不需要hadoop集群（个人暂时是这么理解的欢迎指正）</p>
<h2 id="4-安装并配置apache-nutch-2-3-1"><a href="#4-安装并配置apache-nutch-2-3-1" class="headerlink" title="4.安装并配置apache-nutch-2.3.1"></a>4.安装并配置apache-nutch-2.3.1</h2><h3 id="1-wget下载apache-nutch-2-3-1并解压缩"><a href="#1-wget下载apache-nutch-2-3-1并解压缩" class="headerlink" title="1)wget下载apache-nutch-2.3.1并解压缩"></a>1)wget下载apache-nutch-2.3.1并解压缩</h3><figure class="highlight plain"><figcaption><span>nutch-2_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;www-eu.apache.org&#x2F;dist&#x2F;nutch&#x2F;2.3.1&#x2F;apache-nutch-2.3.1-src.tar.gz</span><br><span class="line">&#x2F;&#x2F;速度不够的话去官网看他给你推荐的链接</span><br><span class="line">tar -zxf apache-nutch-2.3.1-src.tar.gz</span><br><span class="line">mv apache-nutch-2.3.1&#x2F; nutch-2&#x2F;</span><br><span class="line">mv nutch-2&#x2F; &#x2F;usr&#x2F; &#x2F;&#x2F;移动文件</span><br><span class="line">cd &#x2F;usr&#x2F;</span><br><span class="line">chmod -R 777 nutch-2</span><br></pre></td></tr></table></figure>

<ul>
<li>下面开始重头戏，配置nutch文件<h4 id="1-conf目录下的nutch-site-xml文件-我的配置"><a href="#1-conf目录下的nutch-site-xml文件-我的配置" class="headerlink" title="(1)conf目录下的nutch-site.xml文件(我的配置)"></a>(1)conf目录下的nutch-site.xml文件(我的配置)</h4><figure class="highlight plain"><figcaption><span>nutch-2_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;storage.data.store.class&lt;&#x2F;name&gt;</span><br><span class="line">&lt;value&gt;org.apache.gora.hbase.store.HBaseStore&lt;&#x2F;value&gt;</span><br><span class="line">&lt;description&gt;Default class for storing data&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;plugin.includes&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;protocol-httpclient|urlfilter-regex|index-(basic|more)|query-(basic|site|url|lang)|indexer-solr|nutch-extensionpoints|protocol-httpclient|urlfilter-regex|parse-(text|html|msexcel|msword|mspowerpoint|pdf)|summary-basic|scoring-opic|urlnormalizer-(pass|regex|basic)protocol-http|urlfilter-regex|parse-(html|tika|metatags)|index-(basic|anchor|more|metadata)&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &lt;property&gt;</span><br><span class="line">    &lt;name&gt;http.agent.name&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;33.0.1750.117 Safari&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;http.agent.version&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;537.36&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">   &lt;name&gt;http.robots.agents&lt;&#x2F;name&gt;</span><br><span class="line">   &lt;value&gt;Test-Crawler&lt;&#x2F;value&gt;</span><br><span class="line"> &lt;&#x2F;property&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;property&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;property&gt;</span><br><span class="line">  &lt;name&gt;plugin.folders&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;value&gt;.&#x2F;build&#x2F;plugins&lt;&#x2F;value&gt;</span><br><span class="line">  &lt;description&gt;Directories where nutch plugins are located.  Each</span><br><span class="line">  element may be a relative or absolute path.  If absolute, it is used</span><br><span class="line">  as is.  If relative, it is searched for on the classpath.&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"> &lt;&#x2F;property&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;property&gt;</span><br><span class="line">  &lt;name&gt;plugin.includes&lt;&#x2F;name&gt;</span><br><span class="line"> &lt;value&gt;protocol-http|urlfilter-regex|parse-(html|tika)|index-(basic|anchor)|urlnormalizer-(pass|regex|basic)|scoring-opic|index-anchor|index-more|languageidentifier|subcollection|feed|creativecommons|tld&lt;&#x2F;value&gt;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li>留心plugin.folders，配置不对花式报错</li>
</ul>
<h4 id="2-修改conf-gora-properties"><a href="#2-修改conf-gora-properties" class="headerlink" title="(2)修改conf/gora.properties"></a>(2)修改conf/gora.properties</h4><p>加入<pre><code>gora.datastore.default=org.apache.gora.hbase.store.HBaseStore</code></pre><br>之后注释掉所有其他内容</p>
<h4 id="3-修改ivy-ivy-xml文件"><a href="#3-修改ivy-ivy-xml文件" class="headerlink" title="(3)修改ivy/ivy.xml文件"></a>(3)修改ivy/ivy.xml文件</h4><p>取消注释</p>
<pre><code><dependency org="org.apache.gora" name="gora-hbase" rev="0.5" conf="*->default"></dependency></code></pre>
<p>表示使用hbase数据库</p>
<ul>
<li><p>另外regex-urlfliter.txt网页内容过滤等可以暂时不进行配置</p>
</li>
<li><p>返回nutch-2根目录</p>
<figure class="highlight plain"><figcaption><span>nutch-2_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">yum -y install ant &#x2F;&#x2F;yum直接安装ant，对nutch进行搭建</span><br><span class="line">ant eclipse</span><br><span class="line">ant runtime &#x2F;&#x2F;命令行操作方式构建，进入runtime&#x2F;local&#x2F;bin&#x2F;文件夹中有nutch和crawl感兴趣的关注文章结尾处推荐链接</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote><p>maven资源被墙了，建议翻墙使用<br>maven资源被墙了，建议翻墙使用<br>maven资源被墙了，建议翻墙使用</p>
<footer><strong>重要的事情说三遍</strong></footer></blockquote>
<p>安装完成之后就可以导入eclipse中了</p>
<blockquote><ul>
<li>革命尚未成功，同志仍需努力。</li>
<li>行百里者半九十</li>
<li>最后一步不认真的话可能会超级麻烦的！！（认真脸）</li>
</ul>
</blockquote>
<ul>
<li>别忘了最后一步</li>
<li>在nutch根目录中新建文件夹urls/，在文件夹中新建seed.txt文件 <a href="http://www.zi-c.wang/">http://www.zi-c.wang</a> 保存退出</li>
</ul>
<h2 id="5-导入eclipse中（想导入idea也可以这样玩，貌似）"><a href="#5-导入eclipse中（想导入idea也可以这样玩，貌似）" class="headerlink" title="5.导入eclipse中（想导入idea也可以这样玩，貌似）"></a>5.导入eclipse中（想导入idea也可以这样玩，貌似）</h2><h3 id="1-创建工程java-project"><a href="#1-创建工程java-project" class="headerlink" title="1)创建工程java project"></a>1)创建工程java project</h3><p>进入eclipse-&gt;file-&gt;new-&gt;project-&gt;java project<br>直接修改项目路径（/usr/nutch-2）<br>点击next，在build path配置中order&amp;export选项卡，选中nutch-2/conf文件夹，单击top</p>
<h3 id="2-配置run-configuration"><a href="#2-配置run-configuration" class="headerlink" title="2)配置run configuration"></a>2)配置run configuration</h3><p>点击run configurations，进入页面。<br>右键java application，新建application命名为injectJob<br>project：nutch-2<br>main class：org.apache.nutch.crawl.InjectorJob<br>进入run configurations的arguments标签中，在Program Arguments中添加<br>urls/seed.txt -crawlId search<br>点击apply</p>
<p>同理<br>application：generateJob<br>main class：org.apache.nutch.crawl.GeneratorJob<br>arguments:-topN 10 -crawlId search</p>
<p>application：fetcheJob<br>main class：org.apache.nutch.fetcher.FetcherJob<br>arguments:-all -crawlId search -thread 10</p>
<p>application：parseJob<br>main class：org.apache.nutch.parse.ParserJob<br>arguments:-all -crawlId search</p>
<p>application：updatedbJob<br>main class：org.apache.nutch.crawl.DbUpdaterJob<br>arguments:-all -crawlId search</p>
<h3 id="3-跑起来吧！！奔放的eclipse"><a href="#3-跑起来吧！！奔放的eclipse" class="headerlink" title="3)跑起来吧！！奔放的eclipse"></a>3)跑起来吧！！奔放的eclipse</h3><h3 id="4-查看爬取得数据"><a href="#4-查看爬取得数据" class="headerlink" title="4)查看爬取得数据"></a>4)查看爬取得数据</h3><figure class="highlight plain"><figcaption><span>nutch-2_installing</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;hbase&#x2F;</span><br><span class="line">.&#x2F;bin&#x2F;hbase shell</span><br><span class="line">list &#x2F;&#x2F;hbase指令请参考我的上一篇文章 hbase常用指令</span><br><span class="line">scan &#39;search_webpage&#39; &#x2F;&#x2F;灰常灰常壮观的数据闪过去了&#x3D;_+</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>成功！！！</p>
<h2 id="6-感想"><a href="#6-感想" class="headerlink" title="6.感想"></a>6.感想</h2><p>  搭建这套环境对我来说是很大的一个修行！！<br>  前前后后使用的时间可能超过50h了，真是笨死了。<br>  耗时这么长的原因：主要是我太粗心了，很多应该完成的配置并没有实现成功，浪费了很多时间<br>  另一方面：不会看log<br>  现在看起来非常可笑的事情就是我的环境一旦搭建失败了首先看的是文档而不是日志，真是笨死了<br>  同时我也终于意识到Android application中为什么强调写好log。</p>
<p>  搭建这套环境确实提升了个人能力一大截，超级期待下一步的搜索引擎实践！！<br>  加油奔放的少年！！！</p>
<h2 id="7-推荐链接"><a href="#7-推荐链接" class="headerlink" title="7.推荐链接"></a>7.推荐链接</h2><p>1.<a href="https://wiki.apache.org/nutch/#Nutch_2.X_tutorial.28s.29">Apache Nutch Wiki</a><br>2.<a href="http://blog.csdn.net/jediael_lu/article/details/37329731">【Nutch2.2.1基础教程之2.1】集成Nutch/Hbase/Solr构建搜索引擎之一：安装及运行【单机环境】</a><br>3.<a href="http://blog.csdn.net/jediael_lu/article/details/43232449">在Eclipse中运行Nutch2.3</a><br>4.<a href="http://www.aboutyun.com/forum.php">about云社区</a><br>5.<a href="https://hbase.apache.org/book.html">hbase wiki</a><br>6. 杨尚川老师的nutch系列视频（虽然有点旧，但是给你仔细分析每个过程）<br>7.<a href="http://www.oschina.net/code/snippet_875267_44726">Linux 使用wget 命令下载JDK的方法</a><br>8.<a href="http://stackoverflow.com/">神圣网站stackoverflow，救过我无数次</a></p>
]]></content>
      <tags>
        <tag>hbase</tag>
        <tag>nutch</tag>
      </tags>
  </entry>
  <entry>
    <title>三剑客sed/awk/grep常用速查</title>
    <url>/2020/11/16/%E4%B8%89%E5%89%91%E5%AE%A2sed-awk-grep%E5%B8%B8%E7%94%A8%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<p>sed和awk的区别，都是按行读入，但是awk会拆分行里面的元素，sed则直接用正则做匹配，基本上sed可以做到的awk都可以。</p>
<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p><code>awk &#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39; netstat.txt</code> awk 使用print和printf打印每行中按列分布的元素。</p>
<p><code>awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot;&#39; netstat.txt</code> 过滤记录</p>
<p><code>awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot; || NR==1 &#123;printf &quot;%02s %s %-20s %-20s %s\n&quot;,NR, FNR, $4,$5,$6&#125;&#39; netstat.txt</code> 其中NR，FNR为内建变量</p>
<a id="more"></a>
<ul>
<li>$0    当前记录（这个变量中存放着整个行的内容）</li>
<li>$1~$n    当前记录的第n个字段，字段间由FS分隔</li>
<li>FS    输入字段分隔符 默认是空格或Tab</li>
<li>NF    当前记录中的字段个数，就是有多少列</li>
<li>NR    已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。</li>
<li>FNR    当前记录数，与NR不同的是，这个值会是各个文件自己的行号</li>
<li>RS    输入的记录分隔符， 默认为换行符</li>
<li>OFS    输出字段分隔符， 默认也是空格</li>
<li>ORS    输出的记录分隔符，默认为换行符</li>
<li>FILENAME    当前输入文件的名字</li>
</ul>
<p><code>awk  &#39;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1,$3,$6&#125;&#39; /etc/passwd</code> 指定分隔符</p>
<p><code>awk &#39;$6 ~ /E/ || NR==1 &#123;print NR, $4,$5,$6&#125;&#39; netstat.txt</code> ~表示开始，//表示匹配，这行命令表示匹配第六个元素开始包含E的行和第一行，然后输出行数和第456个元素。</p>
<p><code>awk &#39;NR!=1&#123;print $4,$5 &gt; $6&#125;&#39; netstat.txt</code> 不处理第一行，按照第六列元素分类拆分成若干个文件，文件的内容是第45列元素。</p>
<h2 id="awk-脚本"><a href="#awk-脚本" class="headerlink" title="awk 脚本"></a>awk 脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;awk -f</span><br><span class="line"># 运行前</span><br><span class="line">BEGIN &#123;</span><br><span class="line">	math &#x3D; 0</span><br><span class="line">	english &#x3D; 0</span><br><span class="line">	computer &#x3D; 0</span><br><span class="line"></span><br><span class="line">	printf &quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;</span><br><span class="line">	printf &quot;---------------------------------------------\n&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 运行中</span><br><span class="line">&#123;</span><br><span class="line">	math +&#x3D; $3</span><br><span class="line">	english +&#x3D; $4</span><br><span class="line">	computer +&#x3D; $5</span><br><span class="line">	printf &quot;%-6s %-6s %4d %8d %8d %8d\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5</span><br><span class="line">&#125;</span><br><span class="line"># 运行之后</span><br><span class="line">END &#123;</span><br><span class="line">	printf &quot;---------------------------------------------\n&quot;</span><br><span class="line">	printf &quot;  TOTAL:%10d %8d %8d \n&quot;, math, english, computer</span><br><span class="line">	printf &quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;, math&#x2F;NR, english&#x2F;NR, computer&#x2F;NR</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>awk -v val=$x &#39;&#123;print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]&#125;&#39; OFS=&quot;\t&quot; score.txt</code> 其中x，y为环境变量，为了使用环境变量需要 -v</p>
<p><code>echo $PATH| awk &#39;BEGIN&#123;RS=&quot;:&quot;&#125;&#123;print NR,$0&#125;&#39;</code> 把单行拆分成多行</p>
<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p><code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code></p>
<ul>
<li><p>e&lt;script&gt;或–expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。</p>
</li>
<li><p>f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</p>
</li>
<li><p>h或–help 显示帮助。</p>
</li>
<li><p>n或–quiet或–silent 仅显示script处理后的结果。</p>
</li>
<li><p>V或–version 显示版本信息。</p>
</li>
<li><p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</p>
</li>
<li><p>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</p>
</li>
<li><p>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</p>
</li>
<li><p>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</p>
</li>
<li><p>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</p>
</li>
<li><p>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</p>
</li>
</ul>
<p><code>sed &quot;s/my/ppw &#39;s/g&quot; pets.txt</code> 把pets.txt文件的my改成ppw’s，并不修改文件。/g 表示一行上的替换所有的匹配</p>
<p>加入-i <code>sed -i &quot;s/my/ppw &#39;s/g&quot; pets.txt</code>可以直接修改文件</p>
<p><code>sed &#39;s/^/---/g&#39; pets.txt</code> 在开头加上—</p>
<p><code>sed &#39;s/$/---/g&#39; pets.txt</code> 在结尾加上—</p>
<p>同理类似的有：</p>
<ul>
<li>\&lt; 表示词首。 如：&lt;abc 表示以 abc 为首的詞。</li>
<li>\&gt; 表示词尾。 如：abc&gt; 表示以 abc 結尾的詞。</li>
<li>. 表示任何单个字符。</li>
<li>* 表示某个字符出现了0次或多次。</li>
<li><input disabled type="checkbox"> 字符集合。 如：[abc] 表示匹配a或b或c，还有 [a-zA-Z] 表示匹配所有的26个字符。如果其中有^表示反，如 [^a] 表示非a的字符</li>
</ul>
<p><code>sed &#39;s/&lt;[^&gt;]*&gt;//g&#39; html.txt</code> 取消html文件中的&lt;&gt;tags,不能使用<code>&#39;s/&lt;.*&gt;&#39;//g</code>，因为会贪婪匹配掉第一个《和最后一个》之间所有的内容，现在给出的示例是匹配除了&gt;意外的字符。</p>
<p><code>sed &#39;3s/my/your/g&#39; pets.txt</code> 和 <code>sed &#39;3,6s/my/your/g&#39; pets.txt</code>，分别表示匹配第三行和第三到六行。</p>
<p><code>sed &#39;s/s/S/1&#39; pets.txt</code> 匹配每一行的第一个s</p>
<p><code>sed &#39;1,3s/my/your/g; 3,$s/This/That/g&#39; pets.txt</code> 匹配多个</p>
<p><code>sed &#39;s/my/[&amp;]/g&#39; pets.txt</code> 使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西</p>
<p><code>sed &#39;s/This is my \([^,]*\),.*is \(.*\)/\1:\2/g&#39; my.txt</code> 圆括号括起来的正则表达式所匹配的字符串会可以当成变量来使用，sed中使用的是\1,\2…</p>
<p><code>sed &#39;N;s/my/your/&#39; pets.txt</code> 原文本中的偶数行纳入奇数行匹配，而s只匹配并替换一次，所以最后只有奇数行被修改。 N命令把下一行的内容纳入当成缓冲区做匹配。</p>
<p><code>sed &quot;1 i This is my monkey, my monkey&#39;s name is wukong&quot; my.txt</code> 和 <code>sed &quot;$ a This is my monkey, my monkey&#39;s name is wukong&quot; my.txt</code>  命令i和a分别表示insert 和 append，添加行</p>
<p><code>sed &quot;/my/a ----&quot; my.txt</code> 在每行结尾都添加 —-</p>
<p><code>sed &quot;2 c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt</code> 和 <code>sed &quot;/fish/c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt</code> 命令c表示替换，这两个命令分别表示替换第二行和有’fish’存在的那一行。</p>
<p><code>sed &#39;/fish/d&#39; my.txt</code> 和 <code>sed &#39;2d&#39; my.txt</code> 和 <code>sed &#39;2,$d&#39; my.txt</code> 命令d表示删除匹配行，这三个命令分别表示删除有fish的一行，删除第二行和删除第二到最后的所有行。</p>
<p><code>sed -n &#39;/dog/,/fish/p&#39; my.txt</code> 命令-n表示只显示处理后的结果，命令p表示打印，图中命令表示打印有dog的一行和有fish的一行。</p>
<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p><code>grep -i -c &#39;.*ret.*&#39; linux-exec.s</code> 统计内核二级制文件中ret命令的个数，不区分大小写，直接输出匹配行数。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>bash</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>linux</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树非递归遍历</title>
    <url>/2020/11/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>二叉树非递归遍历总是容易忘，这次从原理出发理解一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \ &#x2F;</span><br><span class="line">4  5 6</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="preorder"><a href="#preorder" class="headerlink" title="preorder"></a>preorder</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handle(p-&gt;val);</span><br><span class="line">preorder(root-&gt;left);</span><br><span class="line">preorder(root-&gt;right);</span><br></pre></td></tr></table></figure>

<p>1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6 </p>
<p>先序输出顺序是中左右，因此首先输出，其次要保存左子树，穷尽左子树之后弹出节点，最后输出右子树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack&lt;TreeNode*&gt; st;</span><br><span class="line">TreeNode* p &#x3D; root;</span><br><span class="line">while (p !&#x3D; NULL || !st.empty()）&#123;</span><br><span class="line">    while (p !&#x3D; NULL) &#123;</span><br><span class="line">        handle(p-&gt;val);</span><br><span class="line">        st.push(p);</span><br><span class="line">        p &#x3D; p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!st.empty()) &#123;</span><br><span class="line">        p &#x3D; st.top();</span><br><span class="line">        st.pop();</span><br><span class="line">        p &#x3D; p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="inorder"><a href="#inorder" class="headerlink" title="inorder"></a>inorder</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inorder(p-&gt;left);</span><br><span class="line">handle(p-&gt;val);</span><br><span class="line">inorder(p-&gt;right);</span><br></pre></td></tr></table></figure>

<p>4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3</p>
<p>中序遍历的输出顺序是左中右，和先序遍历有相似性，因为也需要先保存左子树，再弹出左子树找到中和右。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack&lt;TreeNode*&gt; st;</span><br><span class="line">TreeNode* p &#x3D; root;</span><br><span class="line">while (p !&#x3D; NULL || !st.empty()) &#123;</span><br><span class="line">    st.push(p);</span><br><span class="line">    p &#x3D; p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">if (!st.empty()) &#123;</span><br><span class="line">    p &#x3D; st.top();</span><br><span class="line">    st.pop();</span><br><span class="line">    handle(p-&gt;val);</span><br><span class="line">    p &#x3D; p-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="postorder"><a href="#postorder" class="headerlink" title="postorder"></a>postorder</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postorder(p-&gt;left);</span><br><span class="line">postorder(p-&gt;right);</span><br><span class="line">handle(p-&gt;val);</span><br></pre></td></tr></table></figure>

<p>4-&gt;5-&gt;2-&gt;6-&gt;3-&gt;1</p>
<p>后序遍历输出顺序是左右中，先保存左侧节点，然后检查右侧节点，当右子树为空或者已经被访问了，可以访问这个节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack&lt;TreeNode*&gt; st;</span><br><span class="line">TreeNode* p &#x3D; root;</span><br><span class="line">while (p !&#x3D; NULL || !st.empty()) &#123;</span><br><span class="line">    while (p !&#x3D; NULL) &#123;</span><br><span class="line">        st.push(p);</span><br><span class="line">        p &#x3D; p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#x3D; s.top();</span><br><span class="line">    TreeNode* tmp &#x3D; NULL;</span><br><span class="line">    while (!st.empty() &amp;&amp; (p-&gt;right &#x3D;&#x3D; NULL || p-&gt;right &#x3D;&#x3D; tmp)) &#123;</span><br><span class="line">        st.pop();</span><br><span class="line">        if (!st.empty()) &#123;</span><br><span class="line">            tmp &#x3D; p;</span><br><span class="line">            p &#x3D; st.top();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (st.emtpy()) break;</span><br><span class="line">    p &#x3D; p-&gt;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</p>
<p>广度优先按照层次每次保存一层，当输出的时候记录当前队列长度，该长度即为上层被保存的节点数量，依次遍历即为按层次输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line">TreeNode* p &#x3D; NULL;</span><br><span class="line">q.push(p);</span><br><span class="line">while (!q.emtpy()) &#123;</span><br><span class="line">    int size &#x3D; q.size();</span><br><span class="line">    for (int i &#x3D; 0;i &lt; size;i++) &#123;</span><br><span class="line">        p &#x3D; q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        handle(p-&gt;val);</span><br><span class="line"></span><br><span class="line">        if (p-&gt;left !&#x3D; NULL) q.push(p-&gt;left);</span><br><span class="line">        if (p-&gt;right !&#x3D; NULL) q.push(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>binarytree</tag>
      </tags>
  </entry>
  <entry>
    <title>内核近期改变</title>
    <url>/2020/11/15/%E5%86%85%E6%A0%B8%E8%BF%91%E6%9C%9F%E6%94%B9%E5%8F%98/</url>
    <content><![CDATA[<h1 id="内核近期改变"><a href="#内核近期改变" class="headerlink" title="内核近期改变"></a>内核近期改变</h1><ul>
<li><a href="#%E5%86%85%E6%A0%B8%E8%BF%91%E6%9C%9F%E6%94%B9%E5%8F%98">内核近期改变</a><ul>
<li><a href="#ioctl">ioctl</a><ul>
<li><a href="#1%E5%8E%9F%E5%A7%8B%E7%89%88%E6%9C%AC%E7%9A%84ioctl">1.原始版本的ioctl</a></li>
<li><a href="#2%E5%86%85%E6%A0%B8%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84ioctl">2.内核改进后的ioctl</a></li>
<li><a href="#3%E5%9C%A8%E7%BC%96%E5%86%99%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95">3.在编写过程中的处理办法</a></li>
<li><a href="#4-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90">4. 原因分析</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5io-read_iter">异步I/O read_iter</a><ul>
<li><a href="#1%E5%85%B7%E4%BD%93%E5%8F%98%E5%8C%96">1.具体变化</a></li>
<li><a href="#2%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90">2.原因分析</a></li>
<li><a href="#3%E9%97%AE%E9%A2%98">3.问题</a></li>
</ul>
</li>
<li><a href="#timer%E8%AE%A1%E6%97%B6%E5%99%A8%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98">timer计时器发生改变</a></li>
<li><a href="#block-%E9%A9%B1%E5%8A%A8%E5%9C%A850%E5%90%8E%E8%BF%9B%E8%A1%8C%E4%BA%86%E9%9D%9E%E5%B8%B8%E5%A4%A7%E7%9A%84%E5%8F%98%E5%8C%96">block 驱动在5.0后进行了非常大的变化</a><ul>
<li><a href="#%E5%8E%9F%E5%9B%A0">原因</a></li>
<li><a href="#blk-mq-%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%A4%E5%B1%82%E9%98%9F%E5%88%97">blk-mq 设计了两层队列</a></li>
<li><a href="#%E5%9C%A8%E6%9E%B6%E6%9E%84%E5%B1%82%E9%9D%A2">在架构层面</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E5%88%B0%E5%87%BD%E6%95%B0">具体到函数</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E6%A0%B8%E8%AE%A1%E6%97%B6%E6%8E%A5%E5%8F%A3%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96">内核计时接口发生变化</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8E%A5%E5%8F%A3%E5%8F%98%E5%8C%96%E6%9C%AA%E8%A7%A3%E5%86%B3">系统调用初始化接口变化（未解决）</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%87%8F%E5%B0%91%E5%AE%9A%E4%B9%89%E6%95%B0%E9%87%8F-%E6%9C%AA%E8%A7%A3%E5%86%B3">文件系统减少定义数量 （未解决）</a></li>
<li><a href="#jprobe-%E8%A2%AB%E5%8F%96%E6%B6%88">jprobe 被取消</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><h3 id="1-原始版本的ioctl"><a href="#1-原始版本的ioctl" class="headerlink" title="1.原始版本的ioctl"></a>1.原始版本的ioctl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long);</span><br></pre></td></tr></table></figure>

<h3 id="2-内核改进后的ioctl"><a href="#2-内核改进后的ioctl" class="headerlink" title="2.内核改进后的ioctl"></a>2.内核改进后的ioctl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line"></span><br><span class="line">long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br></pre></td></tr></table></figure>

<h3 id="3-在编写过程中的处理办法"><a href="#3-在编写过程中的处理办法" class="headerlink" title="3.在编写过程中的处理办法"></a>3.在编写过程中的处理办法</h3><ul>
<li><p>将原先的写的 ioctl 函数声明给改成下面的 unlocked_ioctl 或者 compat_ioctl,</p>
</li>
<li><p>在 file_operations 结构体的初始化中也是一样. 修改为unlocked_ioctl 或者 compat_ioctl,</p>
</li>
<li><p>注意参数的兼容性问题, 新的ioctl() 接口没有 struct inode* 参数, 如果ioctl 接口中使用了 inode, 因此需要通过其他方式获取 inode</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36)</span><br><span class="line">static int XXX_ioctl(</span><br><span class="line">        struct inode *indoe,</span><br><span class="line">        struct file *filp,</span><br><span class="line">        unsigned int cmd,</span><br><span class="line">        unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">#else</span><br><span class="line">&#x2F;&#x2F;long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">&#x2F;&#x2F;long (*compat_ioctl) (struct file *, unsigned int cmd, unsigned long arg)</span><br><span class="line">static long XXX_unlocked_ioctl(</span><br><span class="line">        struct file *filp,</span><br><span class="line">        unsigned int cmd,</span><br><span class="line">        unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;f_dentry-&gt;d_inode;</span><br><span class="line">    &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;d_inode;</span><br><span class="line">    struct inode *inode &#x3D; inode &#x3D; file_inode(filp);</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;*  此处是ioctl() 函数结构的具体实现  *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，file_operations中也进行同样修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct file_operations fpga_fops &#x3D; &#123;</span><br><span class="line">    .owner  &#x3D; THIS_MODULE,</span><br><span class="line">    .open   &#x3D; fpga_open,</span><br><span class="line">    .read   &#x3D; fpga_read,</span><br><span class="line">    .write &#x3D; fpga_write,</span><br><span class="line">    .llseek &#x3D; fpga_llseek,</span><br><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36)</span><br><span class="line">    .ioctl &#x3D; XXX_ioctl,</span><br><span class="line">#else</span><br><span class="line">    .unlocked_ioctl &#x3D; XXX_unlocked_ioctl,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="4-原因分析"><a href="#4-原因分析" class="headerlink" title="4. 原因分析"></a>4. 原因分析</h3><p><code>file_operations (include/linux/fs.h)</code> 结构变化,ioctl本身并不安全，且之前的ioctl使用了大内核锁延迟太大，因此进行修改。具体内容见<br><a href="https://lwn.net/Articles/119652/">The new way of ioctl()</a></p>
<h2 id="异步I-O-read-iter"><a href="#异步I-O-read-iter" class="headerlink" title="异步I/O read_iter"></a>异步I/O read_iter</h2><h3 id="1-具体变化"><a href="#1-具体变化" class="headerlink" title="1.具体变化"></a>1.具体变化</h3><p><code>file_operations (include/linux/fs.h)</code> 结构变化，导致</p>
<p><code>read_iter</code> 和 <code>write_iter</code> 负责设备驱动的异步读写，取代了之前的 <code>aio_read</code> 和 <code>aio_write</code>,只需要将资料中二者进行转换即可。</p>
<h3 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2.原因分析"></a>2.原因分析</h3><p><a href="https://lwn.net/Articles/625077/">The iov_iter interface</a></p>
<p>iov_iter 功能增强了，并且试图合并 read(write)_iter 和 splice_read(write)，不过截至2020年5月13日来看这俩似乎还存在着</p>
<h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h3><p><code>fs/ramfs/file-mmu.c</code> 中为什么 <code>file_operations</code> 里面没有定义 read 和 write， 而只有异步I/O。</p>
<h2 id="timer计时器发生改变"><a href="#timer计时器发生改变" class="headerlink" title="timer计时器发生改变"></a>timer计时器发生改变</h2><p><a href="https://lwn.net/Articles/735887/">Improving the kernel timers API</a><br>用 <code>timer_setup</code> 替换了 <code>init_timer</code>,替换内核版本为4.14(2017)，属于较新的替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0)</span><br><span class="line">    init_timer(&amp;dev-&gt;getIntrTimer);</span><br><span class="line">    dev-&gt;getIntrTimer.data &#x3D; (unsigned long) dev;</span><br><span class="line">    dev-&gt;getIntrTimer.function &#x3D; GetIntrTimerCallback;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">    add_timer(&amp;dev-&gt;getIntrTimer);</span><br><span class="line">#else</span><br><span class="line">    timer_setup(&amp;dev-&gt;getIntrTimer, GetIntrTimerCallback, 0);</span><br><span class="line">    &#x2F;* the third argument may include TIMER_* flags *&#x2F;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>callback function的变化 <strong>参数类型发生变化，否则会编译失败</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0)</span><br><span class="line">void GetIntrTimerCallback(unsigned long devAddr)</span><br><span class="line">&#123;</span><br><span class="line">    myDevice *dev &#x3D; (myDevice *) devAddr;</span><br><span class="line">#else</span><br><span class="line">void GetIntrTimerCallback(struct timer_list *t)</span><br><span class="line">&#123;</span><br><span class="line">    myDevice *dev &#x3D; from_timer(dev, t, getIntrTimer);</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* Do something with &quot;dev&quot; *&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="block-驱动在5-0后进行了非常大的变化"><a href="#block-驱动在5-0后进行了非常大的变化" class="headerlink" title="block 驱动在5.0后进行了非常大的变化"></a>block 驱动在5.0后进行了非常大的变化</h2><p><a href="https://www.linuxquestions.org/questions/linux-kernel-70/in-kernel-v5-blk_fetch_request-and-blk_init_queue-gone-now-what-4175670215/">In kernel V5 blk_fetch_request() and blk_init_queue() gone. Now What?</a>  </p>
<p><a href="https://prog.world/linux-kernel-5-0-we-write-simple-block-device-under-blk-mq/">Linux Kernel 5.0 – we write Simple Block Device under blk-mq</a>  </p>
<p><a href="https://patchwork.kernel.org/patch/10048915/">block: remove __bio_kmap_atomic</a></p>
<p><strong>内核工匠 公众号 Multiqueue架构分析</strong></p>
<p>block 驱动在5.0后进行了非常大的变化</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>是使用了 multi-queue block layer 即 blk-mq 完全取代了之前的 blk-sq（single-queue），<br>因为从前的IO速度瓶颈在硬件方面，因此可以使用单一队列，即使多个cpu竞争自旋锁获取队列写入权限依旧不过分影响性能。<br>而最近的高IOPS（io per second）硬件逐渐增多比如ssd，nvme等硬件设备开始大量使用，那么从前的single queue在高IOPS场景下80% cpu时间耗费在锁获取上了，因此设计了新的blk-mq 获取锁仅占用 3% cpu时间。</p>
<h3 id="blk-mq-设计了两层队列"><a href="#blk-mq-设计了两层队列" class="headerlink" title="blk-mq 设计了两层队列"></a>blk-mq 设计了两层队列</h3><ol>
<li><p>首先为每个cpu分配了一个软件暂存队列（software staging queue），负责完成bio 提交/完成处理，IO请求暂存（合并、排序等）、IO请求标记、调度、记账（和新的IO调度算法BFS有关）</p>
</li>
<li><p>硬件派发队列（Hardware Dispatch Queue） 为每个硬件队列分派一个硬件派发队列，负责存放软件队列向硬件派发的IO请求，一个和多个软件队列和一个硬件队列存在固定映射关系</p>
</li>
</ol>
<h3 id="在架构层面"><a href="#在架构层面" class="headerlink" title="在架构层面"></a>在架构层面</h3><p>mq 将 request 和 tag 绑定，request内存分配在块设备驱动初始化时完成（调用blk_mq_alloc_tag_set）避免IO时分配request内存带来消耗</p>
<p>tag作为request（static_rqs/rqs）的索引。</p>
<h3 id="具体到函数"><a href="#具体到函数" class="headerlink" title="具体到函数"></a>具体到函数</h3><p>有 <code>blk_fetch_request</code> , <code>__blk_end_request_cur</code>  ,<code>blk_init_queue</code>, <code>__bio_kmap_atomic(bio, iter)</code> , <code>__bio_kunmap_atomic(buffer)</code> 等</p>
<p>其中 取代 <code>__bio_kmap_atomic(bio, iter)</code> , <code>__bio_kunmap_atomic(buffer)</code> 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-		char *buffer &#x3D; __bio_kmap_atomic(bio, iter);</span><br><span class="line">+		char *buffer &#x3D; kmap_atomic(bvec.bv_page) + bvec.bv_offset;</span><br><span class="line"> 		unsigned len &#x3D; bvec.bv_len &gt;&gt; SECTOR_SHIFT;</span><br><span class="line"> </span><br><span class="line"> 		simdisk_transfer(dev, sector, len, buffer,</span><br><span class="line"> 				bio_data_dir(bio) &#x3D;&#x3D; WRITE);</span><br><span class="line"> 		sector +&#x3D; len;</span><br><span class="line">-		__bio_kunmap_atomic(buffer);</span><br><span class="line">+		kunmap_atomic(buffer)</span><br></pre></td></tr></table></figure>

<p>除此之外 <code>BLK_MQ_F_SG_MERGE</code> 和 <code>QUEUE_FLAG_NO_SG_MERGE</code>  都可以被省略了<br><a href="https://lore.kernel.org/patchwork/patch/1042759/">block: kill BLK_MQ_F_SG_MERGE</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-	lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;</span><br><span class="line">+	lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE;</span><br></pre></td></tr></table></figure>

<h2 id="内核计时接口发生变化"><a href="#内核计时接口发生变化" class="headerlink" title="内核计时接口发生变化"></a>内核计时接口发生变化</h2><p>64位系统中,由于<a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038问题</a> 时间戳 timespec 在 inode数据结构中的i_*time 中弃用，转而使用 timespec64</p>
<p>相应的 getnstimeofday 等函数也被弃用， 转而使用 <code>ktime_get_ts64(struct timespec64 *ts)</code> 等函数获取时间，另外需要注意 这个函数必须使用 GPL协议才能成功加载。</p>
<p>详见内核时间api文件，<br><a href="https://www.kernel.org/doc/html/latest/core-api/timekeeping.html">ktime accessors</a></p>
<p>最新设计的时间数据结构为 <code>ktime_t</code> 获取方式为 <code>ktime_t ktime_get(void)</code></p>
<h2 id="系统调用初始化接口变化（未解决）"><a href="#系统调用初始化接口变化（未解决）" class="headerlink" title="系统调用初始化接口变化（未解决）"></a>系统调用初始化接口变化（未解决）</h2><p>系统调用初始化接口代码越变越少，而且有点难以理解，除了在<code>arch/x86/entry/syscall</code> 目录下定义之外，还用了同目录下的脚本直接生成了ni代码</p>
<p>具体的解决办法是直接ftrace跟踪一波，看看syscall最新的调用路径</p>
<h2 id="文件系统减少定义数量-（未解决）"><a href="#文件系统减少定义数量-（未解决）" class="headerlink" title="文件系统减少定义数量 （未解决）"></a>文件系统减少定义数量 （未解决）</h2><p>文件系统减少了大量file_operations定义数量，例如 aio_read  aio_write 等异步代码直接被省略掉，read 和 write 接口基本也不定义了， 似乎使用了 read_iter 和 write_iter 替代了前两类接口</p>
<p>具体原因还没搞清楚，但是在 <a href="https://lore.kernel.org/patchwork/patch/350494/">[V5,17/30] fs: use read_iter and write_iter rather than aio_read and aio_write</a> 中显示 aio被明确删除掉，用iter替代。</p>
<p>此外 <code>file_operations</code> 当中的 readdir 等接口也被取消，直接由read/read_iter和 iterate 替代,iterate基本上可以理解为负责执行ls命令， filldentry_t 由 dir_context 替代。</p>
<h2 id="jprobe-被取消"><a href="#jprobe-被取消" class="headerlink" title="jprobe 被取消"></a>jprobe 被取消</h2><p>在 kprobe中只剩下kprobe和kretprobe，jprobe及相关的一套函数被取消，替代方式如下：</p>
<p><code>/source/samples/kprobes/kprobe_example.c</code> 和 <code>/source/samples/kprobes/kretprobe_example.c</code> 中示例</p>
<p>使用kprobe中的handler_pre和handler_post替代。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>可能经常用到的markdown语法和标签插件</title>
    <url>/2016/01/20/%E5%8F%AF%E8%83%BD%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84markdown%E8%AF%AD%E6%B3%95%E5%92%8C%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>本文没有系统介绍markdown语法和标签插件，而是仅仅列举的可能经常使用的markdown语法和标签插件样式</li>
</ul>
<p>l&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ol&gt;“ 都可以表示分点</p>
<ul>
<li>First</li>
<li>Second</li>
<li>Third</li>
<li>false<a id="more"></a>
<h2 id="关于换行"><a href="#关于换行" class="headerlink" title="关于换行"></a>关于换行</h2></li>
</ul>
<ul>
<li>单一段落( &lt;p&gt;) 用一个空白行</li>
<li>连续两个空格 会变成一个 &lt;br&gt;</li>
<li>连续3个符号，然后是空行，表示 hr横线</li>
</ul>
<h2 id="关于插入代码"><a href="#关于插入代码" class="headerlink" title="关于插入代码"></a>关于插入代码</h2><p> 可以是使用&lt;pre&gt;&lt;code&gt;code&lt;/code&gt;&lt;/pre&gt;形式插入代码，不过比较简陋</p>
<pre><code>cout << "Hello World!!" << endl; </code></pre>
<p> 另外的一种插入代码的方法</p>
<p> <figure class="highlight plain"><figcaption><span>[title] [lang:language] [url] [link text]</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;br&gt;code snippet&lt;br&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><figcaption><span>HelloWorld</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>


<h2 id="关于插入链接"><a href="#关于插入链接" class="headerlink" title="关于插入链接"></a>关于插入链接</h2><p> 直接写 [锚文本](url “可选的title”)<br> <a href="http://www.zi-c.wang/" title="紫城君的Blog">www.zi-c.wang</a></p>
<h2 id="关于插入图片url"><a href="#关于插入图片url" class="headerlink" title="关于插入图片url"></a>关于插入图片url</h2><p>![alt_text](url “可选的title”)<br><img src="http://i8.tietuku.com/78a8923ba6584002.jpg" alt="LiveLongAndProsper" title="LiveLongAndProsper"></p>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>直接在文本前面加上转义符 \ 就可以</p>
<h2 id="插入Youtube视频"><a href="#插入Youtube视频" class="headerlink" title="插入Youtube视频"></a>插入Youtube视频</h2><p><div class="video-container"><iframe src="https://www.youtube.com/embed/video_id" frameborder="0" loading="lazy" allowfullscreen></iframe></div></p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/https://www.youtube.com/watch?v=YG77IYQquB0" frameborder="0" loading="lazy" allowfullscreen></iframe></div>


]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel memory layout</title>
    <url>/2020/12/11/kernel-memory-layout/</url>
    <content><![CDATA[<p><a href="https://www.kernel.org/doc/html/latest/x86/x86_64/mm.html">latest mm documentation</a><br><a href="https://www.kernel.org/doc/html/latest/x86/boot.html?highlight=layout">latest boot documentatino</a><br><a href="https://lwn.net/Articles/338009/">x86: fix return from kernel to userspace with 16-bit stack</a></p>
<p>/Documentation/x86/x86_64/mm.txt</p>
<p>/Documentation/x86/boot.txt</p>
<a id="more"></a>
<p>随着芯片技术升级现在已经出现5级页表了，但是估计还是服务器上面居多，这里重点记录一下4级页表的布局</p>
<p>4页使用48位的虚拟地址，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    Start addr    |   Offset   |     End addr     |  Size   | VM area description</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> 0000000000000000 |    0       | 00007fffffffffff |  128 TB | user-space virtual memory, different per mm</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> 0000800000000000 | +128    TB | ffff7fffffffffff | ~16M TB | ... huge, almost 64 bits wide hole of non-canonical</span><br><span class="line">                  |            |                  |         |     virtual memory addresses up to the -128 TB</span><br><span class="line">                  |            |                  |         |     starting offset of kernel mappings.</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Kernel-space virtual memory, shared between all processes:</span><br><span class="line">____________________________________________________________|___________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> ffff800000000000 | -128    TB | ffff87ffffffffff |    8 TB | ... guard hole, also reserved for hypervisor</span><br><span class="line"> ffff880000000000 | -120    TB | ffff887fffffffff |  0.5 TB | LDT remap for PTI</span><br><span class="line"> ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)</span><br><span class="line"> ffffc88000000000 |  -55.5  TB | ffffc8ffffffffff |  0.5 TB | ... unused hole</span><br><span class="line"> ffffc90000000000 |  -55    TB | ffffe8ffffffffff |   32 TB | vmalloc&#x2F;ioremap space (vmalloc_base)</span><br><span class="line"> ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole</span><br><span class="line"> ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB | virtual memory map (vmemmap_base)</span><br><span class="line"> ffffeb0000000000 |  -21    TB | ffffebffffffffff |    1 TB | ... unused hole</span><br><span class="line"> ffffec0000000000 |  -20    TB | fffffbffffffffff |   16 TB | KASAN shadow memory</span><br><span class="line">__________________|____________|__________________|_________|____________________________________________________________</span><br><span class="line">                                                            |</span><br><span class="line">                                                            | Identical layout to the 56-bit one from here on:</span><br><span class="line">____________________________________________________________|____________________________________________________________</span><br><span class="line">                  |            |                  |         |</span><br><span class="line"> fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole</span><br><span class="line">                  |            |                  |         | vaddr_end for KASLR</span><br><span class="line"> fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping</span><br><span class="line"> fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole</span><br><span class="line"> ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks</span><br><span class="line"> ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole</span><br><span class="line"> ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space</span><br><span class="line"> ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole</span><br><span class="line"> ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0</span><br><span class="line"> ffffffff80000000 |-2048    MB |                  |         |</span><br><span class="line"> ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space</span><br><span class="line"> ffffffffff000000 |  -16    MB |                  |         |</span><br><span class="line">    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset</span><br><span class="line"> ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI</span><br><span class="line"> ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole</span><br><span class="line">__________________|____________|__________________|_________|___________________________________________________________</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Negative addresses such as “-23 TB” are absolute addresses in bytes, counted down from the top of the 64-bit address space. It’s easier to understand the layout when seen both in absolute addresses and in distance-from-top notation.<br>For example 0xffffe90000000000 == -23 TB, it’s 23 TB lower than the top of the 64-bit address space (ffffffffffffffff).</p>
</blockquote>
<p>现代的操作系统 bzImage kernel使用boot 协定 version &gt;= 2.02 的内存布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">              ~                        ~</span><br><span class="line">              |  Protected-mode kernel |</span><br><span class="line">      100000  +------------------------+</span><br><span class="line">              |  I&#x2F;O memory hole       |</span><br><span class="line">      0A0000  +------------------------+</span><br><span class="line">              |  Reserved for BIOS     |      Leave as much as possible unused</span><br><span class="line">              ~                        ~</span><br><span class="line">              |  Command line          |      (Can also be below the X+10000 mark)</span><br><span class="line">      X+10000 +------------------------+</span><br><span class="line">              |  Stack&#x2F;heap            |      For use by the kernel real-mode code.</span><br><span class="line">      X+08000 +------------------------+</span><br><span class="line">              |  Kernel setup          |      The kernel real-mode code.</span><br><span class="line">              |  Kernel boot sector    |      The kernel legacy boot sector.</span><br><span class="line">      X       +------------------------+</span><br><span class="line">              |  Boot loader           |      &lt;- Boot sector entry point 0000:7C00</span><br><span class="line">      001000  +------------------------+</span><br><span class="line">              |  Reserved for MBR&#x2F;BIOS |</span><br><span class="line">      000800  +------------------------+</span><br><span class="line">              |  Typically used by MBR |</span><br><span class="line">      000600  +------------------------+</span><br><span class="line">              |  BIOS use only         |</span><br><span class="line">      000000  +------------------------+</span><br><span class="line"></span><br><span class="line">... where the address X is as low as the design of the boot loader permits.</span><br></pre></td></tr></table></figure>

<p>解决一下 %esp fixup stacks</p>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef code pointer 代码指针</title>
    <url>/2020/12/12/typedef-code-pointer-%E4%BB%A3%E7%A0%81%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><code>typedef</code> 是把一个名字和一个类型联系起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int myinteger;</span><br><span class="line">typedef char *mystring;</span><br><span class="line">typedef void (*myfunc)();</span><br><span class="line"></span><br><span class="line">myinteger i;   &#x2F;&#x2F; is equivalent to    int i;</span><br><span class="line">mystring s;    &#x2F;&#x2F; is the same as      char *s;</span><br><span class="line">myfunc f;      &#x2F;&#x2F; compile equally as  void (*f)();</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>注意第三个给函数做typedef，目的是简化代码阅读的难度，尤其是指针指向函数和structure。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int (*t_somefunc)(int,int);</span><br><span class="line"></span><br><span class="line">int product(int u, int v) &#123;</span><br><span class="line">  return u*v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t_somefunc afunc &#x3D; &amp;product;</span><br><span class="line">...</span><br><span class="line">int x2 &#x3D; (*afunc)(123, 456); &#x2F;&#x2F; call product() to calculate 123*456</span><br></pre></td></tr></table></figure>

<p>在汇编中这是典型的间接跳转 call %rax</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">│B+ 0x555555555154 &lt;main+8&gt;         lea    -0x22(%rip),%rax        #0x555555555139 &lt;product&gt;    </span><br><span class="line">│</span><br><span class="line">│   0x55555555515b &lt;main+15&gt;        mov    %rax,-0x8(%rbp)     </span><br><span class="line">│</span><br><span class="line">│  &gt;0x55555555515f &lt;main+19&gt;        mov    -0x8(%rbp),%rax       </span><br><span class="line">│              </span><br><span class="line">│   0x555555555163 &lt;main+23&gt;        mov    $0x14,%esi   </span><br><span class="line">│</span><br><span class="line">│   0x555555555168 &lt;main+28&gt;        mov    $0xf,%edi  </span><br><span class="line">│</span><br><span class="line">│   0x55555555516d &lt;main+33&gt;        call   *%rax</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>access_ok 重要的函数指针传递分析</title>
    <url>/2020/12/15/access-ok-%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>/arch/x86/include/asm/uaccess.h</p>
<p>用于检查user space 的指针，是否超过用户地址空间的界限，读取或写入内核地址。</p>
<p>Checks if a pointer to a block of memory in user space is valid.</p>
<p>Note that, depending on architecture, this function probably just checks that the pointer is in the user space range</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define access_ok(addr, size)					\</span><br><span class="line">(&#123;									\</span><br><span class="line">	WARN_ON_IN_IRQ();						\</span><br><span class="line">	likely(!__range_not_ok(addr, size, user_addr_max()));		\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#define __range_not_ok(addr, size, limit)				\</span><br><span class="line">(&#123;									\</span><br><span class="line">	__chk_user_ptr(addr);						\</span><br><span class="line">	__chk_range_not_ok((unsigned long __force)(addr), size, limit); \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#define user_addr_max() (current-&gt;thread.addr_limit.seg)</span><br><span class="line"># define __chk_user_ptr(x)	(void)0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Test whether a block of memory is a valid user space address.</span><br><span class="line"> * Returns 0 if the range is valid, nonzero otherwise.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, unsigned long limit)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * If we have used &quot;sizeof()&quot; for the size,</span><br><span class="line">	 * we know it won&#39;t overflow the limit (but</span><br><span class="line">	 * it might overflow the &#39;addr&#39;, so it&#39;s</span><br><span class="line">	 * important to subtract the size from the</span><br><span class="line">	 * limit, not add it to the address).</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	if (__builtin_constant_p(size))</span><br><span class="line">		return unlikely(addr &gt; limit - size);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Arbitrary sizes? Be careful about overflow *&#x2F;</span><br><span class="line">	addr +&#x3D; size;</span><br><span class="line">	if (unlikely(addr &lt; size))</span><br><span class="line">		return true;</span><br><span class="line">	return unlikely(addr &gt; limit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>注意这里有一个__chk_user_ptr，编译器不会生成任何代码</p>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>装机</title>
    <url>/2020/12/27/%E8%A3%85%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="装机-硬件设备厂家选择"><a href="#装机-硬件设备厂家选择" class="headerlink" title="装机-硬件设备厂家选择"></a>装机-硬件设备厂家选择</h1><p>20201226</p>
<p>装机主要分成八个部分：CPU，主板，内存，显卡，硬盘，电源，散热，机箱</p>
<p>这篇文章主要是分析八种硬件有哪些型号，性能对比，以及厂商的质量和价格，最终目的是设计一套合理的装机配置。</p>
<a id="more"></a>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>显然可选的只有x86架构的intel和AMD。</p>
<p>在intel中可选的有自带核心显卡和不带的，其中低端的型号包括intel奔腾G5400，intel酷睿i3，AMD锐龙3 </p>
<p>之后中高端分别有intel i5、i7、i9， AMD 锐龙5、7、线程撕裂者</p>
<p>现在最新的intel core CPU已经到第十代了（i7 10700），8核心16线程，16MB缓存，支持内存DDR4-2933，分为四类（f表示没有核心显卡，k表示频率更高）</p>
<table>
    <tr><td>型号</td><td>主频</td><td>功率</td><td>散片价格</td><td>+微星B460主板价格</td></tr>
    <tr><td>10700f</td><td>2.9-4.8GHz</td><td>65w</td><td>1999</td><td>2729</td></tr>
    <tr><td>10700</td><td>2.9-4.8GHz</td><td>65w</td><td>2249</td><td></td></tr>
    <tr><td>10700kf</td><td>3.8-5.1GHz</td><td>125w</td><td>2199</td><td></td></tr>
    <tr><td>10700</td><td>3.8-5.1GHz</td><td>125w</td><td>2649</td><td></td></tr>
</table>

<p>支持的主板类型为华硕B460M-K，CPU插槽B460芯片组，LGA1200针</p>
<h1 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h1><p>RTX3070 显卡价格从3899-5000多，越贵PCB和散热可能更好，主要是RGB光污染税，其中OC表示over clock超频，注意看下功耗。</p>
<p>由于核心芯片是一致的，所以选择丐版就可以3899（有两个风扇和三个风扇的），主要可选的有</p>
<p><img src="/2020/12/27/%E8%A3%85%E6%9C%BA/rtx3070-brands.jpg" alt="gpu-brands"></p>
<p>图片从互联网下载，随时删除</p>
<h1 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h1><p>关键在于主板芯片和CPU匹配。</p>
<p>主要品牌有华硕、微星、技嘉（t1），华擎、映泰、七彩虹、铭瑄、昂达、影驰（t2）。</p>
<p>支持10代intel CPU的接口类型是<code>LGA1200</code>，具体的型号从H410-Z490都是。</p>
<p>芯片组的级别：intel X &gt; Z &gt; B &gt; H（AMD的TR&gt;X&gt;B&gt;A）</p>
<p>B系列比较常见，不能超频，最多支持i7，十代酷睿支持的芯片组有H410，B460，Z490，其中B460比较常见。</p>
<p>买的时候注意看看主板上面有多少个接口，内存，PCIe，USB，网卡，M.2硬盘等等。</p>
<p>供电也要进行注意，分为供电项数，通常和芯片组绑定。</p>
<p>最后还要注意主板的形状，因为需要搭配机箱。主流的有ATX和m-ATX（小），微星B460M价格在500-600</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>内存的频率表示最高稳定工作的频率，因此需要看看CPU和主板支持的最大运行频率，内存工作时收到自身频率的限制</p>
<p>想要买的i7 10700 支持内存频率是2933，因此2900-3200MHz都可以。</p>
<p>内存标配终身质保，如果不是的话不要买。内存DIE 频率最高的是DDR4</p>
<p>芝奇、海盗船，中段高端可以买，低端不要</p>
<p>金士顿贵一点，但是质保和质量好，威刚也可以，价格更亲民。</p>
<p>芝奇：8G马甲条239，16G马甲条439，幻光戟8G 249，16GB 569，工作频率3000MHz左右，要看一下主板支持不支持</p>
<p>金士顿：3200MHz，8GB 249，16GB 469。 2666MHz的便宜10-30块钱，有RBG污染的贵100.</p>
<p>海盗船：3200Mhz，8GB 274</p>
<h1 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h1><p>接口分为SATA、M.2和PCIe三种，</p>
<p>M.2接口相当于PCIe*4总线，要注意看是否支持NVMe协议，支持的速度更快。</p>
<p>三星，东芝，浦科特，intel，惠普，</p>
<p>三星M.2：256GB 389，512GB 549-649（读写速度有区别），1TB 1099-1369</p>
<p>三星SATA（速度大概是1/6）：1T 739</p>
<p>东芝M.2：500GB 655，1TB 1000</p>
<p>东芝SATA：480GB 369</p>
<p>金士顿M.2：500GB 439，1TB 749（速度比三星慢）</p>
<p>金士顿SATA：480GB 369，</p>
<p>机械硬盘西部数据，1TB 7200转SATA 279，加上1TB西部数据M.2一共卖1000出头。</p>
<h1 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h1><p>模组：非、半、全模组，区别是线材是否固定，全模组所有线材可以拆卸。</p>
<p>ATX电源用的最多，通常用这个。高配电脑1元1w好选择。</p>
<p>电源功率计算 CPU功率+GPU功率+100W余量。</p>
<p>650w<br>性价比款：台达459、鑫谷419、先马479</p>
<p>高品质：酷冷至尊469、振华、海韵</p>
<h1 id="散热器"><a href="#散热器" class="headerlink" title="散热器"></a>散热器</h1><p>风冷主要看热管的数量，回流焊工艺更好，穿片</p>
<p>超频红海，九州风神，大镰刀赤兔马，利民</p>
<p>8核建议6根热管，8根热管的，九州风神，追风者，利民，猫头鹰 200-600</p>
<p>200-500</p>
<h1 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h1><p>主要考虑主板支持，显卡限长，散热器限高，电源支持。250-500</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2700（CPU+主板）+4000（GPU）+500（16gb内存）+1000（1TB固态）+450（650w电源）+300（散热器）+300（机箱）</p>
<p>合计9250</p>
]]></content>
      <tags>
        <tag>硬件</tag>
        <tag>装机</tag>
      </tags>
  </entry>
  <entry>
    <title>内核栈与vmap kernel stack</title>
    <url>/2021/01/15/%E5%86%85%E6%A0%B8%E6%A0%88%E4%B8%8Evmap-kernel-stack/</url>
    <content><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://lwn.net/Articles/692208/">Virtually mapped kernel stacks</a><br><a href="https://lwn.net/Articles/691631/">Virtually mapped stacks with guard pages (x86, core)</a></p>
<p>kernel stack在64位系统上通常是8k或16k连续映射，但是很容易造成溢出，而且在内存被大量占用的情况下不太容易找到连续的2页或4页。</p>
<p>因此有开发者提出了解决办法，使用vmap解决这两个问题,使得内核栈在溢出时print一个错误信息。</p>
<a id="more"></a>
<h1 id="Virtually-mapped-stacks"><a href="#Virtually-mapped-stacks" class="headerlink" title="Virtually mapped stacks"></a>Virtually mapped stacks</h1><p>作者 Andy Lutomirski 使用vmalloc分配内核栈，然而这面临着内存分配速度1.5us，比较慢的问题。</p>
<p>作者本来打算不管这套，并且想让vmalloc速度快点，但是linus建议为per_cpu分配几个cache，实际实现的过程中是为每个CPU分配了2个cache</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NR_CACHED_STACKS 2</span><br><span class="line">static DEFINE_PER_CPU(struct vm_struct *, cached_stacks[NR_CACHED_STACKS]);</span><br></pre></td></tr></table></figure>

<p>如果其中一个能用就分配给申请的task，如果两个都不行就再申请个新的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i &#x3D; 0; i &lt; NR_CACHED_STACKS; i++) &#123;</span><br><span class="line">		struct vm_struct *s;</span><br><span class="line"></span><br><span class="line">		s &#x3D; this_cpu_xchg(cached_stacks[i], NULL);</span><br><span class="line"></span><br><span class="line">		if (!s)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#x2F;* Clear the KASAN shadow of the stack. *&#x2F;</span><br><span class="line">		kasan_unpoison_shadow(s-&gt;addr, THREAD_SIZE);</span><br><span class="line"></span><br><span class="line">		&#x2F;* Clear stale pointers from reused stack. *&#x2F;</span><br><span class="line">		memset(s-&gt;addr, 0, THREAD_SIZE);</span><br><span class="line"></span><br><span class="line">		tsk-&gt;stack_vm_area &#x3D; s;</span><br><span class="line">		tsk-&gt;stack &#x3D; s-&gt;addr;</span><br><span class="line">		return s-&gt;addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * Allocated stacks are cached and later reused by new threads,</span><br><span class="line">	 * so memcg accounting is performed manually on assigning&#x2F;releasing</span><br><span class="line">	 * stacks to tasks. Drop __GFP_ACCOUNT.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	stack &#x3D; __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,</span><br><span class="line">				     VMALLOC_START, VMALLOC_END,</span><br><span class="line">				     THREADINFO_GFP &amp; ~__GFP_ACCOUNT,</span><br><span class="line">				     PAGE_KERNEL,</span><br><span class="line">				     0, node, __builtin_return_address(0));</span><br></pre></td></tr></table></figure>
<h2 id="kconfig"><a href="#kconfig" class="headerlink" title="kconfig"></a>kconfig</h2><ul>
<li>CONFIG_HAVE_ARCH_VMAP_STACK=y</li>
<li>CONFIG_VMAP_STACK=y</li>
</ul>
<h1 id="原本的内核栈"><a href="#原本的内核栈" class="headerlink" title="原本的内核栈"></a>原本的内核栈</h1><p>直接申请物理页，赋予的地址在直接映射区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct page *page &#x3D; alloc_pages_node(node, THREADINFO_GFP,</span><br><span class="line">				     THREAD_SIZE_ORDER);</span><br><span class="line"></span><br><span class="line">if (likely(page)) &#123;</span><br><span class="line">	tsk-&gt;stack &#x3D; page_address(page);</span><br><span class="line">	return tsk-&gt;stack;</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么LKM无法直接调用swapper_pg_dir--内核中的static变量和函数</title>
    <url>/2021/03/01/%E4%B8%BA%E4%BB%80%E4%B9%88LKM%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8swapper-pg-dir-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84static%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="kernel-static-functions-内核静态函数"><a href="#kernel-static-functions-内核静态函数" class="headerlink" title="kernel static functions 内核静态函数"></a>kernel static functions 内核静态函数</h1><p>在编写drivers想要调用一些敏感的内核函数时，往往会出现<code>xxx undefined</code>这种情况，并不能通过加入头文件的方式解决。</p>
<p>深入了解一下，以<code>__p4d_alloc</code>为例：</p>
<p>在<code>include/linux/mm.h</code>中声明<code>static inline int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)</code> 为静态内联函数</p>
<p>那么为什么在driver中无法调用静态函数呢？这回归到了C语言的一个基础问题，static到底是做什么的？</p>
<a id="more"></a>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ol>
<li>可见性不同，全局变量，所有未加static的全局变量和全局函数都有全局可见性，如在文件1中定义的函数和变量可以在文件2中调用，但是加上了static在文件2中则不可见。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char a &#x3D; &#39;A&#39;; &#x2F;&#x2F; global variable</span><br><span class="line">void msg()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">--------------另一个文件-----------</span><br><span class="line">int main(void)</span><br><span class="line">&#123;    </span><br><span class="line">    extern char a;    &#x2F;&#x2F; extern variable must be declared before use</span><br><span class="line">    printf(&quot;%c &quot;, a);</span><br><span class="line">    (void)msg();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>生命周期是整个程序，在程序启动时初始化，全局变量和static变量（全局和局部）都存储在静态存储区，主要区别在于可见性不同。</li>
<li>默认初始化为0,因为静态区默认初始化为0.</li>
</ol>
<p>因此我们能够明白为什么在LKM中我们无法直接调用<code>__p4d_alloc</code> 和 <code>swapper_pg_dir</code> 这些符号，因为都是被static限定了适用范围。</p>
<h1 id="头文件中的static-inline声明"><a href="#头文件中的static-inline声明" class="headerlink" title="头文件中的static inline声明"></a>头文件中的static inline声明</h1><p>头文件中最好不要使用static声明函数，因为：</p>
<blockquote>
<p>头文件中的 static 函数会在每个文件中生成一份代码，这造成代码冗余倒不是最大的问题，最大的问题是可能带来库文件与工程文件同一函数的代码的不一致性，这有风险。</p>
</blockquote>
<p>但是有例外情况 比如内核中大量<code>static inline int pud_present(pud_t pud)</code>这类函数，定义为static inline</p>
<p>因为c语言中的inline 关键字只是建议内联，通常编译器不执行，但是如果使用 <code>static inline</code> 则会保证一定<strong>内联</strong>。</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>目前看来唯一可行的办法是通过地址引用<code>struct mmstruct *INIT_MM = 0xaddress</code>。</p>
<p>另外记录两次失败案例：</p>
<ul>
<li>将static 函数使用 <code>EXPORT_SYMBOL()</code>导出，结果是无法载入内核中</li>
<li>将函数改为非static，则无法通过编译。</li>
</ul>
<p>这里编译浪费了好多时间，不要轻易尝试。</p>
<p>如果只想通过编译，可以使用obj-y，显然无法生成.ko</p>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
        <tag>c</tag>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel compile: obj-m or obj-y</title>
    <url>/2021/03/01/kernel-compile-obj-m-or-obj-y/</url>
    <content><![CDATA[<h1 id="obj-m-obj-y"><a href="#obj-m-obj-y" class="headerlink" title="obj-m/obj-y"></a>obj-m/obj-y</h1><p>使用obj-m可以将文件编译成单独的.ko文件</p>
<p>使用obj-y可以将文件编译到内核的zImage中</p>
<p>使用obj-n表示不编译</p>
<p>内核中常见的还有 obj-$(SYM) 这种类型的，一般$(SYM)可以取值为y，m</p>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>linux</tag>
        <tag>compile</tag>
      </tags>
  </entry>
  <entry>
    <title>llvm 获取代码+编译</title>
    <url>/2021/04/03/llvm-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%A0%81-%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="llvm-获取代码-编译"><a href="#llvm-获取代码-编译" class="headerlink" title="llvm 获取代码+编译"></a>llvm 获取代码+编译</h1><p><a href="https://wiki.archlinux.org/index.php/Swap_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6">swapfile</a><br><a href="http://www.aosabook.org/en/llvm.html">llvm作者写的文档</a><br><a href="https://llvm.org/docs/GettingStarted.html#id17">llvm-doc</a><br><a href="https://llvm.org/docs/tutorial/index.html">llvm-tutorial</a><br><a href="https://zhuanlan.zhihu.com/p/36769900">zhihu-编译llvm内存不够情况</a><br><a href="https://zhuanlan.zhihu.com/p/67625228">zhihu-编译llvm clang</a><br><a href="https://clangbuiltlinux.github.io/">ClangBuiltLinux</a><br><a href></a>  </p>
<h1 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;mirrors&#x2F;llvm-project.git</span><br><span class="line">git checkout llvmorg-12.0.0-rc2</span><br><span class="line">&lt;!-- 因为zzzq的原因master分支不让用了,本次编译了rc2 --&gt;</span><br></pre></td></tr></table></figure>
<p>github不加代理实在太慢了</p>
<p>编译出来结果至少有120GB，因此最好分配一个200GB的虚拟机</p>
<a id="more"></a>

<h1 id="编译llvm"><a href="#编译llvm" class="headerlink" title="编译llvm"></a>编译llvm</h1><p>首先下载llvm源代码，然后进行编译，要注意llvm编译过程中耗费大量内存，因此需要额外进行处理。</p>
<ol>
<li><p>创建llvm-build文件夹，进入文件夹</p>
</li>
<li><p>cmake</p>
</li>
</ol>
<p>根据官网文档，试试看另一种编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX&#x3D;..&#x2F;install -DCMAKE_BUILD_TYPE&#x3D;Debug -DLLVM_TARGETS_TO_BUILD&#x3D;X86  -DLLVM_USE_LINKER&#x3D;gold -DLLVM_ENABLE_PROJECTS&#x3D;&quot;clang;lld&quot;   ..&#x2F;llvm&#x2F;</span><br></pre></td></tr></table></figure>



<p>这里</p>
<ul>
<li>DCMAKE_BUILD_TYPE 有Debug 和 Release因为我要后期开发，因此使用debug</li>
<li>DCMAKE_INSTALL_PREFIX 表示安装的文件夹，这里显示是上层目录，即llvm-source-code目录下的install文件夹</li>
<li>DLLVM_USE_LINKER=gold 使用gold链接器替换ld，据说能够节省大量内存</li>
<li>DLLVM_TARGETS_TO_BUILD=X86  只编译x86相关的指令即可</li>
<li>DLLVM_ENABLE_PROJECTS=”clang;lld”  这里可以一起编译clang和lld</li>
</ul>
<ol start="3">
<li>创建一个10GB的swap分区</li>
</ol>
<p>具体看<a href="https://wiki.archlinux.org/index.php/Swap_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6">swapfile</a>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fallocate -l 10G &#x2F;swapfile</span><br><span class="line"># dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swapfile bs&#x3D;1M count&#x3D;10240（和上面那条指令等价）</span><br><span class="line">chmod 600 &#x2F;swapfile</span><br><span class="line">mkswap &#x2F;swapfile</span><br><span class="line">swapon &#x2F;swapfile</span><br></pre></td></tr></table></figure>
<p>如果想保存swap分区可以编辑 <code>/etc/fstab</code> 增加这一条目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;swapfile none swap defaults 0 0</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>make<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make ; make install</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这里单线程，不要多线程，占用内存太多有崩溃风险</p>
<h1 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;home&#x2F;x&#x2F;Documents&#x2F;llvm-project&#x2F;install&#x2F;bin</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;x&#x2F;Documents&#x2F;llvm-project&#x2F;install&#x2F;lib</span><br><span class="line"></span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>

<p>目录中有 clang和llvm需要的一系列工具，但是没有ld.lld</p>
<h1 id="编译linux内核"><a href="#编译linux内核" class="headerlink" title="编译linux内核"></a>编译linux内核</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make LLVM&#x3D;1 -j4</span><br><span class="line"></span><br><span class="line">make CC&#x3D;clang  -j4</span><br></pre></td></tr></table></figure>

<p>注意这里不知道为什么没有ld.lld，可能需要单独安装一下。</p>
<p>如果想要使用llvm编译linux内核，需要查看一下<strong>ClangBuiltLinux</strong> 项目，这里面维护了几个所有编译都能通过的linux版本，其他版本则有这样或那样的可能导致编译失败。</p>
<p><a href="https://clangbuiltlinux.github.io/">ClangBuiltLinux</a>  </p>
<!-- ```
cmake -DCMAKE_BUILD_TYPE=Debug --enable-optimized --enable-targets=host-only -DCMAKE_INSTALL_PREFIX=../install  -DLLVM_USE_LINKER=gold -G "Unix Makefiles" ../llvm

cmake -DCMAKE_BUILD_TYPE=Debug --enable-optimized -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_INSTALL_PREFIX=../install  -DLLVM_USE_LINKER=gold -G "Unix Makefiles" ../llvm
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- # 编译clang</span><br><span class="line"></span><br><span class="line">此处需要编译过llvm之后才能进行编译，因为clang的cmake需要依赖llvm的编译结果</span><br><span class="line"></span><br><span class="line">1. 创建clang-build文件夹，进入文件夹</span><br><span class="line"></span><br><span class="line">2. cmake</span><br></pre></td></tr></table></figure>
<p>cmake -DCMAKE_BUILD_TYPE=Debug –enable-optimized –enable-targets=host-only -DCMAKE_INSTALL_PREFIX=../install  -DLLVM_USE_LINKER=gold -G “Unix Makefiles” ../clang</p>
<p>cmake -DCMAKE_BUILD_TYPE=Debug –enable-optimized -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_INSTALL_PREFIX=../install  -DLLVM_USE_LINKER=gold -G “Unix Makefiles” ../clang</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. make</span><br></pre></td></tr></table></figure>
<p>make ; make install</p>
<p>```</p>
<p>如果资源不够不要多线程，这里被卡死过一次。 –&gt;</p>
-->]]></content>
      <tags>
        <tag>compile</tag>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title>llvm-pass-build</title>
    <url>/2021/04/03/llvm-pass-build/</url>
    <content><![CDATA[<h1 id="llvm-pass-build"><a href="#llvm-pass-build" class="headerlink" title="llvm-pass-build"></a>llvm-pass-build</h1><p>llvm pass 编译有三种方式，直接上clang干，或者使用github skeleton项目给出的cmake，或者直接make</p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这里有个非常诡异的问题， <code>opt -load mypass.so</code>显示文件格式错误，但是<code>opt -load ./mypass.so</code> 就可以正常使用</p>
<p>因此记得 <strong>opt -load ./mypass.so</strong></p>
<h1 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang &#96;llvm-config --cxxflags&#96; -Wl,-znodelete -fno-rtti -fPIC -shared Hello.cpp -o LLVMHello.so &#96;llvm-config --ldflags&#96;</span><br><span class="line"></span><br><span class="line">opt -load .&#x2F;LLVMHello.so -hello test.bc</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LLVM_CONFIG?&#x3D;llvm-config</span><br><span class="line"></span><br><span class="line">SRC_DIR?&#x3D;$(PWD)</span><br><span class="line">LD_FLAGS+&#x3D;$(shell $(LLVM_CONFIG) --ldflags)</span><br><span class="line"></span><br><span class="line">COMMON_FLAGS&#x3D;-Wall -Wextra</span><br><span class="line">CXXFLAGS+&#x3D;$(COMMON_FLAGS) $(shell $(LLVM_CONFIG) --cxxflags)</span><br><span class="line">CXXFLAGS+&#x3D;-fPIC</span><br><span class="line">CPPFLAGS+&#x3D;$(shell $(LLVM_CONFIG) --cppflags) -T$(SRC_DIR)</span><br><span class="line">CPPFLAGS+&#x3D;-fPIC</span><br><span class="line"></span><br><span class="line">ifeq ($(shell uname), Darwin)</span><br><span class="line">LOADABLE_MODULE_OPTIONS&#x3D;-bundle -undefined dynamic_lookup</span><br><span class="line">else</span><br><span class="line">LOADABLE_MODULE_OPTIONS&#x3D;-shared -Wl,-O1</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">HELLOPASS&#x3D;hellopass.so</span><br><span class="line">HELLOPASS_OBJECTS&#x3D;Hello.o</span><br><span class="line"></span><br><span class="line">default: $(HELLOPASS)</span><br><span class="line"></span><br><span class="line">%.o : $(SRC_DIR)&#x2F;%.cpp</span><br><span class="line">	@echo Compiling $.cpp</span><br><span class="line">	$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $&lt;</span><br><span class="line"></span><br><span class="line">$(HELLOPASS) : $(HELLOPASS_OBJECTS)</span><br><span class="line">	@echo Linking</span><br><span class="line">	$(CXX) -o $@  $(LOADABLE_MODULE_OPTIONS) $(CXXFLAGS) $(LD_FLAGS) $^</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f $(HELLOPASS) $(HELLOPASS_OBJECTS)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/purplewall1206/llvm-practice/blob/main/tutorial/5-pass-test/Makefile">llvm-practice/tutorial/5-pass-test/Makefile</a></p>
<h1 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h1><p><a href="https://github.com/sampsyo/llvm-pass-skeleton">github skeleton</a></p>
<p>或者我的github</p>
<p><a href="https://github.com/purplewall1206/llvm-practice/tree/main/tutorial/6-instrumentation">llvm-practice/tutorial/6-instrumentation/</a></p>
]]></content>
      <tags>
        <tag>llvm</tag>
        <tag>compiler</tag>
        <tag>llvm-pass</tag>
        <tag>instrumentation</tag>
      </tags>
  </entry>
  <entry>
    <title>内核如何检测CPU features支持</title>
    <url>/2021/04/23/%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8BCPU-features%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h1 id="linux内核如何检查存在CPU-features支持"><a href="#linux内核如何检查存在CPU-features支持" class="headerlink" title="linux内核如何检查存在CPU features支持"></a>linux内核如何检查存在CPU features支持</h1><p><a href="https://elixir.bootlin.com/linux/v5.10.25/source/arch/x86/include/asm/cpufeatures.h">elixir code</a></p>
<p>代码所在地址 <code>arch/x86/include/asm/cpufeatures.h</code></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _ASM_X86_CPUFEATURES_H</span><br><span class="line">#define _ASM_X86_CPUFEATURES_H</span><br><span class="line"></span><br><span class="line">#ifndef _ASM_X86_REQUIRED_FEATURES_H</span><br><span class="line">#include &lt;asm&#x2F;required-features.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef _ASM_X86_DISABLED_FEATURES_H</span><br><span class="line">#include &lt;asm&#x2F;disabled-features.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Defines x86 CPU feature bits</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define NCAPINTS			19	   &#x2F;* N 32-bit words worth of info *&#x2F;</span><br><span class="line">#define NBUGINTS			1	   &#x2F;* N 32-bit bug flags *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Note: If the comment begins with a quoted string, that string is used</span><br><span class="line"> * in &#x2F;proc&#x2F;cpuinfo instead of the macro name.  If the string is &quot;&quot;,</span><br><span class="line"> * this feature bit is not displayed in &#x2F;proc&#x2F;cpuinfo at all.</span><br><span class="line"> *</span><br><span class="line"> * When adding new features here that depend on other features,</span><br><span class="line"> * please update the table in kernel&#x2F;cpu&#x2F;cpuid-deps.c as well.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Intel-defined CPU features, CPUID level 0x00000001 (EDX), word 0 *&#x2F;</span><br><span class="line">#define X86_FEATURE_FPU			( 0*32+ 0) &#x2F;* Onboard FPU *&#x2F;</span><br><span class="line">#define X86_FEATURE_VME			( 0*32+ 1) &#x2F;* Virtual Mode Extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_DE			( 0*32+ 2) &#x2F;* Debugging Extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_PSE			( 0*32+ 3) &#x2F;* Page Size Extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_TSC			( 0*32+ 4) &#x2F;* Time Stamp Counter *&#x2F;</span><br><span class="line">#define X86_FEATURE_MSR			( 0*32+ 5) &#x2F;* Model-Specific Registers *&#x2F;</span><br><span class="line">#define X86_FEATURE_PAE			( 0*32+ 6) &#x2F;* Physical Address Extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_MCE			( 0*32+ 7) &#x2F;* Machine Check Exception *&#x2F;</span><br><span class="line">#define X86_FEATURE_CX8			( 0*32+ 8) &#x2F;* CMPXCHG8 instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_APIC		( 0*32+ 9) &#x2F;* Onboard APIC *&#x2F;</span><br><span class="line">#define X86_FEATURE_SEP			( 0*32+11) &#x2F;* SYSENTER&#x2F;SYSEXIT *&#x2F;</span><br><span class="line">#define X86_FEATURE_MTRR		( 0*32+12) &#x2F;* Memory Type Range Registers *&#x2F;</span><br><span class="line">#define X86_FEATURE_PGE			( 0*32+13) &#x2F;* Page Global Enable *&#x2F;</span><br><span class="line">#define X86_FEATURE_MCA			( 0*32+14) &#x2F;* Machine Check Architecture *&#x2F;</span><br><span class="line">#define X86_FEATURE_CMOV		( 0*32+15) &#x2F;* CMOV instructions (plus FCMOVcc, FCOMI with FPU) *&#x2F;</span><br><span class="line">#define X86_FEATURE_PAT			( 0*32+16) &#x2F;* Page Attribute Table *&#x2F;</span><br><span class="line">#define X86_FEATURE_PSE36		( 0*32+17) &#x2F;* 36-bit PSEs *&#x2F;</span><br><span class="line">#define X86_FEATURE_PN			( 0*32+18) &#x2F;* Processor serial number *&#x2F;</span><br><span class="line">#define X86_FEATURE_CLFLUSH		( 0*32+19) &#x2F;* CLFLUSH instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_DS			( 0*32+21) &#x2F;* &quot;dts&quot; Debug Store *&#x2F;</span><br><span class="line">#define X86_FEATURE_ACPI		( 0*32+22) &#x2F;* ACPI via MSR *&#x2F;</span><br><span class="line">#define X86_FEATURE_MMX			( 0*32+23) &#x2F;* Multimedia Extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_FXSR		( 0*32+24) &#x2F;* FXSAVE&#x2F;FXRSTOR, CR4.OSFXSR *&#x2F;</span><br><span class="line">#define X86_FEATURE_XMM			( 0*32+25) &#x2F;* &quot;sse&quot; *&#x2F;</span><br><span class="line">#define X86_FEATURE_XMM2		( 0*32+26) &#x2F;* &quot;sse2&quot; *&#x2F;</span><br><span class="line">#define X86_FEATURE_SELFSNOOP		( 0*32+27) &#x2F;* &quot;ss&quot; CPU self snoop *&#x2F;</span><br><span class="line">#define X86_FEATURE_HT			( 0*32+28) &#x2F;* Hyper-Threading *&#x2F;</span><br><span class="line">#define X86_FEATURE_ACC			( 0*32+29) &#x2F;* &quot;tm&quot; Automatic clock control *&#x2F;</span><br><span class="line">#define X86_FEATURE_IA64		( 0*32+30) &#x2F;* IA-64 processor *&#x2F;</span><br><span class="line">#define X86_FEATURE_PBE			( 0*32+31) &#x2F;* Pending Break Enable *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* AMD-defined CPU features, CPUID level 0x80000001, word 1 *&#x2F;</span><br><span class="line">&#x2F;* Don&#39;t duplicate feature flags which are redundant with Intel! *&#x2F;</span><br><span class="line">#define X86_FEATURE_SYSCALL		( 1*32+11) &#x2F;* SYSCALL&#x2F;SYSRET *&#x2F;</span><br><span class="line">#define X86_FEATURE_MP			( 1*32+19) &#x2F;* MP Capable *&#x2F;</span><br><span class="line">#define X86_FEATURE_NX			( 1*32+20) &#x2F;* Execute Disable *&#x2F;</span><br><span class="line">#define X86_FEATURE_MMXEXT		( 1*32+22) &#x2F;* AMD MMX extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_FXSR_OPT		( 1*32+25) &#x2F;* FXSAVE&#x2F;FXRSTOR optimizations *&#x2F;</span><br><span class="line">#define X86_FEATURE_GBPAGES		( 1*32+26) &#x2F;* &quot;pdpe1gb&quot; GB pages *&#x2F;</span><br><span class="line">#define X86_FEATURE_RDTSCP		( 1*32+27) &#x2F;* RDTSCP *&#x2F;</span><br><span class="line">#define X86_FEATURE_LM			( 1*32+29) &#x2F;* Long Mode (x86-64, 64-bit support) *&#x2F;</span><br><span class="line">#define X86_FEATURE_3DNOWEXT		( 1*32+30) &#x2F;* AMD 3DNow extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_3DNOW		( 1*32+31) &#x2F;* 3DNow *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Transmeta-defined CPU features, CPUID level 0x80860001, word 2 *&#x2F;</span><br><span class="line">#define X86_FEATURE_RECOVERY		( 2*32+ 0) &#x2F;* CPU in recovery mode *&#x2F;</span><br><span class="line">#define X86_FEATURE_LONGRUN		( 2*32+ 1) &#x2F;* Longrun power control *&#x2F;</span><br><span class="line">#define X86_FEATURE_LRTI		( 2*32+ 3) &#x2F;* LongRun table interface *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Other features, Linux-defined mapping, word 3 *&#x2F;</span><br><span class="line">&#x2F;* This range is used for feature bits which conflict or are synthesized *&#x2F;</span><br><span class="line">#define X86_FEATURE_CXMMX		( 3*32+ 0) &#x2F;* Cyrix MMX extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_K6_MTRR		( 3*32+ 1) &#x2F;* AMD K6 nonstandard MTRRs *&#x2F;</span><br><span class="line">#define X86_FEATURE_CYRIX_ARR		( 3*32+ 2) &#x2F;* Cyrix ARRs (&#x3D; MTRRs) *&#x2F;</span><br><span class="line">#define X86_FEATURE_CENTAUR_MCR		( 3*32+ 3) &#x2F;* Centaur MCRs (&#x3D; MTRRs) *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* CPU types for specific tunings: *&#x2F;</span><br><span class="line">#define X86_FEATURE_K8			( 3*32+ 4) &#x2F;* &quot;&quot; Opteron, Athlon64 *&#x2F;</span><br><span class="line">#define X86_FEATURE_K7			( 3*32+ 5) &#x2F;* &quot;&quot; Athlon *&#x2F;</span><br><span class="line">#define X86_FEATURE_P3			( 3*32+ 6) &#x2F;* &quot;&quot; P3 *&#x2F;</span><br><span class="line">#define X86_FEATURE_P4			( 3*32+ 7) &#x2F;* &quot;&quot; P4 *&#x2F;</span><br><span class="line">#define X86_FEATURE_CONSTANT_TSC	( 3*32+ 8) &#x2F;* TSC ticks at a constant rate *&#x2F;</span><br><span class="line">#define X86_FEATURE_UP			( 3*32+ 9) &#x2F;* SMP kernel running on UP *&#x2F;</span><br><span class="line">#define X86_FEATURE_ART			( 3*32+10) &#x2F;* Always running timer (ART) *&#x2F;</span><br><span class="line">#define X86_FEATURE_ARCH_PERFMON	( 3*32+11) &#x2F;* Intel Architectural PerfMon *&#x2F;</span><br><span class="line">#define X86_FEATURE_PEBS		( 3*32+12) &#x2F;* Precise-Event Based Sampling *&#x2F;</span><br><span class="line">#define X86_FEATURE_BTS			( 3*32+13) &#x2F;* Branch Trace Store *&#x2F;</span><br><span class="line">#define X86_FEATURE_SYSCALL32		( 3*32+14) &#x2F;* &quot;&quot; syscall in IA32 userspace *&#x2F;</span><br><span class="line">#define X86_FEATURE_SYSENTER32		( 3*32+15) &#x2F;* &quot;&quot; sysenter in IA32 userspace *&#x2F;</span><br><span class="line">#define X86_FEATURE_REP_GOOD		( 3*32+16) &#x2F;* REP microcode works well *&#x2F;</span><br><span class="line">#define X86_FEATURE_SME_COHERENT	( 3*32+17) &#x2F;* &quot;&quot; AMD hardware-enforced cache coherency *&#x2F;</span><br><span class="line">#define X86_FEATURE_LFENCE_RDTSC	( 3*32+18) &#x2F;* &quot;&quot; LFENCE synchronizes RDTSC *&#x2F;</span><br><span class="line">#define X86_FEATURE_ACC_POWER		( 3*32+19) &#x2F;* AMD Accumulated Power Mechanism *&#x2F;</span><br><span class="line">#define X86_FEATURE_NOPL		( 3*32+20) &#x2F;* The NOPL (0F 1F) instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_ALWAYS		( 3*32+21) &#x2F;* &quot;&quot; Always-present feature *&#x2F;</span><br><span class="line">#define X86_FEATURE_XTOPOLOGY		( 3*32+22) &#x2F;* CPU topology enum extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_TSC_RELIABLE	( 3*32+23) &#x2F;* TSC is known to be reliable *&#x2F;</span><br><span class="line">#define X86_FEATURE_NONSTOP_TSC		( 3*32+24) &#x2F;* TSC does not stop in C states *&#x2F;</span><br><span class="line">#define X86_FEATURE_CPUID		( 3*32+25) &#x2F;* CPU has CPUID instruction itself *&#x2F;</span><br><span class="line">#define X86_FEATURE_EXTD_APICID		( 3*32+26) &#x2F;* Extended APICID (8 bits) *&#x2F;</span><br><span class="line">#define X86_FEATURE_AMD_DCM		( 3*32+27) &#x2F;* AMD multi-node processor *&#x2F;</span><br><span class="line">#define X86_FEATURE_APERFMPERF		( 3*32+28) &#x2F;* P-State hardware coordination feedback capability (APERF&#x2F;MPERF MSRs) *&#x2F;</span><br><span class="line">&#x2F;* free					( 3*32+29) *&#x2F;</span><br><span class="line">#define X86_FEATURE_NONSTOP_TSC_S3	( 3*32+30) &#x2F;* TSC doesn&#39;t stop in S3 state *&#x2F;</span><br><span class="line">#define X86_FEATURE_TSC_KNOWN_FREQ	( 3*32+31) &#x2F;* TSC has known frequency *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Intel-defined CPU features, CPUID level 0x00000001 (ECX), word 4 *&#x2F;</span><br><span class="line">#define X86_FEATURE_XMM3		( 4*32+ 0) &#x2F;* &quot;pni&quot; SSE-3 *&#x2F;</span><br><span class="line">#define X86_FEATURE_PCLMULQDQ		( 4*32+ 1) &#x2F;* PCLMULQDQ instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_DTES64		( 4*32+ 2) &#x2F;* 64-bit Debug Store *&#x2F;</span><br><span class="line">#define X86_FEATURE_MWAIT		( 4*32+ 3) &#x2F;* &quot;monitor&quot; MONITOR&#x2F;MWAIT support *&#x2F;</span><br><span class="line">#define X86_FEATURE_DSCPL		( 4*32+ 4) &#x2F;* &quot;ds_cpl&quot; CPL-qualified (filtered) Debug Store *&#x2F;</span><br><span class="line">#define X86_FEATURE_VMX			( 4*32+ 5) &#x2F;* Hardware virtualization *&#x2F;</span><br><span class="line">#define X86_FEATURE_SMX			( 4*32+ 6) &#x2F;* Safer Mode eXtensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_EST			( 4*32+ 7) &#x2F;* Enhanced SpeedStep *&#x2F;</span><br><span class="line">#define X86_FEATURE_TM2			( 4*32+ 8) &#x2F;* Thermal Monitor 2 *&#x2F;</span><br><span class="line">#define X86_FEATURE_SSSE3		( 4*32+ 9) &#x2F;* Supplemental SSE-3 *&#x2F;</span><br><span class="line">#define X86_FEATURE_CID			( 4*32+10) &#x2F;* Context ID *&#x2F;</span><br><span class="line">#define X86_FEATURE_SDBG		( 4*32+11) &#x2F;* Silicon Debug *&#x2F;</span><br><span class="line">#define X86_FEATURE_FMA			( 4*32+12) &#x2F;* Fused multiply-add *&#x2F;</span><br><span class="line">#define X86_FEATURE_CX16		( 4*32+13) &#x2F;* CMPXCHG16B instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_XTPR		( 4*32+14) &#x2F;* Send Task Priority Messages *&#x2F;</span><br><span class="line">#define X86_FEATURE_PDCM		( 4*32+15) &#x2F;* Perf&#x2F;Debug Capabilities MSR *&#x2F;</span><br><span class="line">#define X86_FEATURE_PCID		( 4*32+17) &#x2F;* Process Context Identifiers *&#x2F;</span><br><span class="line">#define X86_FEATURE_DCA			( 4*32+18) &#x2F;* Direct Cache Access *&#x2F;</span><br><span class="line">#define X86_FEATURE_XMM4_1		( 4*32+19) &#x2F;* &quot;sse4_1&quot; SSE-4.1 *&#x2F;</span><br><span class="line">#define X86_FEATURE_XMM4_2		( 4*32+20) &#x2F;* &quot;sse4_2&quot; SSE-4.2 *&#x2F;</span><br><span class="line">#define X86_FEATURE_X2APIC		( 4*32+21) &#x2F;* X2APIC *&#x2F;</span><br><span class="line">#define X86_FEATURE_MOVBE		( 4*32+22) &#x2F;* MOVBE instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_POPCNT		( 4*32+23) &#x2F;* POPCNT instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_TSC_DEADLINE_TIMER	( 4*32+24) &#x2F;* TSC deadline timer *&#x2F;</span><br><span class="line">#define X86_FEATURE_AES			( 4*32+25) &#x2F;* AES instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_XSAVE		( 4*32+26) &#x2F;* XSAVE&#x2F;XRSTOR&#x2F;XSETBV&#x2F;XGETBV instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_OSXSAVE		( 4*32+27) &#x2F;* &quot;&quot; XSAVE instruction enabled in the OS *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX			( 4*32+28) &#x2F;* Advanced Vector Extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_F16C		( 4*32+29) &#x2F;* 16-bit FP conversions *&#x2F;</span><br><span class="line">#define X86_FEATURE_RDRAND		( 4*32+30) &#x2F;* RDRAND instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_HYPERVISOR		( 4*32+31) &#x2F;* Running on a hypervisor *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* VIA&#x2F;Cyrix&#x2F;Centaur-defined CPU features, CPUID level 0xC0000001, word 5 *&#x2F;</span><br><span class="line">#define X86_FEATURE_XSTORE		( 5*32+ 2) &#x2F;* &quot;rng&quot; RNG present (xstore) *&#x2F;</span><br><span class="line">#define X86_FEATURE_XSTORE_EN		( 5*32+ 3) &#x2F;* &quot;rng_en&quot; RNG enabled *&#x2F;</span><br><span class="line">#define X86_FEATURE_XCRYPT		( 5*32+ 6) &#x2F;* &quot;ace&quot; on-CPU crypto (xcrypt) *&#x2F;</span><br><span class="line">#define X86_FEATURE_XCRYPT_EN		( 5*32+ 7) &#x2F;* &quot;ace_en&quot; on-CPU crypto enabled *&#x2F;</span><br><span class="line">#define X86_FEATURE_ACE2		( 5*32+ 8) &#x2F;* Advanced Cryptography Engine v2 *&#x2F;</span><br><span class="line">#define X86_FEATURE_ACE2_EN		( 5*32+ 9) &#x2F;* ACE v2 enabled *&#x2F;</span><br><span class="line">#define X86_FEATURE_PHE			( 5*32+10) &#x2F;* PadLock Hash Engine *&#x2F;</span><br><span class="line">#define X86_FEATURE_PHE_EN		( 5*32+11) &#x2F;* PHE enabled *&#x2F;</span><br><span class="line">#define X86_FEATURE_PMM			( 5*32+12) &#x2F;* PadLock Montgomery Multiplier *&#x2F;</span><br><span class="line">#define X86_FEATURE_PMM_EN		( 5*32+13) &#x2F;* PMM enabled *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* More extended AMD flags: CPUID level 0x80000001, ECX, word 6 *&#x2F;</span><br><span class="line">#define X86_FEATURE_LAHF_LM		( 6*32+ 0) &#x2F;* LAHF&#x2F;SAHF in long mode *&#x2F;</span><br><span class="line">#define X86_FEATURE_CMP_LEGACY		( 6*32+ 1) &#x2F;* If yes HyperThreading not valid *&#x2F;</span><br><span class="line">#define X86_FEATURE_SVM			( 6*32+ 2) &#x2F;* Secure Virtual Machine *&#x2F;</span><br><span class="line">#define X86_FEATURE_EXTAPIC		( 6*32+ 3) &#x2F;* Extended APIC space *&#x2F;</span><br><span class="line">#define X86_FEATURE_CR8_LEGACY		( 6*32+ 4) &#x2F;* CR8 in 32-bit mode *&#x2F;</span><br><span class="line">#define X86_FEATURE_ABM			( 6*32+ 5) &#x2F;* Advanced bit manipulation *&#x2F;</span><br><span class="line">#define X86_FEATURE_SSE4A		( 6*32+ 6) &#x2F;* SSE-4A *&#x2F;</span><br><span class="line">#define X86_FEATURE_MISALIGNSSE		( 6*32+ 7) &#x2F;* Misaligned SSE mode *&#x2F;</span><br><span class="line">#define X86_FEATURE_3DNOWPREFETCH	( 6*32+ 8) &#x2F;* 3DNow prefetch instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_OSVW		( 6*32+ 9) &#x2F;* OS Visible Workaround *&#x2F;</span><br><span class="line">#define X86_FEATURE_IBS			( 6*32+10) &#x2F;* Instruction Based Sampling *&#x2F;</span><br><span class="line">#define X86_FEATURE_XOP			( 6*32+11) &#x2F;* extended AVX instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_SKINIT		( 6*32+12) &#x2F;* SKINIT&#x2F;STGI instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_WDT			( 6*32+13) &#x2F;* Watchdog timer *&#x2F;</span><br><span class="line">#define X86_FEATURE_LWP			( 6*32+15) &#x2F;* Light Weight Profiling *&#x2F;</span><br><span class="line">#define X86_FEATURE_FMA4		( 6*32+16) &#x2F;* 4 operands MAC instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_TCE			( 6*32+17) &#x2F;* Translation Cache Extension *&#x2F;</span><br><span class="line">#define X86_FEATURE_NODEID_MSR		( 6*32+19) &#x2F;* NodeId MSR *&#x2F;</span><br><span class="line">#define X86_FEATURE_TBM			( 6*32+21) &#x2F;* Trailing Bit Manipulations *&#x2F;</span><br><span class="line">#define X86_FEATURE_TOPOEXT		( 6*32+22) &#x2F;* Topology extensions CPUID leafs *&#x2F;</span><br><span class="line">#define X86_FEATURE_PERFCTR_CORE	( 6*32+23) &#x2F;* Core performance counter extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_PERFCTR_NB		( 6*32+24) &#x2F;* NB performance counter extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_BPEXT		( 6*32+26) &#x2F;* Data breakpoint extension *&#x2F;</span><br><span class="line">#define X86_FEATURE_PTSC		( 6*32+27) &#x2F;* Performance time-stamp counter *&#x2F;</span><br><span class="line">#define X86_FEATURE_PERFCTR_LLC		( 6*32+28) &#x2F;* Last Level Cache performance counter extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_MWAITX		( 6*32+29) &#x2F;* MWAIT extension (MONITORX&#x2F;MWAITX instructions) *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Auxiliary flags: Linux defined - For features scattered in various</span><br><span class="line"> * CPUID levels like 0x6, 0xA etc, word 7.</span><br><span class="line"> *</span><br><span class="line"> * Reuse free bits when adding new feature flags!</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define X86_FEATURE_RING3MWAIT		( 7*32+ 0) &#x2F;* Ring 3 MONITOR&#x2F;MWAIT instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_CPUID_FAULT		( 7*32+ 1) &#x2F;* Intel CPUID faulting *&#x2F;</span><br><span class="line">#define X86_FEATURE_CPB			( 7*32+ 2) &#x2F;* AMD Core Performance Boost *&#x2F;</span><br><span class="line">#define X86_FEATURE_EPB			( 7*32+ 3) &#x2F;* IA32_ENERGY_PERF_BIAS support *&#x2F;</span><br><span class="line">#define X86_FEATURE_CAT_L3		( 7*32+ 4) &#x2F;* Cache Allocation Technology L3 *&#x2F;</span><br><span class="line">#define X86_FEATURE_CAT_L2		( 7*32+ 5) &#x2F;* Cache Allocation Technology L2 *&#x2F;</span><br><span class="line">#define X86_FEATURE_CDP_L3		( 7*32+ 6) &#x2F;* Code and Data Prioritization L3 *&#x2F;</span><br><span class="line">#define X86_FEATURE_INVPCID_SINGLE	( 7*32+ 7) &#x2F;* Effectively INVPCID &amp;&amp; CR4.PCIDE&#x3D;1 *&#x2F;</span><br><span class="line">#define X86_FEATURE_HW_PSTATE		( 7*32+ 8) &#x2F;* AMD HW-PState *&#x2F;</span><br><span class="line">#define X86_FEATURE_PROC_FEEDBACK	( 7*32+ 9) &#x2F;* AMD ProcFeedbackInterface *&#x2F;</span><br><span class="line">#define X86_FEATURE_SME			( 7*32+10) &#x2F;* AMD Secure Memory Encryption *&#x2F;</span><br><span class="line">#define X86_FEATURE_PTI			( 7*32+11) &#x2F;* Kernel Page Table Isolation enabled *&#x2F;</span><br><span class="line">#define X86_FEATURE_RETPOLINE		( 7*32+12) &#x2F;* &quot;&quot; Generic Retpoline mitigation for Spectre variant 2 *&#x2F;</span><br><span class="line">#define X86_FEATURE_RETPOLINE_AMD	( 7*32+13) &#x2F;* &quot;&quot; AMD Retpoline mitigation for Spectre variant 2 *&#x2F;</span><br><span class="line">#define X86_FEATURE_INTEL_PPIN		( 7*32+14) &#x2F;* Intel Processor Inventory Number *&#x2F;</span><br><span class="line">#define X86_FEATURE_CDP_L2		( 7*32+15) &#x2F;* Code and Data Prioritization L2 *&#x2F;</span><br><span class="line">#define X86_FEATURE_MSR_SPEC_CTRL	( 7*32+16) &#x2F;* &quot;&quot; MSR SPEC_CTRL is implemented *&#x2F;</span><br><span class="line">#define X86_FEATURE_SSBD		( 7*32+17) &#x2F;* Speculative Store Bypass Disable *&#x2F;</span><br><span class="line">#define X86_FEATURE_MBA			( 7*32+18) &#x2F;* Memory Bandwidth Allocation *&#x2F;</span><br><span class="line">#define X86_FEATURE_RSB_CTXSW		( 7*32+19) &#x2F;* &quot;&quot; Fill RSB on context switches *&#x2F;</span><br><span class="line">#define X86_FEATURE_SEV			( 7*32+20) &#x2F;* AMD Secure Encrypted Virtualization *&#x2F;</span><br><span class="line">#define X86_FEATURE_USE_IBPB		( 7*32+21) &#x2F;* &quot;&quot; Indirect Branch Prediction Barrier enabled *&#x2F;</span><br><span class="line">#define X86_FEATURE_USE_IBRS_FW		( 7*32+22) &#x2F;* &quot;&quot; Use IBRS during runtime firmware calls *&#x2F;</span><br><span class="line">#define X86_FEATURE_SPEC_STORE_BYPASS_DISABLE	( 7*32+23) &#x2F;* &quot;&quot; Disable Speculative Store Bypass. *&#x2F;</span><br><span class="line">#define X86_FEATURE_LS_CFG_SSBD		( 7*32+24)  &#x2F;* &quot;&quot; AMD SSBD implementation via LS_CFG MSR *&#x2F;</span><br><span class="line">#define X86_FEATURE_IBRS		( 7*32+25) &#x2F;* Indirect Branch Restricted Speculation *&#x2F;</span><br><span class="line">#define X86_FEATURE_IBPB		( 7*32+26) &#x2F;* Indirect Branch Prediction Barrier *&#x2F;</span><br><span class="line">#define X86_FEATURE_STIBP		( 7*32+27) &#x2F;* Single Thread Indirect Branch Predictors *&#x2F;</span><br><span class="line">#define X86_FEATURE_ZEN			( 7*32+28) &#x2F;* &quot;&quot; CPU is AMD family 0x17 or above (Zen) *&#x2F;</span><br><span class="line">#define X86_FEATURE_L1TF_PTEINV		( 7*32+29) &#x2F;* &quot;&quot; L1TF workaround PTE inversion *&#x2F;</span><br><span class="line">#define X86_FEATURE_IBRS_ENHANCED	( 7*32+30) &#x2F;* Enhanced IBRS *&#x2F;</span><br><span class="line">#define X86_FEATURE_MSR_IA32_FEAT_CTL	( 7*32+31) &#x2F;* &quot;&quot; MSR IA32_FEAT_CTL configured *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Virtualization flags: Linux defined, word 8 *&#x2F;</span><br><span class="line">#define X86_FEATURE_TPR_SHADOW		( 8*32+ 0) &#x2F;* Intel TPR Shadow *&#x2F;</span><br><span class="line">#define X86_FEATURE_VNMI		( 8*32+ 1) &#x2F;* Intel Virtual NMI *&#x2F;</span><br><span class="line">#define X86_FEATURE_FLEXPRIORITY	( 8*32+ 2) &#x2F;* Intel FlexPriority *&#x2F;</span><br><span class="line">#define X86_FEATURE_EPT			( 8*32+ 3) &#x2F;* Intel Extended Page Table *&#x2F;</span><br><span class="line">#define X86_FEATURE_VPID		( 8*32+ 4) &#x2F;* Intel Virtual Processor ID *&#x2F;</span><br><span class="line"></span><br><span class="line">#define X86_FEATURE_VMMCALL		( 8*32+15) &#x2F;* Prefer VMMCALL to VMCALL *&#x2F;</span><br><span class="line">#define X86_FEATURE_XENPV		( 8*32+16) &#x2F;* &quot;&quot; Xen paravirtual guest *&#x2F;</span><br><span class="line">#define X86_FEATURE_EPT_AD		( 8*32+17) &#x2F;* Intel Extended Page Table access-dirty bit *&#x2F;</span><br><span class="line">#define X86_FEATURE_VMCALL		( 8*32+18) &#x2F;* &quot;&quot; Hypervisor supports the VMCALL instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_VMW_VMMCALL		( 8*32+19) &#x2F;* &quot;&quot; VMware prefers VMMCALL hypercall instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_SEV_ES		( 8*32+20) &#x2F;* AMD Secure Encrypted Virtualization - Encrypted State *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Intel-defined CPU features, CPUID level 0x00000007:0 (EBX), word 9 *&#x2F;</span><br><span class="line">#define X86_FEATURE_FSGSBASE		( 9*32+ 0) &#x2F;* RDFSBASE, WRFSBASE, RDGSBASE, WRGSBASE instructions*&#x2F;</span><br><span class="line">#define X86_FEATURE_TSC_ADJUST		( 9*32+ 1) &#x2F;* TSC adjustment MSR 0x3B *&#x2F;</span><br><span class="line">#define X86_FEATURE_BMI1		( 9*32+ 3) &#x2F;* 1st group bit manipulation extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_HLE			( 9*32+ 4) &#x2F;* Hardware Lock Elision *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX2		( 9*32+ 5) &#x2F;* AVX2 instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_FDP_EXCPTN_ONLY	( 9*32+ 6) &#x2F;* &quot;&quot; FPU data pointer updated only on x87 exceptions *&#x2F;</span><br><span class="line">#define X86_FEATURE_SMEP		( 9*32+ 7) &#x2F;* Supervisor Mode Execution Protection *&#x2F;</span><br><span class="line">#define X86_FEATURE_BMI2		( 9*32+ 8) &#x2F;* 2nd group bit manipulation extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_ERMS		( 9*32+ 9) &#x2F;* Enhanced REP MOVSB&#x2F;STOSB instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_INVPCID		( 9*32+10) &#x2F;* Invalidate Processor Context ID *&#x2F;</span><br><span class="line">#define X86_FEATURE_RTM			( 9*32+11) &#x2F;* Restricted Transactional Memory *&#x2F;</span><br><span class="line">#define X86_FEATURE_CQM			( 9*32+12) &#x2F;* Cache QoS Monitoring *&#x2F;</span><br><span class="line">#define X86_FEATURE_ZERO_FCS_FDS	( 9*32+13) &#x2F;* &quot;&quot; Zero out FPU CS and FPU DS *&#x2F;</span><br><span class="line">#define X86_FEATURE_MPX			( 9*32+14) &#x2F;* Memory Protection Extension *&#x2F;</span><br><span class="line">#define X86_FEATURE_RDT_A		( 9*32+15) &#x2F;* Resource Director Technology Allocation *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512F		( 9*32+16) &#x2F;* AVX-512 Foundation *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512DQ		( 9*32+17) &#x2F;* AVX-512 DQ (Double&#x2F;Quad granular) Instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_RDSEED		( 9*32+18) &#x2F;* RDSEED instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_ADX			( 9*32+19) &#x2F;* ADCX and ADOX instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_SMAP		( 9*32+20) &#x2F;* Supervisor Mode Access Prevention *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512IFMA		( 9*32+21) &#x2F;* AVX-512 Integer Fused Multiply-Add instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_CLFLUSHOPT		( 9*32+23) &#x2F;* CLFLUSHOPT instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_CLWB		( 9*32+24) &#x2F;* CLWB instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_INTEL_PT		( 9*32+25) &#x2F;* Intel Processor Trace *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512PF		( 9*32+26) &#x2F;* AVX-512 Prefetch *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512ER		( 9*32+27) &#x2F;* AVX-512 Exponential and Reciprocal *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512CD		( 9*32+28) &#x2F;* AVX-512 Conflict Detection *&#x2F;</span><br><span class="line">#define X86_FEATURE_SHA_NI		( 9*32+29) &#x2F;* SHA1&#x2F;SHA256 Instruction Extensions *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512BW		( 9*32+30) &#x2F;* AVX-512 BW (Byte&#x2F;Word granular) Instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512VL		( 9*32+31) &#x2F;* AVX-512 VL (128&#x2F;256 Vector Length) Extensions *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Extended state features, CPUID level 0x0000000d:1 (EAX), word 10 *&#x2F;</span><br><span class="line">#define X86_FEATURE_XSAVEOPT		(10*32+ 0) &#x2F;* XSAVEOPT instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_XSAVEC		(10*32+ 1) &#x2F;* XSAVEC instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_XGETBV1		(10*32+ 2) &#x2F;* XGETBV with ECX &#x3D; 1 instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_XSAVES		(10*32+ 3) &#x2F;* XSAVES&#x2F;XRSTORS instructions *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * Extended auxiliary flags: Linux defined - for features scattered in various</span><br><span class="line"> * CPUID levels like 0xf, etc.</span><br><span class="line"> *</span><br><span class="line"> * Reuse free bits when adding new feature flags!</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define X86_FEATURE_CQM_LLC		(11*32+ 0) &#x2F;* LLC QoS if 1 *&#x2F;</span><br><span class="line">#define X86_FEATURE_CQM_OCCUP_LLC	(11*32+ 1) &#x2F;* LLC occupancy monitoring *&#x2F;</span><br><span class="line">#define X86_FEATURE_CQM_MBM_TOTAL	(11*32+ 2) &#x2F;* LLC Total MBM monitoring *&#x2F;</span><br><span class="line">#define X86_FEATURE_CQM_MBM_LOCAL	(11*32+ 3) &#x2F;* LLC Local MBM monitoring *&#x2F;</span><br><span class="line">#define X86_FEATURE_FENCE_SWAPGS_USER	(11*32+ 4) &#x2F;* &quot;&quot; LFENCE in user entry SWAPGS path *&#x2F;</span><br><span class="line">#define X86_FEATURE_FENCE_SWAPGS_KERNEL	(11*32+ 5) &#x2F;* &quot;&quot; LFENCE in kernel entry SWAPGS path *&#x2F;</span><br><span class="line">#define X86_FEATURE_SPLIT_LOCK_DETECT	(11*32+ 6) &#x2F;* #AC for split lock *&#x2F;</span><br><span class="line">#define X86_FEATURE_PER_THREAD_MBA	(11*32+ 7) &#x2F;* &quot;&quot; Per-thread Memory Bandwidth Allocation *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Intel-defined CPU features, CPUID level 0x00000007:1 (EAX), word 12 *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512_BF16		(12*32+ 5) &#x2F;* AVX512 BFLOAT16 instructions *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* AMD-defined CPU features, CPUID level 0x80000008 (EBX), word 13 *&#x2F;</span><br><span class="line">#define X86_FEATURE_CLZERO		(13*32+ 0) &#x2F;* CLZERO instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_IRPERF		(13*32+ 1) &#x2F;* Instructions Retired Count *&#x2F;</span><br><span class="line">#define X86_FEATURE_XSAVEERPTR		(13*32+ 2) &#x2F;* Always save&#x2F;restore FP error pointers *&#x2F;</span><br><span class="line">#define X86_FEATURE_RDPRU		(13*32+ 4) &#x2F;* Read processor register at user level *&#x2F;</span><br><span class="line">#define X86_FEATURE_WBNOINVD		(13*32+ 9) &#x2F;* WBNOINVD instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_AMD_IBPB		(13*32+12) &#x2F;* &quot;&quot; Indirect Branch Prediction Barrier *&#x2F;</span><br><span class="line">#define X86_FEATURE_AMD_IBRS		(13*32+14) &#x2F;* &quot;&quot; Indirect Branch Restricted Speculation *&#x2F;</span><br><span class="line">#define X86_FEATURE_AMD_STIBP		(13*32+15) &#x2F;* &quot;&quot; Single Thread Indirect Branch Predictors *&#x2F;</span><br><span class="line">#define X86_FEATURE_AMD_STIBP_ALWAYS_ON	(13*32+17) &#x2F;* &quot;&quot; Single Thread Indirect Branch Predictors always-on preferred *&#x2F;</span><br><span class="line">#define X86_FEATURE_AMD_PPIN		(13*32+23) &#x2F;* Protected Processor Inventory Number *&#x2F;</span><br><span class="line">#define X86_FEATURE_AMD_SSBD		(13*32+24) &#x2F;* &quot;&quot; Speculative Store Bypass Disable *&#x2F;</span><br><span class="line">#define X86_FEATURE_VIRT_SSBD		(13*32+25) &#x2F;* Virtualized Speculative Store Bypass Disable *&#x2F;</span><br><span class="line">#define X86_FEATURE_AMD_SSB_NO		(13*32+26) &#x2F;* &quot;&quot; Speculative Store Bypass is fixed in hardware. *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Thermal and Power Management Leaf, CPUID level 0x00000006 (EAX), word 14 *&#x2F;</span><br><span class="line">#define X86_FEATURE_DTHERM		(14*32+ 0) &#x2F;* Digital Thermal Sensor *&#x2F;</span><br><span class="line">#define X86_FEATURE_IDA			(14*32+ 1) &#x2F;* Intel Dynamic Acceleration *&#x2F;</span><br><span class="line">#define X86_FEATURE_ARAT		(14*32+ 2) &#x2F;* Always Running APIC Timer *&#x2F;</span><br><span class="line">#define X86_FEATURE_PLN			(14*32+ 4) &#x2F;* Intel Power Limit Notification *&#x2F;</span><br><span class="line">#define X86_FEATURE_PTS			(14*32+ 6) &#x2F;* Intel Package Thermal Status *&#x2F;</span><br><span class="line">#define X86_FEATURE_HWP			(14*32+ 7) &#x2F;* Intel Hardware P-states *&#x2F;</span><br><span class="line">#define X86_FEATURE_HWP_NOTIFY		(14*32+ 8) &#x2F;* HWP Notification *&#x2F;</span><br><span class="line">#define X86_FEATURE_HWP_ACT_WINDOW	(14*32+ 9) &#x2F;* HWP Activity Window *&#x2F;</span><br><span class="line">#define X86_FEATURE_HWP_EPP		(14*32+10) &#x2F;* HWP Energy Perf. Preference *&#x2F;</span><br><span class="line">#define X86_FEATURE_HWP_PKG_REQ		(14*32+11) &#x2F;* HWP Package Level Request *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* AMD SVM Feature Identification, CPUID level 0x8000000a (EDX), word 15 *&#x2F;</span><br><span class="line">#define X86_FEATURE_NPT			(15*32+ 0) &#x2F;* Nested Page Table support *&#x2F;</span><br><span class="line">#define X86_FEATURE_LBRV		(15*32+ 1) &#x2F;* LBR Virtualization support *&#x2F;</span><br><span class="line">#define X86_FEATURE_SVML		(15*32+ 2) &#x2F;* &quot;svm_lock&quot; SVM locking MSR *&#x2F;</span><br><span class="line">#define X86_FEATURE_NRIPS		(15*32+ 3) &#x2F;* &quot;nrip_save&quot; SVM next_rip save *&#x2F;</span><br><span class="line">#define X86_FEATURE_TSCRATEMSR		(15*32+ 4) &#x2F;* &quot;tsc_scale&quot; TSC scaling support *&#x2F;</span><br><span class="line">#define X86_FEATURE_VMCBCLEAN		(15*32+ 5) &#x2F;* &quot;vmcb_clean&quot; VMCB clean bits support *&#x2F;</span><br><span class="line">#define X86_FEATURE_FLUSHBYASID		(15*32+ 6) &#x2F;* flush-by-ASID support *&#x2F;</span><br><span class="line">#define X86_FEATURE_DECODEASSISTS	(15*32+ 7) &#x2F;* Decode Assists support *&#x2F;</span><br><span class="line">#define X86_FEATURE_PAUSEFILTER		(15*32+10) &#x2F;* filtered pause intercept *&#x2F;</span><br><span class="line">#define X86_FEATURE_PFTHRESHOLD		(15*32+12) &#x2F;* pause filter threshold *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVIC		(15*32+13) &#x2F;* Virtual Interrupt Controller *&#x2F;</span><br><span class="line">#define X86_FEATURE_V_VMSAVE_VMLOAD	(15*32+15) &#x2F;* Virtual VMSAVE VMLOAD *&#x2F;</span><br><span class="line">#define X86_FEATURE_VGIF		(15*32+16) &#x2F;* Virtual GIF *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Intel-defined CPU features, CPUID level 0x00000007:0 (ECX), word 16 *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512VBMI		(16*32+ 1) &#x2F;* AVX512 Vector Bit Manipulation instructions*&#x2F;</span><br><span class="line">#define X86_FEATURE_UMIP		(16*32+ 2) &#x2F;* User Mode Instruction Protection *&#x2F;</span><br><span class="line">#define X86_FEATURE_PKU			(16*32+ 3) &#x2F;* Protection Keys for Userspace *&#x2F;</span><br><span class="line">#define X86_FEATURE_OSPKE		(16*32+ 4) &#x2F;* OS Protection Keys Enable *&#x2F;</span><br><span class="line">#define X86_FEATURE_WAITPKG		(16*32+ 5) &#x2F;* UMONITOR&#x2F;UMWAIT&#x2F;TPAUSE Instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512_VBMI2	(16*32+ 6) &#x2F;* Additional AVX512 Vector Bit Manipulation Instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_GFNI		(16*32+ 8) &#x2F;* Galois Field New Instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_VAES		(16*32+ 9) &#x2F;* Vector AES *&#x2F;</span><br><span class="line">#define X86_FEATURE_VPCLMULQDQ		(16*32+10) &#x2F;* Carry-Less Multiplication Double Quadword *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512_VNNI		(16*32+11) &#x2F;* Vector Neural Network Instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512_BITALG	(16*32+12) &#x2F;* Support for VPOPCNT[B,W] and VPSHUF-BITQMB instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_TME			(16*32+13) &#x2F;* Intel Total Memory Encryption *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512_VPOPCNTDQ	(16*32+14) &#x2F;* POPCNT for vectors of DW&#x2F;QW *&#x2F;</span><br><span class="line">#define X86_FEATURE_LA57		(16*32+16) &#x2F;* 5-level page tables *&#x2F;</span><br><span class="line">#define X86_FEATURE_RDPID		(16*32+22) &#x2F;* RDPID instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_CLDEMOTE		(16*32+25) &#x2F;* CLDEMOTE instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_MOVDIRI		(16*32+27) &#x2F;* MOVDIRI instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_MOVDIR64B		(16*32+28) &#x2F;* MOVDIR64B instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_ENQCMD		(16*32+29) &#x2F;* ENQCMD and ENQCMDS instructions *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* AMD-defined CPU features, CPUID level 0x80000007 (EBX), word 17 *&#x2F;</span><br><span class="line">#define X86_FEATURE_OVERFLOW_RECOV	(17*32+ 0) &#x2F;* MCA overflow recovery support *&#x2F;</span><br><span class="line">#define X86_FEATURE_SUCCOR		(17*32+ 1) &#x2F;* Uncorrectable error containment and recovery *&#x2F;</span><br><span class="line">#define X86_FEATURE_SMCA		(17*32+ 3) &#x2F;* Scalable MCA *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Intel-defined CPU features, CPUID level 0x00000007:0 (EDX), word 18 *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512_4VNNIW	(18*32+ 2) &#x2F;* AVX-512 Neural Network Instructions *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512_4FMAPS	(18*32+ 3) &#x2F;* AVX-512 Multiply Accumulation Single precision *&#x2F;</span><br><span class="line">#define X86_FEATURE_FSRM		(18*32+ 4) &#x2F;* Fast Short Rep Mov *&#x2F;</span><br><span class="line">#define X86_FEATURE_AVX512_VP2INTERSECT (18*32+ 8) &#x2F;* AVX-512 Intersect for D&#x2F;Q *&#x2F;</span><br><span class="line">#define X86_FEATURE_SRBDS_CTRL		(18*32+ 9) &#x2F;* &quot;&quot; SRBDS mitigation MSR available *&#x2F;</span><br><span class="line">#define X86_FEATURE_MD_CLEAR		(18*32+10) &#x2F;* VERW clears CPU buffers *&#x2F;</span><br><span class="line">#define X86_FEATURE_TSX_FORCE_ABORT	(18*32+13) &#x2F;* &quot;&quot; TSX_FORCE_ABORT *&#x2F;</span><br><span class="line">#define X86_FEATURE_SERIALIZE		(18*32+14) &#x2F;* SERIALIZE instruction *&#x2F;</span><br><span class="line">#define X86_FEATURE_TSXLDTRK		(18*32+16) &#x2F;* TSX Suspend Load Address Tracking *&#x2F;</span><br><span class="line">#define X86_FEATURE_PCONFIG		(18*32+18) &#x2F;* Intel PCONFIG *&#x2F;</span><br><span class="line">#define X86_FEATURE_ARCH_LBR		(18*32+19) &#x2F;* Intel ARCH LBR *&#x2F;</span><br><span class="line">#define X86_FEATURE_SPEC_CTRL		(18*32+26) &#x2F;* &quot;&quot; Speculation Control (IBRS + IBPB) *&#x2F;</span><br><span class="line">#define X86_FEATURE_INTEL_STIBP		(18*32+27) &#x2F;* &quot;&quot; Single Thread Indirect Branch Predictors *&#x2F;</span><br><span class="line">#define X86_FEATURE_FLUSH_L1D		(18*32+28) &#x2F;* Flush L1D cache *&#x2F;</span><br><span class="line">#define X86_FEATURE_ARCH_CAPABILITIES	(18*32+29) &#x2F;* IA32_ARCH_CAPABILITIES MSR (Intel) *&#x2F;</span><br><span class="line">#define X86_FEATURE_CORE_CAPABILITIES	(18*32+30) &#x2F;* &quot;&quot; IA32_CORE_CAPABILITIES MSR *&#x2F;</span><br><span class="line">#define X86_FEATURE_SPEC_CTRL_SSBD	(18*32+31) &#x2F;* &quot;&quot; Speculative Store Bypass Disable *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * BUG word(s)</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define X86_BUG(x)			(NCAPINTS*32 + (x))</span><br><span class="line"></span><br><span class="line">#define X86_BUG_F00F			X86_BUG(0) &#x2F;* Intel F00F *&#x2F;</span><br><span class="line">#define X86_BUG_FDIV			X86_BUG(1) &#x2F;* FPU FDIV *&#x2F;</span><br><span class="line">#define X86_BUG_COMA			X86_BUG(2) &#x2F;* Cyrix 6x86 coma *&#x2F;</span><br><span class="line">#define X86_BUG_AMD_TLB_MMATCH		X86_BUG(3) &#x2F;* &quot;tlb_mmatch&quot; AMD Erratum 383 *&#x2F;</span><br><span class="line">#define X86_BUG_AMD_APIC_C1E		X86_BUG(4) &#x2F;* &quot;apic_c1e&quot; AMD Erratum 400 *&#x2F;</span><br><span class="line">#define X86_BUG_11AP			X86_BUG(5) &#x2F;* Bad local APIC aka 11AP *&#x2F;</span><br><span class="line">#define X86_BUG_FXSAVE_LEAK		X86_BUG(6) &#x2F;* FXSAVE leaks FOP&#x2F;FIP&#x2F;FOP *&#x2F;</span><br><span class="line">#define X86_BUG_CLFLUSH_MONITOR		X86_BUG(7) &#x2F;* AAI65, CLFLUSH required before MONITOR *&#x2F;</span><br><span class="line">#define X86_BUG_SYSRET_SS_ATTRS		X86_BUG(8) &#x2F;* SYSRET doesn&#39;t fix up SS attrs *&#x2F;</span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 64-bit kernels don&#39;t use X86_BUG_ESPFIX.  Make the define conditional</span><br><span class="line"> * to avoid confusion.</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define X86_BUG_ESPFIX			X86_BUG(9) &#x2F;* &quot;&quot; IRET to 16-bit SS corrupts ESP&#x2F;RSP high bits *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">#define X86_BUG_NULL_SEG		X86_BUG(10) &#x2F;* Nulling a selector preserves the base *&#x2F;</span><br><span class="line">#define X86_BUG_SWAPGS_FENCE		X86_BUG(11) &#x2F;* SWAPGS without input dep on GS *&#x2F;</span><br><span class="line">#define X86_BUG_MONITOR			X86_BUG(12) &#x2F;* IPI required to wake up remote CPU *&#x2F;</span><br><span class="line">#define X86_BUG_AMD_E400		X86_BUG(13) &#x2F;* CPU is among the affected by Erratum 400 *&#x2F;</span><br><span class="line">#define X86_BUG_CPU_MELTDOWN		X86_BUG(14) &#x2F;* CPU is affected by meltdown attack and needs kernel page table isolation *&#x2F;</span><br><span class="line">#define X86_BUG_SPECTRE_V1		X86_BUG(15) &#x2F;* CPU is affected by Spectre variant 1 attack with conditional branches *&#x2F;</span><br><span class="line">#define X86_BUG_SPECTRE_V2		X86_BUG(16) &#x2F;* CPU is affected by Spectre variant 2 attack with indirect branches *&#x2F;</span><br><span class="line">#define X86_BUG_SPEC_STORE_BYPASS	X86_BUG(17) &#x2F;* CPU is affected by speculative store bypass attack *&#x2F;</span><br><span class="line">#define X86_BUG_L1TF			X86_BUG(18) &#x2F;* CPU is affected by L1 Terminal Fault *&#x2F;</span><br><span class="line">#define X86_BUG_MDS			X86_BUG(19) &#x2F;* CPU is affected by Microarchitectural data sampling *&#x2F;</span><br><span class="line">#define X86_BUG_MSBDS_ONLY		X86_BUG(20) &#x2F;* CPU is only affected by the  MSDBS variant of BUG_MDS *&#x2F;</span><br><span class="line">#define X86_BUG_SWAPGS			X86_BUG(21) &#x2F;* CPU is affected by speculation through SWAPGS *&#x2F;</span><br><span class="line">#define X86_BUG_TAA			X86_BUG(22) &#x2F;* CPU is affected by TSX Async Abort(TAA) *&#x2F;</span><br><span class="line">#define X86_BUG_ITLB_MULTIHIT		X86_BUG(23) &#x2F;* CPU may incur MCE during certain page attribute changes *&#x2F;</span><br><span class="line">#define X86_BUG_SRBDS			X86_BUG(24) &#x2F;* CPU may leak RNG bits if not mitigated *&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>kernel</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>make-输出过程信息</title>
    <url>/2021/07/28/make-%E8%BE%93%E5%87%BA%E8%BF%87%E7%A8%8B%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make SHELL&#x3D;&#39;sh -x&#39; # 通用的</span><br><span class="line"></span><br><span class="line">make VERBOSE&#x3D;1 # 少数情况下有用</span><br><span class="line"></span><br><span class="line">make CC&#x3D;clang -j4 SHELL&#x3D;&#39;sh -x&#39; 2&gt;compile.log</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>compiler</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>内核符号kallsyms和只读测试</title>
    <url>/2021/08/06/%E5%86%85%E6%A0%B8%E7%AC%A6%E5%8F%B7kallsyms%E5%92%8C%E5%8F%AA%E8%AF%BB%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="sudo-cat-proc-kallsyms"><a href="#sudo-cat-proc-kallsyms" class="headerlink" title="sudo cat /proc/kallsyms"></a>sudo cat /proc/kallsyms</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffffffff81140450 T put_old_timex32</span><br><span class="line">ffffffff81140560 t __do_sys_adjtimex_time32</span><br><span class="line">ffffffff811405e0 T __x64_sys_adjtimex_time32</span><br><span class="line">...</span><br><span class="line">ffffffff82e59660 D acpi_rs_convert_gpio</span><br><span class="line">...</span><br><span class="line">ffffffff826c0360 D kmalloc_caches</span><br><span class="line">ffffffff826f8f5c r __ksymtab_kmalloc_caches</span><br><span class="line">ffffffff827266f0 r __kstrtabns_kmalloc_caches</span><br><span class="line">ffffffff82728043 r __kstrtab_kmalloc_caches</span><br></pre></td></tr></table></figure>

<h1 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h1><ul>
<li>T 全局代码符号</li>
<li>t local代码符号</li>
<li>D 全局数据符号</li>
<li>d 本地数据符号</li>
<li>B/b 全局和本地bss符号（未初始化data区）</li>
<li>R/r 只读数据符号（和D/d重合）</li>
</ul>
<h1 id="kernel-EXPORT-SYMBOL-介绍"><a href="#kernel-EXPORT-SYMBOL-介绍" class="headerlink" title="kernel EXPORT_SYMBOL() 介绍"></a>kernel EXPORT_SYMBOL() 介绍</h1><p>需要通过export_symbol 导出给用户使用</p>
<ul>
<li><code>__kstrtab_&lt;symbol_name&gt;</code> - name of the symbol as a string</li>
<li><code>__ksymtab_&lt;symbol_name&gt;</code> - a structure with the information about the symbol: its address, address of <code>__kstrtab_&lt;symbol_name&gt;</code>, etc.</li>
<li><code>__kcrctab_&lt;symbol_name&gt;</code> - address of the control sum (CRC) of the symbol</li>
</ul>
<h1 id="小实验-ext4-file-operations-只读保护？"><a href="#小实验-ext4-file-operations-只读保护？" class="headerlink" title="小实验 ext4_file_operations 只读保护？"></a>小实验 ext4_file_operations 只读保护？</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fops read only</span><br><span class="line"></span><br><span class="line">unsigned long *ext4_fops &#x3D; (unsigned long*)0xffffffff8224cb40;</span><br><span class="line">pr_info(&quot;%016lx\n&quot;, *ext4_fops);</span><br><span class="line">*ext4_fops &#x3D; 0xdeadbeef0123abcd;</span><br><span class="line">pr_info(&quot;%016lx\n&quot;, *ext4_fops);&#x2F;&#x2F; trigger page fault</span><br></pre></td></tr></table></figure>

<p>触发了page fault，显然这些页是只读的。</p>
]]></content>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>arm memory tagging extension</title>
    <url>/2021/08/09/arm-MTE/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/353807709">MTE技术在Android上的应用</a><br><a href="https://www.kernel.org/doc/html/latest/arm64/tagged-address-abi.html">kernel - AArch64 TAGGED ADDRESS ABI</a><br><a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety">Armv8.5-A Memory Tagging Extension white paper</a>  </p>
<a id="more"></a>

<p><img src="/2021/08/09/arm-MTE/arm-mte.png" alt="arm-mte"></p>
<p>之前我只把这玩意当做kasan的硬件实现，其实不对，因为他提供了一个lock + key的匹配</p>
<p>比如给一个地址分配可读写权限，这意味着</p>
<ol>
<li>相应的地址，<code>addr = 0x-fff800000000000</code>,的开头四位(“-“)记录了key</li>
<li>对应的shadow memory  <code>tagaddr =（addr &gt;&gt; 4）+ offset</code> 标记了lock（未来可能就不需要了，直接MTE提供shadow）</li>
</ol>
<p>lock和key必须匹配才能读写，否则触发异常，这个异常可以配置成同步的，也可以是异步的。</p>
<p>忽略开头的四位地址的技术在arm中叫 TBI（top byte ignoring）</p>
<p>相应的技术有kasan  asan hwasan这类的sanitizer，以及android tagged pointers等</p>
<p>类似的还可以参考loki（用fpga模拟的mte/tbi），如果你想做论文的话，需要优化loki这类工作，或者绕开这类工作。</p>
<p>此外内核已经提供了MTE接口，可以研究一下。</p>
]]></content>
      <tags>
        <tag>arm</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
</search>
