{"meta":{"title":"purplewall1206 blog","subtitle":"","description":"something about kernel & programming","author":"purplewall1206","url":"https://www.zi-c.wang","root":"/"},"pages":[{"title":"","date":"2020-11-15T10:43:54.047Z","updated":"2020-11-15T10:43:54.047Z","comments":true,"path":"404.html","permalink":"https://www.zi-c.wang/404.html","excerpt":"","text":"+layout: false +--- 404"},{"title":"about","date":"2020-11-15T10:38:51.000Z","updated":"2020-11-15T10:38:51.790Z","comments":true,"path":"about/index.html","permalink":"https://www.zi-c.wang/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-11-15T10:40:07.000Z","updated":"2020-11-15T10:43:51.827Z","comments":false,"path":"categories/index.html","permalink":"https://www.zi-c.wang/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-15T10:39:13.000Z","updated":"2020-11-15T10:43:56.047Z","comments":false,"path":"tags/index.html","permalink":"https://www.zi-c.wang/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"kernel compile: obj-m or obj-y","slug":"kernel-compile-obj-m-or-obj-y","date":"2021-03-01T08:14:14.000Z","updated":"2021-03-01T08:14:48.766Z","comments":true,"path":"2021/03/01/kernel-compile-obj-m-or-obj-y/","link":"","permalink":"https://www.zi-c.wang/2021/03/01/kernel-compile-obj-m-or-obj-y/","excerpt":"","text":"obj-m/obj-y使用obj-m可以将文件编译成单独的.ko文件 使用obj-y可以将文件编译到内核的zImage中 使用obj-n表示不编译 内核中常见的还有 obj-$(SYM) 这种类型的，一般$(SYM)可以取值为y，m","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"compile","slug":"compile","permalink":"https://www.zi-c.wang/tags/compile/"}]},{"title":"为什么LKM无法直接调用swapper_pg_dir--内核中的static变量和函数","slug":"为什么LKM无法直接调用swapper-pg-dir-内核中的static变量和函数","date":"2021-03-01T08:09:53.000Z","updated":"2021-03-02T02:04:00.484Z","comments":true,"path":"2021/03/01/为什么LKM无法直接调用swapper-pg-dir-内核中的static变量和函数/","link":"","permalink":"https://www.zi-c.wang/2021/03/01/%E4%B8%BA%E4%BB%80%E4%B9%88LKM%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8swapper-pg-dir-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84static%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/","excerpt":"kernel static functions 内核静态函数在编写drivers想要调用一些敏感的内核函数时，往往会出现xxx undefined这种情况，并不能通过加入头文件的方式解决。 深入了解一下，以__p4d_alloc为例： 在include/linux/mm.h中声明static inline int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address) 为静态内联函数 那么为什么在driver中无法调用静态函数呢？这回归到了C语言的一个基础问题，static到底是做什么的？","text":"kernel static functions 内核静态函数在编写drivers想要调用一些敏感的内核函数时，往往会出现xxx undefined这种情况，并不能通过加入头文件的方式解决。 深入了解一下，以__p4d_alloc为例： 在include/linux/mm.h中声明static inline int __p4d_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address) 为静态内联函数 那么为什么在driver中无法调用静态函数呢？这回归到了C语言的一个基础问题，static到底是做什么的？ static 可见性不同，全局变量，所有未加static的全局变量和全局函数都有全局可见性，如在文件1中定义的函数和变量可以在文件2中调用，但是加上了static在文件2中则不可见。 12345678910111213char a &#x3D; &#39;A&#39;; &#x2F;&#x2F; global variablevoid msg()&#123; printf(&quot;Hello\\n&quot;);&#125;--------------另一个文件-----------int main(void)&#123; extern char a; &#x2F;&#x2F; extern variable must be declared before use printf(&quot;%c &quot;, a); (void)msg(); return 0;&#125; 生命周期是整个程序，在程序启动时初始化，全局变量和static变量（全局和局部）都存储在静态存储区，主要区别在于可见性不同。 默认初始化为0,因为静态区默认初始化为0. 因此我们能够明白为什么在LKM中我们无法直接调用__p4d_alloc 和 swapper_pg_dir 这些符号，因为都是被static限定了适用范围。 头文件中的static inline声明头文件中最好不要使用static声明函数，因为： 头文件中的 static 函数会在每个文件中生成一份代码，这造成代码冗余倒不是最大的问题，最大的问题是可能带来库文件与工程文件同一函数的代码的不一致性，这有风险。 但是有例外情况 比如内核中大量static inline int pud_present(pud_t pud)这类函数，定义为static inline 因为c语言中的inline 关键字只是建议内联，通常编译器不执行，但是如果使用 static inline 则会保证一定内联。 如何使用目前看来唯一可行的办法是通过地址引用struct mmstruct *INIT_MM = 0xaddress。 另外记录两次失败案例： 将static 函数使用 EXPORT_SYMBOL()导出，结果是无法载入内核中 将函数改为非static，则无法通过编译。 这里编译浪费了好多时间，不要轻易尝试。 如果只想通过编译，可以使用obj-y，显然无法生成.ko","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"c","slug":"c","permalink":"https://www.zi-c.wang/tags/c/"},{"name":"programming","slug":"programming","permalink":"https://www.zi-c.wang/tags/programming/"}]},{"title":"内核栈与vmap kernel stack","slug":"内核栈与vmap-kernel-stack","date":"2021-01-15T08:37:32.000Z","updated":"2021-01-15T08:40:29.298Z","comments":true,"path":"2021/01/15/内核栈与vmap-kernel-stack/","link":"","permalink":"https://www.zi-c.wang/2021/01/15/%E5%86%85%E6%A0%B8%E6%A0%88%E4%B8%8Evmap-kernel-stack/","excerpt":"参考Virtually mapped kernel stacksVirtually mapped stacks with guard pages (x86, core) kernel stack在64位系统上通常是8k或16k连续映射，但是很容易造成溢出，而且在内存被大量占用的情况下不太容易找到连续的2页或4页。 因此有开发者提出了解决办法，使用vmap解决这两个问题,使得内核栈在溢出时print一个错误信息。","text":"参考Virtually mapped kernel stacksVirtually mapped stacks with guard pages (x86, core) kernel stack在64位系统上通常是8k或16k连续映射，但是很容易造成溢出，而且在内存被大量占用的情况下不太容易找到连续的2页或4页。 因此有开发者提出了解决办法，使用vmap解决这两个问题,使得内核栈在溢出时print一个错误信息。 Virtually mapped stacks作者 Andy Lutomirski 使用vmalloc分配内核栈，然而这面临着内存分配速度1.5us，比较慢的问题。 作者本来打算不管这套，并且想让vmalloc速度快点，但是linus建议为per_cpu分配几个cache，实际实现的过程中是为每个CPU分配了2个cache 12#define NR_CACHED_STACKS 2static DEFINE_PER_CPU(struct vm_struct *, cached_stacks[NR_CACHED_STACKS]); 如果其中一个能用就分配给申请的task，如果两个都不行就再申请个新的 1234567891011121314151617181920212223242526272829for (i &#x3D; 0; i &lt; NR_CACHED_STACKS; i++) &#123; struct vm_struct *s; s &#x3D; this_cpu_xchg(cached_stacks[i], NULL); if (!s) continue; &#x2F;* Clear the KASAN shadow of the stack. *&#x2F; kasan_unpoison_shadow(s-&gt;addr, THREAD_SIZE); &#x2F;* Clear stale pointers from reused stack. *&#x2F; memset(s-&gt;addr, 0, THREAD_SIZE); tsk-&gt;stack_vm_area &#x3D; s; tsk-&gt;stack &#x3D; s-&gt;addr; return s-&gt;addr; &#125; &#x2F;* * Allocated stacks are cached and later reused by new threads, * so memcg accounting is performed manually on assigning&#x2F;releasing * stacks to tasks. Drop __GFP_ACCOUNT. *&#x2F; stack &#x3D; __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN, VMALLOC_START, VMALLOC_END, THREADINFO_GFP &amp; ~__GFP_ACCOUNT, PAGE_KERNEL, 0, node, __builtin_return_address(0)); kconfig CONFIG_HAVE_ARCH_VMAP_STACK=y CONFIG_VMAP_STACK=y 原本的内核栈直接申请物理页，赋予的地址在直接映射区 12345678struct page *page &#x3D; alloc_pages_node(node, THREADINFO_GFP, THREAD_SIZE_ORDER);if (likely(page)) &#123; tsk-&gt;stack &#x3D; page_address(page); return tsk-&gt;stack;&#125;return NULL;","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"stack","slug":"stack","permalink":"https://www.zi-c.wang/tags/stack/"}]},{"title":"装机","slug":"装机","date":"2020-12-27T01:43:23.000Z","updated":"2020-12-27T02:20:32.427Z","comments":true,"path":"2020/12/27/装机/","link":"","permalink":"https://www.zi-c.wang/2020/12/27/%E8%A3%85%E6%9C%BA/","excerpt":"装机-硬件设备厂家选择20201226 装机主要分成八个部分：CPU，主板，内存，显卡，硬盘，电源，散热，机箱 这篇文章主要是分析八种硬件有哪些型号，性能对比，以及厂商的质量和价格，最终目的是设计一套合理的装机配置。","text":"装机-硬件设备厂家选择20201226 装机主要分成八个部分：CPU，主板，内存，显卡，硬盘，电源，散热，机箱 这篇文章主要是分析八种硬件有哪些型号，性能对比，以及厂商的质量和价格，最终目的是设计一套合理的装机配置。 CPU显然可选的只有x86架构的intel和AMD。 在intel中可选的有自带核心显卡和不带的，其中低端的型号包括intel奔腾G5400，intel酷睿i3，AMD锐龙3 之后中高端分别有intel i5、i7、i9， AMD 锐龙5、7、线程撕裂者 现在最新的intel core CPU已经到第十代了（i7 10700），8核心16线程，16MB缓存，支持内存DDR4-2933，分为四类（f表示没有核心显卡，k表示频率更高） 型号主频功率散片价格+微星B460主板价格 10700f2.9-4.8GHz65w19992729 107002.9-4.8GHz65w2249 10700kf3.8-5.1GHz125w2199 107003.8-5.1GHz125w2649 支持的主板类型为华硕B460M-K，CPU插槽B460芯片组，LGA1200针 显卡RTX3070 显卡价格从3899-5000多，越贵PCB和散热可能更好，主要是RGB光污染税，其中OC表示over clock超频，注意看下功耗。 由于核心芯片是一致的，所以选择丐版就可以3899（有两个风扇和三个风扇的），主要可选的有 图片从互联网下载，随时删除 主板关键在于主板芯片和CPU匹配。 主要品牌有华硕、微星、技嘉（t1），华擎、映泰、七彩虹、铭瑄、昂达、影驰（t2）。 支持10代intel CPU的接口类型是LGA1200，具体的型号从H410-Z490都是。 芯片组的级别：intel X &gt; Z &gt; B &gt; H（AMD的TR&gt;X&gt;B&gt;A） B系列比较常见，不能超频，最多支持i7，十代酷睿支持的芯片组有H410，B460，Z490，其中B460比较常见。 买的时候注意看看主板上面有多少个接口，内存，PCIe，USB，网卡，M.2硬盘等等。 供电也要进行注意，分为供电项数，通常和芯片组绑定。 最后还要注意主板的形状，因为需要搭配机箱。主流的有ATX和m-ATX（小），微星B460M价格在500-600 内存内存的频率表示最高稳定工作的频率，因此需要看看CPU和主板支持的最大运行频率，内存工作时收到自身频率的限制 想要买的i7 10700 支持内存频率是2933，因此2900-3200MHz都可以。 内存标配终身质保，如果不是的话不要买。内存DIE 频率最高的是DDR4 芝奇、海盗船，中段高端可以买，低端不要 金士顿贵一点，但是质保和质量好，威刚也可以，价格更亲民。 芝奇：8G马甲条239，16G马甲条439，幻光戟8G 249，16GB 569，工作频率3000MHz左右，要看一下主板支持不支持 金士顿：3200MHz，8GB 249，16GB 469。 2666MHz的便宜10-30块钱，有RBG污染的贵100. 海盗船：3200Mhz，8GB 274 固态硬盘接口分为SATA、M.2和PCIe三种， M.2接口相当于PCIe*4总线，要注意看是否支持NVMe协议，支持的速度更快。 三星，东芝，浦科特，intel，惠普， 三星M.2：256GB 389，512GB 549-649（读写速度有区别），1TB 1099-1369 三星SATA（速度大概是1/6）：1T 739 东芝M.2：500GB 655，1TB 1000 东芝SATA：480GB 369 金士顿M.2：500GB 439，1TB 749（速度比三星慢） 金士顿SATA：480GB 369， 机械硬盘西部数据，1TB 7200转SATA 279，加上1TB西部数据M.2一共卖1000出头。 电源模组：非、半、全模组，区别是线材是否固定，全模组所有线材可以拆卸。 ATX电源用的最多，通常用这个。高配电脑1元1w好选择。 电源功率计算 CPU功率+GPU功率+100W余量。 650w性价比款：台达459、鑫谷419、先马479 高品质：酷冷至尊469、振华、海韵 散热器风冷主要看热管的数量，回流焊工艺更好，穿片 超频红海，九州风神，大镰刀赤兔马，利民 8核建议6根热管，8根热管的，九州风神，追风者，利民，猫头鹰 200-600 200-500 机箱主要考虑主板支持，显卡限长，散热器限高，电源支持。250-500 总结2700（CPU+主板）+4000（GPU）+500（16gb内存）+1000（1TB固态）+450（650w电源）+300（散热器）+300（机箱） 合计9250","categories":[],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://www.zi-c.wang/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"装机","slug":"装机","permalink":"https://www.zi-c.wang/tags/%E8%A3%85%E6%9C%BA/"}]},{"title":"access_ok 重要的函数指针传递分析","slug":"access-ok-重要的函数指针传递分析","date":"2020-12-15T01:45:55.000Z","updated":"2020-12-15T01:47:24.600Z","comments":true,"path":"2020/12/15/access-ok-重要的函数指针传递分析/","link":"","permalink":"https://www.zi-c.wang/2020/12/15/access-ok-%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E5%88%86%E6%9E%90/","excerpt":"/arch/x86/include/asm/uaccess.h 用于检查user space 的指针，是否超过用户地址空间的界限，读取或写入内核地址。 Checks if a pointer to a block of memory in user space is valid. Note that, depending on architecture, this function probably just checks that the pointer is in the user space range","text":"/arch/x86/include/asm/uaccess.h 用于检查user space 的指针，是否超过用户地址空间的界限，读取或写入内核地址。 Checks if a pointer to a block of memory in user space is valid. Note that, depending on architecture, this function probably just checks that the pointer is in the user space range 123456789101112131415161718192021222324252627282930313233343536373839#define access_ok(addr, size) \\(&#123; \\ WARN_ON_IN_IRQ(); \\ likely(!__range_not_ok(addr, size, user_addr_max())); \\&#125;)#define __range_not_ok(addr, size, limit) \\(&#123; \\ __chk_user_ptr(addr); \\ __chk_range_not_ok((unsigned long __force)(addr), size, limit); \\&#125;)#define user_addr_max() (current-&gt;thread.addr_limit.seg)# define __chk_user_ptr(x) (void)0&#x2F;* * Test whether a block of memory is a valid user space address. * Returns 0 if the range is valid, nonzero otherwise. *&#x2F;static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, unsigned long limit)&#123; &#x2F;* * If we have used &quot;sizeof()&quot; for the size, * we know it won&#39;t overflow the limit (but * it might overflow the &#39;addr&#39;, so it&#39;s * important to subtract the size from the * limit, not add it to the address). *&#x2F; if (__builtin_constant_p(size)) return unlikely(addr &gt; limit - size); &#x2F;* Arbitrary sizes? Be careful about overflow *&#x2F; addr +&#x3D; size; if (unlikely(addr &lt; size)) return true; return unlikely(addr &gt; limit);&#125; 注意这里有一个__chk_user_ptr，编译器不会生成任何代码","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"}]},{"title":"typedef code pointer 代码指针","slug":"typedef-code-pointer-代码指针","date":"2020-12-12T08:55:39.000Z","updated":"2020-12-12T08:56:46.222Z","comments":true,"path":"2020/12/12/typedef-code-pointer-代码指针/","link":"","permalink":"https://www.zi-c.wang/2020/12/12/typedef-code-pointer-%E4%BB%A3%E7%A0%81%E6%8C%87%E9%92%88/","excerpt":"typedef 是把一个名字和一个类型联系起来。 1234567typedef int myinteger;typedef char *mystring;typedef void (*myfunc)();myinteger i; &#x2F;&#x2F; is equivalent to int i;mystring s; &#x2F;&#x2F; is the same as char *s;myfunc f; &#x2F;&#x2F; compile equally as void (*f)();","text":"typedef 是把一个名字和一个类型联系起来。 1234567typedef int myinteger;typedef char *mystring;typedef void (*myfunc)();myinteger i; &#x2F;&#x2F; is equivalent to int i;mystring s; &#x2F;&#x2F; is the same as char *s;myfunc f; &#x2F;&#x2F; compile equally as void (*f)(); 注意第三个给函数做typedef，目的是简化代码阅读的难度，尤其是指针指向函数和structure。 123456789typedef int (*t_somefunc)(int,int);int product(int u, int v) &#123; return u*v;&#125;t_somefunc afunc &#x3D; &amp;product;...int x2 &#x3D; (*afunc)(123, 456); &#x2F;&#x2F; call product() to calculate 123*456 在汇编中这是典型的间接跳转 call %rax 1234567891011│B+ 0x555555555154 &lt;main+8&gt; lea -0x22(%rip),%rax #0x555555555139 &lt;product&gt; ││ 0x55555555515b &lt;main+15&gt; mov %rax,-0x8(%rbp) ││ &gt;0x55555555515f &lt;main+19&gt; mov -0x8(%rbp),%rax │ │ 0x555555555163 &lt;main+23&gt; mov $0x14,%esi ││ 0x555555555168 &lt;main+28&gt; mov $0xf,%edi ││ 0x55555555516d &lt;main+33&gt; call *%rax","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"c","slug":"c","permalink":"https://www.zi-c.wang/tags/c/"}]},{"title":"kernel memory layout","slug":"kernel-memory-layout","date":"2020-12-11T13:20:41.000Z","updated":"2020-12-11T13:22:03.478Z","comments":true,"path":"2020/12/11/kernel-memory-layout/","link":"","permalink":"https://www.zi-c.wang/2020/12/11/kernel-memory-layout/","excerpt":"latest mm documentationlatest boot documentatinox86: fix return from kernel to userspace with 16-bit stack /Documentation/x86/x86_64/mm.txt /Documentation/x86/boot.txt","text":"latest mm documentationlatest boot documentatinox86: fix return from kernel to userspace with 16-bit stack /Documentation/x86/x86_64/mm.txt /Documentation/x86/boot.txt 随着芯片技术升级现在已经出现5级页表了，但是估计还是服务器上面居多，这里重点记录一下4级页表的布局 4页使用48位的虚拟地址， 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Start addr | Offset | End addr | Size | VM area description&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; | | | | 0000000000000000 | 0 | 00007fffffffffff | 128 TB | user-space virtual memory, different per mm__________________|____________|__________________|_________|___________________________________________________________ | | | | 0000800000000000 | +128 TB | ffff7fffffffffff | ~16M TB | ... huge, almost 64 bits wide hole of non-canonical | | | | virtual memory addresses up to the -128 TB | | | | starting offset of kernel mappings.__________________|____________|__________________|_________|___________________________________________________________ | | Kernel-space virtual memory, shared between all processes:____________________________________________________________|___________________________________________________________ | | | | ffff800000000000 | -128 TB | ffff87ffffffffff | 8 TB | ... guard hole, also reserved for hypervisor ffff880000000000 | -120 TB | ffff887fffffffff | 0.5 TB | LDT remap for PTI ffff888000000000 | -119.5 TB | ffffc87fffffffff | 64 TB | direct mapping of all physical memory (page_offset_base) ffffc88000000000 | -55.5 TB | ffffc8ffffffffff | 0.5 TB | ... unused hole ffffc90000000000 | -55 TB | ffffe8ffffffffff | 32 TB | vmalloc&#x2F;ioremap space (vmalloc_base) ffffe90000000000 | -23 TB | ffffe9ffffffffff | 1 TB | ... unused hole ffffea0000000000 | -22 TB | ffffeaffffffffff | 1 TB | virtual memory map (vmemmap_base) ffffeb0000000000 | -21 TB | ffffebffffffffff | 1 TB | ... unused hole ffffec0000000000 | -20 TB | fffffbffffffffff | 16 TB | KASAN shadow memory__________________|____________|__________________|_________|____________________________________________________________ | | Identical layout to the 56-bit one from here on:____________________________________________________________|____________________________________________________________ | | | | fffffc0000000000 | -4 TB | fffffdffffffffff | 2 TB | ... unused hole | | | | vaddr_end for KASLR fffffe0000000000 | -2 TB | fffffe7fffffffff | 0.5 TB | cpu_entry_area mapping fffffe8000000000 | -1.5 TB | fffffeffffffffff | 0.5 TB | ... unused hole ffffff0000000000 | -1 TB | ffffff7fffffffff | 0.5 TB | %esp fixup stacks ffffff8000000000 | -512 GB | ffffffeeffffffff | 444 GB | ... unused hole ffffffef00000000 | -68 GB | fffffffeffffffff | 64 GB | EFI region mapping space ffffffff00000000 | -4 GB | ffffffff7fffffff | 2 GB | ... unused hole ffffffff80000000 | -2 GB | ffffffff9fffffff | 512 MB | kernel text mapping, mapped to physical address 0 ffffffff80000000 |-2048 MB | | | ffffffffa0000000 |-1536 MB | fffffffffeffffff | 1520 MB | module mapping space ffffffffff000000 | -16 MB | | | FIXADDR_START | ~-11 MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset ffffffffff600000 | -10 MB | ffffffffff600fff | 4 kB | legacy vsyscall ABI ffffffffffe00000 | -2 MB | ffffffffffffffff | 2 MB | ... unused hole__________________|____________|__________________|_________|___________________________________________________________ Negative addresses such as “-23 TB” are absolute addresses in bytes, counted down from the top of the 64-bit address space. It’s easier to understand the layout when seen both in absolute addresses and in distance-from-top notation.For example 0xffffe90000000000 == -23 TB, it’s 23 TB lower than the top of the 64-bit address space (ffffffffffffffff). 现代的操作系统 bzImage kernel使用boot 协定 version &gt;= 2.02 的内存布局 123456789101112131415161718192021222324 ~ ~ | Protected-mode kernel | 100000 +------------------------+ | I&#x2F;O memory hole | 0A0000 +------------------------+ | Reserved for BIOS | Leave as much as possible unused ~ ~ | Command line | (Can also be below the X+10000 mark) X+10000 +------------------------+ | Stack&#x2F;heap | For use by the kernel real-mode code. X+08000 +------------------------+ | Kernel setup | The kernel real-mode code. | Kernel boot sector | The kernel legacy boot sector. X +------------------------+ | Boot loader | &lt;- Boot sector entry point 0000:7C00 001000 +------------------------+ | Reserved for MBR&#x2F;BIOS | 000800 +------------------------+ | Typically used by MBR | 000600 +------------------------+ | BIOS use only | 000000 +------------------------+... where the address X is as low as the design of the boot loader permits. 解决一下 %esp fixup stacks","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"}]},{"title":"Linux User-mode Driver","slug":"Linux-User-mode-Driver","date":"2020-11-28T07:18:10.000Z","updated":"2020-12-01T07:43:04.395Z","comments":true,"path":"2020/11/28/Linux-User-mode-Driver/","link":"","permalink":"https://www.zi-c.wang/2020/11/28/Linux-User-mode-Driver/","excerpt":"UIO userspace i/o20200702Make the user mode driver code a better citizen20040120User-space device driverstldp userspace device driver20161019Linux drivers in user space — a surveyUIO: user-space driversThe Userspace I/O HOWTO","text":"UIO userspace i/o20200702Make the user mode driver code a better citizen20040120User-space device driverstldp userspace device driver20161019Linux drivers in user space — a surveyUIO: user-space driversThe Userspace I/O HOWTO UIO因为不支持DMA已经被vfio取代了,zd 2.6.22被引入 UIO的目的，对于有些设备来说创建Linux kernel driver有点多余了，这些设备只是需要处理中断和提供对device内存区域的访问，例如industrial I/O card。 UIO不完全排除内核空间代码的使用，需要一个小的模块负责device设置，PCI总线接口、注册interrupt handler等 相关数据结构在linux/uio_driver.h,在sysfs和/dev/uioX 导出用户接口，使用dev的接口进行设备控制，mmap映射设备的寄存器或者RAM，通过读dev/uioX处理中断（可以通过select），每个UIO设备可以创建一个或多个内存区域能够进行内存映射，因为一些industrial I/O card在driver中需要访问超过一个PCI内存区域 UIO驱动是char drivers，没有block和network drivers，不能在用户态设置DMA VFIOvfio-kernel documentVFIO core frameworkVFIOvfio: expose virtual Shared Virtual Addressing to VMsSafe device assignment with VFIOIOMMU &amp; iomap &amp;VFIO &amp; uioVFIO - “Virtual Function I/O” VFIO 把内核态的和IO相关的内存区域、IO port和DMA暴露给用户态，可以用KVM做设备直通，也可以构建用户态driver。也是通过 /dev/vfio暴露接口，通过IOCTL系统调用发送操作device的command 在VFIO中虚拟机直通的最小单元不再是单独的设备，而是同一group里面的所有设备，而仅仅通过IOMMU设置直通则无法处理多个有联系的PCI设备的相互访问。因此VFIO集成了IOMMU和UIO的优点。 DPDK Data Plane Development KitDPDK介绍Network acceleration with DPDK 是一种intel使用intel硬件提供的用户空间的网络驱动解决方案。用于快速数据包处理的函数库与驱动集合，可以极大提高数据处理性能和吞吐量，提高数据平面应用程序的工作效率。 DPDK使用了轮询(polling)而不是中断来处理数据包。在收到数据包时，经DPDK重载的网卡驱动不会通过中断通知CPU，而是直接将数据包存入内存，交付应用层软件通过DPDK提供的接口来直接处理，这样节省了大量的CPU中断时间和内存拷贝时间 DPDK defines an execution environment which contains user-space network drivers. 具体优点是使用了HUGEPAGE和numa，CPU亲和等硬件技术，加快运行速度，还有使用了UIO或VFIO技术直接暴露设备内存通过zero copy的方式减少系统调用和复制数据开销。 SPDK storage performance development kit给NVME-ssd设计的高速工具包，intel提供的使用intel网络、处理、存取技术，充分发挥固态存储的优势，采用了UIO和polling，将驱动代码运行在内核态，多路复用取代阻塞I/O。 其中也涉及不少实现细节，但总之是当下速度比较快的一种I/O工具。实现思路和DPDK一样，也是取消get/put_user，mmap直接干。 referenceLinux drivers in user space — a surveyUser-space device driversUser-space device driversMake the user mode driver code a better citizen","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"Driver","slug":"Driver","permalink":"https://www.zi-c.wang/tags/Driver/"},{"name":"Linux","slug":"Linux","permalink":"https://www.zi-c.wang/tags/Linux/"}]},{"title":"kernel-exploit-vm搭建","slug":"kernel-exploit-vm搭建","date":"2020-11-28T07:15:29.000Z","updated":"2020-11-28T07:19:06.967Z","comments":true,"path":"2020/11/28/kernel-exploit-vm搭建/","link":"","permalink":"https://www.zi-c.wang/2020/11/28/kernel-exploit-vm%E6%90%AD%E5%BB%BA/","excerpt":"环境：Manjaro(archlinux)18 Linux wangzc-pc 4.14.193-1-MANJARO x86_64 GNU/Linux","text":"环境：Manjaro(archlinux)18 Linux wangzc-pc 4.14.193-1-MANJARO x86_64 GNU/Linux 1. 内核编译1.1 linux-3.7.1 使用gcc-4.9编译 由于 kernel 3.x 开发时间较早，因此不适用PIC PIE等加载机制，尤其在gcc-10环境下已经变成默认设置。 因此我们最好使用 gcc-4.9 进行编译，可以使用 aur 库中的自动安装（编译时间较长），安装之后修改 kernel3.x 的 Makefile。 1234567# 安装gcc-4.9yay -S gcc49# 修改 MakefileCC &#x3D; $(CROSS_COMPILE)gcc -&gt; gcc-4.9HOSTCC &#x3D; gcc -&gt; gcc-4.9 编译选项 Kernel hacking —&gt; Compile the kernel with debug info Kernel hacking —&gt; Compile the kernel with frame pointer Kernel hacking —&gt; KGDB: kernel debugger perl 脚本修改 kernel/timeconst.pl 脚本中出现 if (!define(@val)) 无法执行的问题，解决办法是修改为 if (!@val) 即可 设置默认配置 1make x86_64_defconfig make -j4 进行编译，在 arch/x86_64/boot 目录下，生成bzImage 1.2 linux-4.4.232 设置默认配置 12make x86_64_defconfigmake kvmconfig 修改编译选项 Kernel hacking → Compile-time checks and compiler options -&gt; Compile the kernel with debug info -&gt; Compile the kernel with frame pointers Kernel hacking → KGDB: kernel debugger 1.3 linux-5.8.2 设置默认配置 123make x86_64_defconfigmake kvm_guest.config# &#39;make kvmconfig&#39; will be removed after Linux 5.10 修改编译选项 Kernel hacking &gt; Compile-time checks and compiler options Kernel hacking &gt; Kernel debugging 2. 编译busybox-1.32.0 编译选项 选中 setting &gt; Build static binary (no shared libs) 取消 inetd make install -j2 打包 编译成功后进入 _install 目录，创建 1234567891011121314151617mkdir proc sys dev etc etc&#x2F;init.dvim etc&#x2F;init.d&#x2F;rcS# 写入mkdir &#x2F;homemkdir &#x2F;home&#x2F;ppwtouch &#x2F;etc&#x2F;passwdtouch &#x2F;etc&#x2F;groupadduser ppwcat &#x2F;proc&#x2F;kallsyms | grep start_kernelmkdir &#x2F;homemkdir &#x2F;home&#x2F;ppwtouch &#x2F;etc&#x2F;passwdtouch &#x2F;etc&#x2F;groupadduser ppwcat &#x2F;proc&#x2F;kallsyms | grep start_kernelfind . | cpio -o --format&#x3D;newc &gt; rootfs.cpio 3. qemu 启动，调试12345678910#!&#x2F;bin&#x2F;sh# linux-5.8.2&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImage# linux-4.4.232&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImage# linux-3.7.1&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImageqemu-system-x86_64 -kernel linux-3.7.1&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImage \\-initrd busybox-1.32.0&#x2F;_install&#x2F;rootfs.img \\-append &quot;nokalsr console&#x3D;ttyS0 root&#x3D;&#x2F;dev&#x2F;ram rdinit&#x3D;&#x2F;sbin&#x2F;init&quot; \\-cpu kvm64,+smep \\--nographic -gdb tcp::1234 \\ 共享目录还没有进行测试。2.6内核测试不成功，不知道为啥。 123456qemu-system-i386 -kernel bzImage -s -append nokaslr -initrd initramfs.img -fsdev local,security_model&#x3D;passthrough,id&#x3D;fsdev-fs0,path&#x3D;&#x2F;home&#x2F;error404&#x2F;Desktop&#x2F;CTF_question&#x2F;Kernel&#x2F;Buffer_overflow_basic_1&#x2F;Share -device virtio-9p-pci,id&#x3D;fs0,fsdev&#x3D;fsdev-fs0,mount_tag&#x3D;rootme 解决方法 12345mkdir rootfs# 解压缩cpio -idvm &lt; ..&#x2F;rootfs.cpio# 压缩find . | cpio -o --format&#x3D;newc &gt; rootfs.cpio 另一个例子 1234567891011121314151617181920212223mount -t proc proc &#x2F;procmount -t sysfs sysfs &#x2F;sysmount -t devtmpfs none &#x2F;dev&#x2F;sbin&#x2F;mdev -smkdir -p &#x2F;dev&#x2F;ptsmount -vt devpts -o gid&#x3D;4,mode&#x3D;620 none &#x2F;dev&#x2F;ptschmod 666 &#x2F;dev&#x2F;ptmxcat &#x2F;proc&#x2F;kallsyms &gt; &#x2F;tmp&#x2F;kallsymsecho 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;kptr_restrictecho 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;dmesg_restrictifconfig eth0 upudhcpc -i eth0ifconfig eth0 10.0.2.15 netmask 255.255.255.0route add default gw 10.0.2.2 insmod &#x2F;core.ko poweroff -d 1200000 -f &amp;setsid &#x2F;bin&#x2F;cttyhack setuidgid 0 &#x2F;bin&#x2F;shecho &#39;sh end!\\n&#39;umount &#x2F;procumount &#x2F;sys poweroff -d 0 -f 变量kptr_restrict是可以用来限制内核地址的打印，当kptr_restrict=0时，会直接打印内核地址（%p和%pK效果一样）； 当kptr_restrict=1时，若在中断上下文或软中断时，%pK打印“pK-error”，否则内核地址打印全0； 当kptr_restrict=2时，%pK打印内核地址为全0； dmesg能够输出kernel ring buffer中的内容，这些内容中可能会包含一些敏感信息，我们可以通过设置内核参数 dmesg_restrict 为 1 的方式来禁止普通用户查看demsg信息。 mmap_min_addr 指定用户进程通过mmap可使用的最小虚拟内存地址，以避免其在低地址空间产生映射导致安全问题。 kptr_restrict / dmesg_restrict 在linux内核漏洞利用中常常使用commit_creds和prepare_kernel_cred来完成提权，它们的地址可以从/proc/kallsyms中读取。/proc/sys/kernel/kptr_restrict被默认设置为1以阻止通过这种方式泄露内核地址。dmesg_restrict限制非特权读dmesg（Restrict unprivileged access to kernel syslog） SMEP/SMAP SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)和SMAP(Supervisor Mode Access Prevention，管理模式访问保护)，其作用分别是禁止内核执行用户空间的代码和禁止内核访问用户空间的数据。","categories":[],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"vm","slug":"vm","permalink":"https://www.zi-c.wang/tags/vm/"},{"name":"exploit","slug":"exploit","permalink":"https://www.zi-c.wang/tags/exploit/"}]},{"title":"二叉树非递归遍历","slug":"二叉树非递归遍历","date":"2020-11-24T02:28:59.000Z","updated":"2020-11-24T05:43:42.653Z","comments":true,"path":"2020/11/24/二叉树非递归遍历/","link":"","permalink":"https://www.zi-c.wang/2020/11/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/","excerpt":"二叉树非递归遍历总是容易忘，这次从原理出发理解一次。 12345 1 &#x2F; \\ 2 3 &#x2F; \\ &#x2F;4 5 6","text":"二叉树非递归遍历总是容易忘，这次从原理出发理解一次。 12345 1 &#x2F; \\ 2 3 &#x2F; \\ &#x2F;4 5 6 preorder123handle(p-&gt;val);preorder(root-&gt;left);preorder(root-&gt;right); 1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6 先序输出顺序是中左右，因此首先输出，其次要保存左子树，穷尽左子树之后弹出节点，最后输出右子树 1234567891011121314stack&lt;TreeNode*&gt; st;TreeNode* p &#x3D; root;while (p !&#x3D; NULL || !st.empty()）&#123; while (p !&#x3D; NULL) &#123; handle(p-&gt;val); st.push(p); p &#x3D; p-&gt;left; &#125; if (!st.empty()) &#123; p &#x3D; st.top(); st.pop(); p &#x3D; p-&gt;right; &#125;&#125; inorder123inorder(p-&gt;left);handle(p-&gt;val);inorder(p-&gt;right); 4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3 中序遍历的输出顺序是左中右，和先序遍历有相似性，因为也需要先保存左子树，再弹出左子树找到中和右。 123456789101112stack&lt;TreeNode*&gt; st;TreeNode* p &#x3D; root;while (p !&#x3D; NULL || !st.empty()) &#123; st.push(p); p &#x3D; p-&gt;left;&#125;if (!st.empty()) &#123; p &#x3D; st.top(); st.pop(); handle(p-&gt;val); p &#x3D; p-&gt;right;&#125; postorder123postorder(p-&gt;left);postorder(p-&gt;right);handle(p-&gt;val); 4-&gt;5-&gt;2-&gt;6-&gt;3-&gt;1 后序遍历输出顺序是左右中，先保存左侧节点，然后检查右侧节点，当右子树为空或者已经被访问了，可以访问这个节点 12345678910111213141516171819stack&lt;TreeNode*&gt; st;TreeNode* p &#x3D; root;while (p !&#x3D; NULL || !st.empty()) &#123; while (p !&#x3D; NULL) &#123; st.push(p); p &#x3D; p-&gt;left; &#125; p &#x3D; s.top(); TreeNode* tmp &#x3D; NULL; while (!st.empty() &amp;&amp; (p-&gt;right &#x3D;&#x3D; NULL || p-&gt;right &#x3D;&#x3D; tmp)) &#123; st.pop(); if (!st.empty()) &#123; tmp &#x3D; p; p &#x3D; st.top(); &#125; &#125; if (st.emtpy()) break; p &#x3D; p-&gt;right;&#125; BFS1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 广度优先按照层次每次保存一层，当输出的时候记录当前队列长度，该长度即为上层被保存的节点数量，依次遍历即为按层次输出 12345678910111213141516queue&lt;TreeNode*&gt; q;TreeNode* p &#x3D; NULL;q.push(p);while (!q.emtpy()) &#123; int size &#x3D; q.size(); for (int i &#x3D; 0;i &lt; size;i++) &#123; p &#x3D; q.front(); q.pop(); handle(p-&gt;val); if (p-&gt;left !&#x3D; NULL) q.push(p-&gt;left); if (p-&gt;right !&#x3D; NULL) q.push(p-&gt;right); &#125; &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"},{"name":"binarytree","slug":"binarytree","permalink":"https://www.zi-c.wang/tags/binarytree/"}]},{"title":"NJU研究生通知RSS","slug":"NJU研究生通知RSS","date":"2020-11-19T06:39:45.000Z","updated":"2020-11-21T08:54:32.396Z","comments":true,"path":"2020/11/19/NJU研究生通知RSS/","link":"","permalink":"https://www.zi-c.wang/2020/11/19/NJU%E7%A0%94%E7%A9%B6%E7%94%9F%E9%80%9A%E7%9F%A5RSS/","excerpt":"NJU-notifeedNanjing University notification feed https://github.com/purplewall1206/NJU-notifeed 直接订阅：http://idcvz.zi-c.wang:8000/rss","text":"NJU-notifeedNanjing University notification feed https://github.com/purplewall1206/NJU-notifeed 直接订阅：http://idcvz.zi-c.wang:8000/rss 主要收集以下两个网站的最新通知，生成统一的feed提供给本地部署的RSS阅读器（i.e. Thunderbird） https://grawww.nju.edu.cn http://pyb.nju.edu.cn/ 设计思路使用requests和beautifulsoup4制作爬虫，获取通知页面的信息条目news 使用PyRSS2Gen生成feed条目，并写到feed.xml文件中（这里有个问题，lib好像只提供文件写入函数了，暂时没找到其他的output方式） 使用Flask构建RESTful API，访问 http://url/rss 获取feed 使用多线程其中一个线程运行爬虫，主线程（flask单线程）维护API 文件结构： news.py news struct，存储消息的属性 crawlerPYB/GRA.py 两个网站的爬虫策略 __init__.py 主函数，通过多线程的方式每小时更新一次feed。 logging.txt 记录调用日志 requirement.txt 安装的python lib，sudo pip install -r requirement.txt ubuntu 运行面对的问题 sudo apt-get install python3-html5lib 启动问题加入description信息获取之后，服务器往往无法立即反应，需要等到logging中显示出爬虫已经完全获取信息的日志之后，才能通过网站访问。需要处理一下这个问题，应该是global被锁住，服务器比爬虫先启动导致的。","categories":[{"name":"python","slug":"python","permalink":"https://www.zi-c.wang/categories/python/"},{"name":"rss","slug":"python/rss","permalink":"https://www.zi-c.wang/categories/python/rss/"},{"name":"github","slug":"python/rss/github","permalink":"https://www.zi-c.wang/categories/python/rss/github/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.zi-c.wang/tags/python/"},{"name":"rss","slug":"rss","permalink":"https://www.zi-c.wang/tags/rss/"},{"name":"github","slug":"github","permalink":"https://www.zi-c.wang/tags/github/"},{"name":"NJU","slug":"NJU","permalink":"https://www.zi-c.wang/tags/NJU/"}]},{"title":"Raspberry Pi 内核编译","slug":"Raspberry-Pi-内核编译","date":"2020-11-16T12:06:10.000Z","updated":"2020-11-16T12:10:02.276Z","comments":true,"path":"2020/11/16/Raspberry-Pi-内核编译/","link":"","permalink":"https://www.zi-c.wang/2020/11/16/Raspberry-Pi-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/","excerpt":"我的版本 : 树莓派3 1.内核获取1.1.软件下载sudo apt install git bc bison flex libssl-dev make","text":"我的版本 : 树莓派3 1.内核获取1.1.软件下载sudo apt install git bc bison flex libssl-dev make 关于libssl-dev的小问题12345sudo apt-get install aptitudedpkg -l *libssl*sudo aptitude install libssl-dev 1.2.源码获取git clone --depth=1 https://github.com/raspberrypi/linux 2.内核编译预设环境 1234cd linuxKERNEL&#x3D;kernel7make bcm2709_defconfig或者 zcat &#x2F;proc&#x2F;config.gz &gt; .config #从现在原有版本的内核中复制配置文件 编译 123456make -j4 zImage modules dtbssudo make modules_installsudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;*.dtb &#x2F;boot&#x2F;sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;*.dtb* &#x2F;boot&#x2F;overlays&#x2F;sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;README &#x2F;boot&#x2F;overlays&#x2F;sudo cp arch&#x2F;arm&#x2F;boot&#x2F;zImage &#x2F;boot&#x2F;$KERNEL.img 3.更换内核修改 /boot/config.txt 文件中内容 kernel=kernel-myconfig.img myconfig的版本在/lib/modules/ 文件夹中。 4.参考文件DOCUMENTATION &gt; LINUX &gt; KERNEL &gt; BUILDING","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"},{"name":"raspberryPi","slug":"kernel/raspberryPi","permalink":"https://www.zi-c.wang/categories/kernel/raspberryPi/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"raspberryPi","slug":"raspberryPi","permalink":"https://www.zi-c.wang/tags/raspberryPi/"}]},{"title":"三剑客sed/awk/grep常用速查","slug":"三剑客sed-awk-grep常用速查","date":"2020-11-16T06:22:23.000Z","updated":"2020-11-16T06:24:22.817Z","comments":true,"path":"2020/11/16/三剑客sed-awk-grep常用速查/","link":"","permalink":"https://www.zi-c.wang/2020/11/16/%E4%B8%89%E5%89%91%E5%AE%A2sed-awk-grep%E5%B8%B8%E7%94%A8%E9%80%9F%E6%9F%A5/","excerpt":"sed和awk的区别，都是按行读入，但是awk会拆分行里面的元素，sed则直接用正则做匹配，基本上sed可以做到的awk都可以。 awkawk &#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39; netstat.txt awk 使用print和printf打印每行中按列分布的元素。 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot;&#39; netstat.txt 过滤记录 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot; || NR==1 &#123;printf &quot;%02s %s %-20s %-20s %s\\n&quot;,NR, FNR, $4,$5,$6&#125;&#39; netstat.txt 其中NR，FNR为内建变量","text":"sed和awk的区别，都是按行读入，但是awk会拆分行里面的元素，sed则直接用正则做匹配，基本上sed可以做到的awk都可以。 awkawk &#39;&#123;printf &quot;%-8s %-8s %-8s %-18s %-22s %-15s\\n&quot;,$1,$2,$3,$4,$5,$6&#125;&#39; netstat.txt awk 使用print和printf打印每行中按列分布的元素。 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot;&#39; netstat.txt 过滤记录 awk &#39;$3==0 &amp;&amp; $6==&quot;ESTABLISHED&quot; || NR==1 &#123;printf &quot;%02s %s %-20s %-20s %s\\n&quot;,NR, FNR, $4,$5,$6&#125;&#39; netstat.txt 其中NR，FNR为内建变量 $0 当前记录（这个变量中存放着整个行的内容） $1~$n 当前记录的第n个字段，字段间由FS分隔 FS 输入字段分隔符 默认是空格或Tab NF 当前记录中的字段个数，就是有多少列 NR 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。 FNR 当前记录数，与NR不同的是，这个值会是各个文件自己的行号 RS 输入的记录分隔符， 默认为换行符 OFS 输出字段分隔符， 默认也是空格 ORS 输出的记录分隔符，默认为换行符 FILENAME 当前输入文件的名字 awk &#39;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1,$3,$6&#125;&#39; /etc/passwd 指定分隔符 awk &#39;$6 ~ /E/ || NR==1 &#123;print NR, $4,$5,$6&#125;&#39; netstat.txt ~表示开始，//表示匹配，这行命令表示匹配第六个元素开始包含E的行和第一行，然后输出行数和第456个元素。 awk &#39;NR!=1&#123;print $4,$5 &gt; $6&#125;&#39; netstat.txt 不处理第一行，按照第六列元素分类拆分成若干个文件，文件的内容是第45列元素。 awk 脚本123456789101112131415161718192021222324#!&#x2F;bin&#x2F;awk -f# 运行前BEGIN &#123; math &#x3D; 0 english &#x3D; 0 computer &#x3D; 0 printf &quot;NAME NO. MATH ENGLISH COMPUTER TOTAL\\n&quot; printf &quot;---------------------------------------------\\n&quot;&#125;# 运行中&#123; math +&#x3D; $3 english +&#x3D; $4 computer +&#x3D; $5 printf &quot;%-6s %-6s %4d %8d %8d %8d\\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5&#125;# 运行之后END &#123; printf &quot;---------------------------------------------\\n&quot; printf &quot; TOTAL:%10d %8d %8d \\n&quot;, math, english, computer printf &quot;AVERAGE:%10.2f %8.2f %8.2f\\n&quot;, math&#x2F;NR, english&#x2F;NR, computer&#x2F;NR&#125; awk -v val=$x &#39;&#123;print $1, $2, $3, $4+val, $5+ENVIRON[&quot;y&quot;]&#125;&#39; OFS=&quot;\\t&quot; score.txt 其中x，y为环境变量，为了使用环境变量需要 -v echo $PATH| awk &#39;BEGIN&#123;RS=&quot;:&quot;&#125;&#123;print NR,$0&#125;&#39; 把单行拆分成多行 sedsed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件] e&lt;script&gt;或–expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。 f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。 h或–help 显示帮助。 n或–quiet或–silent 仅显示script处理后的结果。 V或–version 显示版本信息。 a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～ s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ sed &quot;s/my/ppw &#39;s/g&quot; pets.txt 把pets.txt文件的my改成ppw’s，并不修改文件。/g 表示一行上的替换所有的匹配 加入-i sed -i &quot;s/my/ppw &#39;s/g&quot; pets.txt可以直接修改文件 sed &#39;s/^/---/g&#39; pets.txt 在开头加上— sed &#39;s/$/---/g&#39; pets.txt 在结尾加上— 同理类似的有： \\&lt; 表示词首。 如：&lt;abc 表示以 abc 为首的詞。 \\&gt; 表示词尾。 如：abc&gt; 表示以 abc 結尾的詞。 . 表示任何单个字符。 * 表示某个字符出现了0次或多次。 字符集合。 如：[abc] 表示匹配a或b或c，还有 [a-zA-Z] 表示匹配所有的26个字符。如果其中有^表示反，如 [^a] 表示非a的字符 sed &#39;s/&lt;[^&gt;]*&gt;//g&#39; html.txt 取消html文件中的&lt;&gt;tags,不能使用&#39;s/&lt;.*&gt;&#39;//g，因为会贪婪匹配掉第一个《和最后一个》之间所有的内容，现在给出的示例是匹配除了&gt;意外的字符。 sed &#39;3s/my/your/g&#39; pets.txt 和 sed &#39;3,6s/my/your/g&#39; pets.txt，分别表示匹配第三行和第三到六行。 sed &#39;s/s/S/1&#39; pets.txt 匹配每一行的第一个s sed &#39;1,3s/my/your/g; 3,$s/This/That/g&#39; pets.txt 匹配多个 sed &#39;s/my/[&amp;]/g&#39; pets.txt 使用&amp;来当做被匹配的变量，然后可以在基本左右加点东西 sed &#39;s/This is my \\([^,]*\\),.*is \\(.*\\)/\\1:\\2/g&#39; my.txt 圆括号括起来的正则表达式所匹配的字符串会可以当成变量来使用，sed中使用的是\\1,\\2… sed &#39;N;s/my/your/&#39; pets.txt 原文本中的偶数行纳入奇数行匹配，而s只匹配并替换一次，所以最后只有奇数行被修改。 N命令把下一行的内容纳入当成缓冲区做匹配。 sed &quot;1 i This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 和 sed &quot;$ a This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 命令i和a分别表示insert 和 append，添加行 sed &quot;/my/a ----&quot; my.txt 在每行结尾都添加 —- sed &quot;2 c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 和 sed &quot;/fish/c This is my monkey, my monkey&#39;s name is wukong&quot; my.txt 命令c表示替换，这两个命令分别表示替换第二行和有’fish’存在的那一行。 sed &#39;/fish/d&#39; my.txt 和 sed &#39;2d&#39; my.txt 和 sed &#39;2,$d&#39; my.txt 命令d表示删除匹配行，这三个命令分别表示删除有fish的一行，删除第二行和删除第二到最后的所有行。 sed -n &#39;/dog/,/fish/p&#39; my.txt 命令-n表示只显示处理后的结果，命令p表示打印，图中命令表示打印有dog的一行和有fish的一行。 grepgrep -i -c &#39;.*ret.*&#39; linux-exec.s 统计内核二级制文件中ret命令的个数，不区分大小写，直接输出匹配行数。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/categories/linux/"},{"name":"bash","slug":"linux/bash","permalink":"https://www.zi-c.wang/categories/linux/bash/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://www.zi-c.wang/tags/bash/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"tool","slug":"tool","permalink":"https://www.zi-c.wang/tags/tool/"}]},{"title":"kernel contribution 统计","slug":"kernel-contribution-统计","date":"2020-11-16T06:19:37.000Z","updated":"2020-11-16T06:24:36.180Z","comments":true,"path":"2020/11/16/kernel-contribution-统计/","link":"","permalink":"https://www.zi-c.wang/2020/11/16/kernel-contribution-%E7%BB%9F%E8%AE%A1/","excerpt":"保存lwn.net发布的新版本开发统计文章，目前来看还是华为最屌。 Development statistics for the 5.0 kernelAs of this writing, 12,517 non-merge changesets have been pulled into the mainline repository for the 5.0 release Some 5.5 kernel development statistics5.5 saw the merging of 14,350 non-merge changesets from 1,885 developers","text":"保存lwn.net发布的新版本开发统计文章，目前来看还是华为最屌。 Development statistics for the 5.0 kernelAs of this writing, 12,517 non-merge changesets have been pulled into the mainline repository for the 5.0 release Some 5.5 kernel development statistics5.5 saw the merging of 14,350 non-merge changesets from 1,885 developers Some 5.6 kernel development statistics12,665 non-merge changesets had been accepted from 1,712 developers Development statistics for the 5.7 kernelWork on 5.7 arrived in the form of 13,901 non-merge changesets contributed by 1,878 developers;","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"lwn.net","slug":"lwn-net","permalink":"https://www.zi-c.wang/tags/lwn-net/"}]},{"title":"io_uring 系统性整理","slug":"io-uring-系统性整理","date":"2020-11-15T11:42:54.000Z","updated":"2020-11-15T11:52:18.240Z","comments":true,"path":"2020/11/15/io-uring-系统性整理/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/io-uring-%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%95%B4%E7%90%86/","excerpt":"io_uring 系统性整理 io_uring 系统性整理 I/O 模型 comparison Asynchronous I/O io_uring 总结邮件 这里有个误解，I/O模型其实是针对整个系统的所有I/O操作的，但是平时很少对文件系统使用异步读写，同步或直接映射的情况比较多。更别提多路复用了，这个机制基本只用在network中。 lwn Kernel article index","text":"io_uring 系统性整理 io_uring 系统性整理 I/O 模型 comparison Asynchronous I/O io_uring 总结邮件 这里有个误解，I/O模型其实是针对整个系统的所有I/O操作的，但是平时很少对文件系统使用异步读写，同步或直接映射的情况比较多。更别提多路复用了，这个机制基本只用在network中。 lwn Kernel article index I/O 模型 blocking I/O 同步阻塞，直到内核收到数据返回给线程。 nonblocking I/O 同步不阻塞，但是如果内核没收到数据会返回一个 EWOULDBLOCK I/O multiplexing (select and poll) 异步阻塞，使用selet（using select requires two system calls instead of one）、poll系统调用循环等待socket可读时，使用recvfrom收取数据。主要优势在于能够在单线程监控多个文件描述符fd。 初次之外还有epoll,使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次 优点有： 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。 这种方法基本等价于 一个进程创建多个线程，每个线程维护一个blocking I/O signal driven I/O (SIGIO) 非阻塞，通过sigaction系统调用安装signal handler，当datagram数据报可读时，向I/O接收进程发送SIGIO信号，可以在signal handler里面读这个数据，然后通知main loop；也可以先通知main loop，让main loop去读这个数据。 asynchronous I/O (the POSIX aio_functions) 异步非阻塞，也是调用aio_read之后立刻返回，和SIGIO的区别是直到接收到数据并将数据传输到用户时，才产生完成信号。 comparison 参考:io models彻底理解 IO多路复用聊聊IO多路复用之select、poll、epoll详解 Asynchronous I/O首先确定这里的AIO是内核态的，由libaio封装的系统调用运行库，而不是glibc用户态AIO，使用多线程模拟的。 linux kernel AIO的主要缺点在于项目泥潭，bug太多，项目设计和领导更换，而且实现比较复杂，直到现在只能比较稳定支持以O_DIRECT（直接映射修改，bypass page cache）方式打开文件，需要自己处理buffer、offset对其这些问题，不能用page cache层以bio的方式读写block数据。 因为使用page buffer层时涉及到block driver里面的队列，相比O_DIRECT多出很多阻塞点，因此实现起来比较令人恼火。因此这个项目根本就没实现起来。 因此io_uring的主要对比对象是多路复用和DPDK、SPDK，是一个事实上的新异步IO API Linux AIO does suffer from a number of ailments. The subsystem is quite complex and requires explicit code in any I/O target for it to be supported. 实现不了的地方基本上都开一个kernel thread跑，感觉开销更大了。 参考：Linux Asynchronous I/O Fixing asynchronous I/O, againLinux kernel AIO这个奇葩2017Toward non-blocking asynchronous I/O io_uring参考：Kernel Recipes 2019 - Faster IO through io_uring20190115Ringing in a new asynchronous I/O API20200715Operations restrictions for io_uring20200320Automatic buffer selection for io_uring20200124The rapid growth of io_uring20200511Hussain: Lord of the io_uringLinux异步IO新时代：io_uring20200716io_uring: add restrictions to support untrusted applications and guests20200225io_uring support for automatic buffersio_uring（1） – 我们为什么会需要 io_uringlinux “io_uring” 提权漏洞(CVE-2019-19241)分析io_uring（2）- 从创建必要的文件描述符 fd 开始 uring这个词没有翻译”something that looks a little less like io_urine”. 这是一个为了高速I/O提出的新的一系列系统调用，简单来说就是新的ring buffer。之前的异步I/O策略是libaio，这个机制饱受诟病，于是Jens Axboe直接提出io_uring，性能远超aio。 从5.7开始超出纯I/O的范畴，io_uring开始为一部接口提供FAST POLL机制，用户无需再像使用select、event poll等多路复用机制来监听文件句柄，只要把读写请求直接丢到io_uring的submission queue中提交 ，当文件句柄不可读写时，内核会主动添加poll handler，当文件句柄可读写时主动调用poll handler再次下发读写请求，从而减少系统调用次数提高性能 这是一个线程粒度的异步I/O机制，分为 submission queue和completion queue，在使用系统调用申请之后，直接返回可以使用mmap映射的file discriptor。 应用程序可以直接使用mmap映射的两个ring buffer直接与内核进行I/O数据传输交换，减少了大量系统调用的开销。 具体流程： setup int io_uring_setup(int entries, struct io_uring_params *params); 其中entries表示submission and completion queues两个队列的大小 param中设置两个队列和具体的状态 12345678struct io_uring_params &#123; __u32 sq_entries; __u32 cq_entries; __u32 flags; __u16 resv[10]; struct io_sqring_offsets sq_off; struct io_cqring_offsets cq_off;&#125;; 最终实现目的通过file descriptor与内核共享ring buffer 123456789101112subqueue &#x3D; mmap(0, params.sq_off.array + params.sq_entries*sizeof(__u32), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_SQ_RING);sqentries &#x3D; mmap(0, params.sq_entries*sizeof(struct io_uring_sqe), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_SQES);cqentries &#x3D; mmap(0, params.cq_off.cqes + params.cq_entries*sizeof(struct io_uring_cqe), PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE, ring_fd, IORING_OFF_CQ_RING); 相关资料：Ringing in a new asynchronous I/O APIThe rapid growth of io_uring 12345678910111213141516171819202122232425262728293031323334#include &lt;liburing.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main()&#123; struct io_uring ring; io_uring_queue_init(32, &amp;ring, 0); struct io_uring_sqe *sqe &#x3D; io_uring_get_sqe(&amp;ring); int fd &#x3D; open(&quot;&#x2F;home&#x2F;carter&#x2F;test.txt&quot;, O_WRONLY | O_CREAT); struct iovec iov &#x3D; &#123; .iov_base &#x3D; &quot;Hello world&quot;, .iov_len &#x3D; strlen(&quot;Hello world&quot;), &#125;; io_uring_prep_writev(sqe, fd, &amp;iov, 1, 0); io_uring_submit(&amp;ring); struct io_uring_cqe *cqe; for (;;) &#123; io_uring_peek_cqe(&amp;ring, &amp;cqe); if (!cqe) &#123; puts(&quot;Waiting...&quot;); &#x2F;&#x2F; accept 新连接，做其他事 &#125; else &#123; puts(&quot;Finished.&quot;); break; &#125; &#125; io_uring_cqe_seen(&amp;ring, cqe); io_uring_queue_exit(&amp;ring);&#125; 总结邮件今天重新思考了一下IO模型，并阅读了io_uring和多路复用相关代码，感觉突然想通了。io_uring取代了AIO而不是取代了usercopy，usercopy部署的安全策略未必适用擅长传输大量数据的io_uring，这个工作可以推后再进行。具体如下。 一、将I/O模型的设计和实现分离 I/O在操作系统中含义包括与I/O设备通信和输入输出数据，I/O模型是针对第一种含义提出的解决方案。 linux在实现I/O的过程中参考了这些模型进行实现，但并没有在同一层次进行实现。例如LKM开发中定义的file_operations实际只包括 read（同步）/read_iter（异步）/mmap/poll 等函数指针，在I/O模型中的阻塞同步和非阻塞同步的情况可以通过使用read/read_iter 附加O_NONBLOCK的方式实现。 select epoll 多路复用和AIO这些I/O模型，则是分别在与之相同或不同的层次对底层函数进行封装。 例如 select 系统调用是在内核层通过vfs_poll遍历相关的file_descriptor，glibc实现的AIO是在用户空间多线程调用这些阻塞/非阻塞的同步/异步系统调用，epoll（更像是一个通知机制）是将select/poll中需要每次都传递的file descriptor都保存在内核中，减少了usercopy；通过event监听callback进行通知，减少了对fd的遍历开销。 二、思考io_uring的设计和实现 io_uring的设计借鉴了以上的优点，在内核空间通过kthread实现对阻塞读写任务的托管，并加入了zero copy特性，开发者可以通过一次系统调用唤醒线程一直向共享ringbuffer中写数据，而不是每次写数据都需要系统调用，这在内核和用户通信范畴内很大程度上减少了系统调用的次数，消除了usercopy的负担。 但无法否认io_uring是对下层file_operations的封装，下层函数又是device driver file_operations的封装（甚至对buffer I/O中间还有一层page cache、一层block layer、一层I/O schedule），因此io_uring在许多情况无法获得SPDK用户空间直通driver的性能优势。 三、对安全问题的思考 我目前理解的安全风险主要来自于usercopy造成的out-of-bound、information/pointer leakage和race情况，尤其是struct结构可能存在的函数/数据指针，但是io_uring消除掉的usercopy主要负责大量I/O数据的传输，而非带有指针的控制数据结构（io_uring中的控制数据也在用copy_*_user传输，如图），因此对安全问题的认识比我预期要复杂一些（主要问题可能是OOB和Iago攻击），需要加深对漏洞形式的理解，但好处是急迫程度下降了。 我只能继续积累漏洞阅读量提升认知水平，思考copy_*_user可以部署的安全机制和策略。 四、总结 我这阶段应该继续把重点放在kernel extension问题的描述上，对这个问题我已经基本有了一定想法，大致是将威胁模型定位为kernel rootkits，通过修改页表或切换地址空间构建运行时沙箱，使用可信基截获、保护gateway，使用hook方式监控driver相关函数和数据I/O。可以将性能的提升和对DPDK/SPDK使用的UIO和VFIO保护作为贡献点（这可能是这次突发奇想的意外收获），现在面临的问题是不确定相关方案是否有实现、近期driver保护方案相关只有四篇。","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"io_uring","slug":"io-uring","permalink":"https://www.zi-c.wang/tags/io-uring/"}]},{"title":"eBPF 简介","slug":"eBPF-简介","date":"2020-11-15T11:17:06.000Z","updated":"2020-11-15T11:52:20.424Z","comments":true,"path":"2020/11/15/eBPF-简介/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/eBPF-%E7%AE%80%E4%BB%8B/","excerpt":"eBPF eBPF 1. 简介 2. 参考材料 3. in-kernel virtual machine 4. JIT just-in-time compile 5. kprobe 实现原理 ebpf summit 2020峰会 这个有时间应该看一下 1. 简介eBPF由BPF（berkeley packet filter发展而来，BPF现在也叫classic-BPF由于区别BPF），到目前为止被引入了linux内核并且使用了JIT just in time comilper进行加速，类似于浏览器的javascript脚本执行语言。 eBPF定义了一个内核内运行的虚拟机 使用bcc进行bpf的开发，bcc和bpftrace项目的维护放在 iovisor","text":"eBPF eBPF 1. 简介 2. 参考材料 3. in-kernel virtual machine 4. JIT just-in-time compile 5. kprobe 实现原理 ebpf summit 2020峰会 这个有时间应该看一下 1. 简介eBPF由BPF（berkeley packet filter发展而来，BPF现在也叫classic-BPF由于区别BPF），到目前为止被引入了linux内核并且使用了JIT just in time comilper进行加速，类似于浏览器的javascript脚本执行语言。 eBPF定义了一个内核内运行的虚拟机 使用bcc进行bpf的开发，bcc和bpftrace项目的维护放在 iovisor 2. 参考材料 A thorough introduction to eBPF A JIT for packet filters BPF: the universal in-kernel virtual machine LECTURE BPF: Tracing and More TUTORIAL Learn eBPF Tracing: Tutorial and Examples TUTORIAL The bpftrace One-Liner Tutorial TUTORIAL bpftrace Reference Guide Linux内核攻击面之eBPF模块 3. in-kernel virtual machineThings started to change in the 3.0 release, when Eric Dumazet added a just-in-time compiler to the BPF interpreter. In the 3.4 kernel, the “secure computing” (seccomp) facility was enhanced to support a user-supplied filter for system calls; that filter, too, is written in the BPF language. 4. JIT just-in-time compileEric Dumazet’s patch is a fundamental change: it puts a just-in-time compiler into the kernel to translate BPF code directly into the host system’s assembly code. The simplicity of the BPF machine makes the JIT translation relatively simple; every BPF instruction maps to a straightforward x86 instruction sequence. 5. kprobe 实现原理这里仅做猜测，应该是直接使用kprobe技术，int3 打断点到指定位置，截取控制流到相应的probe callback 函数。","categories":[{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/categories/eBPF/"}],"tags":[{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/tags/eBPF/"}]},{"title":"内核近期改变","slug":"内核近期改变","date":"2020-11-15T11:09:13.000Z","updated":"2020-11-15T11:52:26.240Z","comments":true,"path":"2020/11/15/内核近期改变/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/%E5%86%85%E6%A0%B8%E8%BF%91%E6%9C%9F%E6%94%B9%E5%8F%98/","excerpt":"内核近期改变 内核近期改变 ioctl 1.原始版本的ioctl 2.内核改进后的ioctl 3.在编写过程中的处理办法 4. 原因分析 异步I/O read_iter 1.具体变化 2.原因分析 3.问题 timer计时器发生改变 block 驱动在5.0后进行了非常大的变化 原因 blk-mq 设计了两层队列 在架构层面 具体到函数 内核计时接口发生变化 系统调用初始化接口变化（未解决） 文件系统减少定义数量 （未解决） jprobe 被取消","text":"内核近期改变 内核近期改变 ioctl 1.原始版本的ioctl 2.内核改进后的ioctl 3.在编写过程中的处理办法 4. 原因分析 异步I/O read_iter 1.具体变化 2.原因分析 3.问题 timer计时器发生改变 block 驱动在5.0后进行了非常大的变化 原因 blk-mq 设计了两层队列 在架构层面 具体到函数 内核计时接口发生变化 系统调用初始化接口变化（未解决） 文件系统减少定义数量 （未解决） jprobe 被取消 ioctl1.原始版本的ioctl1int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long); 2.内核改进后的ioctl123long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);long (*compat_ioctl) (struct file *, unsigned int, unsigned long); 3.在编写过程中的处理办法 将原先的写的 ioctl 函数声明给改成下面的 unlocked_ioctl 或者 compat_ioctl, 在 file_operations 结构体的初始化中也是一样. 修改为unlocked_ioctl 或者 compat_ioctl, 注意参数的兼容性问题, 新的ioctl() 接口没有 struct inode* 参数, 如果ioctl 接口中使用了 inode, 因此需要通过其他方式获取 inode 123456789101112131415161718192021#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36)static int XXX_ioctl( struct inode *indoe, struct file *filp, unsigned int cmd, unsigned long arg)&#123;#else&#x2F;&#x2F;long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);&#x2F;&#x2F;long (*compat_ioctl) (struct file *, unsigned int cmd, unsigned long arg)static long XXX_unlocked_ioctl( struct file *filp, unsigned int cmd, unsigned long arg)&#123; &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;f_dentry-&gt;d_inode; &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;d_inode; struct inode *inode &#x3D; inode &#x3D; file_inode(filp);#endif &#x2F;* 此处是ioctl() 函数结构的具体实现 *&#x2F;&#125; 同理，file_operations中也进行同样修改。 123456789101112static struct file_operations fpga_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; fpga_open, .read &#x3D; fpga_read, .write &#x3D; fpga_write, .llseek &#x3D; fpga_llseek,#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36) .ioctl &#x3D; XXX_ioctl,#else .unlocked_ioctl &#x3D; XXX_unlocked_ioctl,#endif&#125;; 4. 原因分析file_operations (include/linux/fs.h) 结构变化,ioctl本身并不安全，且之前的ioctl使用了大内核锁延迟太大，因此进行修改。具体内容见The new way of ioctl() 异步I/O read_iter1.具体变化file_operations (include/linux/fs.h) 结构变化，导致 read_iter 和 write_iter 负责设备驱动的异步读写，取代了之前的 aio_read 和 aio_write,只需要将资料中二者进行转换即可。 2.原因分析The iov_iter interface iov_iter 功能增强了，并且试图合并 read(write)_iter 和 splice_read(write)，不过截至2020年5月13日来看这俩似乎还存在着 3.问题fs/ramfs/file-mmu.c 中为什么 file_operations 里面没有定义 read 和 write， 而只有异步I/O。 timer计时器发生改变Improving the kernel timers API用 timer_setup 替换了 init_timer,替换内核版本为4.14(2017)，属于较新的替换 1234567891011#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0) init_timer(&amp;dev-&gt;getIntrTimer); dev-&gt;getIntrTimer.data &#x3D; (unsigned long) dev; dev-&gt;getIntrTimer.function &#x3D; GetIntrTimerCallback; &#x2F;* ... *&#x2F; add_timer(&amp;dev-&gt;getIntrTimer);#else timer_setup(&amp;dev-&gt;getIntrTimer, GetIntrTimerCallback, 0); &#x2F;* the third argument may include TIMER_* flags *&#x2F; &#x2F;* ... *&#x2F;#endif callback function的变化 参数类型发生变化，否则会编译失败 12345678910#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0)void GetIntrTimerCallback(unsigned long devAddr)&#123; myDevice *dev &#x3D; (myDevice *) devAddr;#elsevoid GetIntrTimerCallback(struct timer_list *t)&#123; myDevice *dev &#x3D; from_timer(dev, t, getIntrTimer);#endif &#x2F;* Do something with &quot;dev&quot; *&#x2F; block 驱动在5.0后进行了非常大的变化In kernel V5 blk_fetch_request() and blk_init_queue() gone. Now What? Linux Kernel 5.0 – we write Simple Block Device under blk-mq block: remove __bio_kmap_atomic 内核工匠 公众号 Multiqueue架构分析 block 驱动在5.0后进行了非常大的变化 原因是使用了 multi-queue block layer 即 blk-mq 完全取代了之前的 blk-sq（single-queue），因为从前的IO速度瓶颈在硬件方面，因此可以使用单一队列，即使多个cpu竞争自旋锁获取队列写入权限依旧不过分影响性能。而最近的高IOPS（io per second）硬件逐渐增多比如ssd，nvme等硬件设备开始大量使用，那么从前的single queue在高IOPS场景下80% cpu时间耗费在锁获取上了，因此设计了新的blk-mq 获取锁仅占用 3% cpu时间。 blk-mq 设计了两层队列 首先为每个cpu分配了一个软件暂存队列（software staging queue），负责完成bio 提交/完成处理，IO请求暂存（合并、排序等）、IO请求标记、调度、记账（和新的IO调度算法BFS有关） 硬件派发队列（Hardware Dispatch Queue） 为每个硬件队列分派一个硬件派发队列，负责存放软件队列向硬件派发的IO请求，一个和多个软件队列和一个硬件队列存在固定映射关系 在架构层面mq 将 request 和 tag 绑定，request内存分配在块设备驱动初始化时完成（调用blk_mq_alloc_tag_set）避免IO时分配request内存带来消耗 tag作为request（static_rqs/rqs）的索引。 具体到函数有 blk_fetch_request , __blk_end_request_cur ,blk_init_queue, __bio_kmap_atomic(bio, iter) , __bio_kunmap_atomic(buffer) 等 其中 取代 __bio_kmap_atomic(bio, iter) , __bio_kunmap_atomic(buffer) 如下 123456789- char *buffer &#x3D; __bio_kmap_atomic(bio, iter);+ char *buffer &#x3D; kmap_atomic(bvec.bv_page) + bvec.bv_offset; unsigned len &#x3D; bvec.bv_len &gt;&gt; SECTOR_SHIFT; simdisk_transfer(dev, sector, len, buffer, bio_data_dir(bio) &#x3D;&#x3D; WRITE); sector +&#x3D; len;- __bio_kunmap_atomic(buffer);+ kunmap_atomic(buffer) 除此之外 BLK_MQ_F_SG_MERGE 和 QUEUE_FLAG_NO_SG_MERGE 都可以被省略了block: kill BLK_MQ_F_SG_MERGE 12- lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;+ lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE; 内核计时接口发生变化64位系统中,由于2038问题 时间戳 timespec 在 inode数据结构中的i_*time 中弃用，转而使用 timespec64 相应的 getnstimeofday 等函数也被弃用， 转而使用 ktime_get_ts64(struct timespec64 *ts) 等函数获取时间，另外需要注意 这个函数必须使用 GPL协议才能成功加载。 详见内核时间api文件，ktime accessors 最新设计的时间数据结构为 ktime_t 获取方式为 ktime_t ktime_get(void) 系统调用初始化接口变化（未解决）系统调用初始化接口代码越变越少，而且有点难以理解，除了在arch/x86/entry/syscall 目录下定义之外，还用了同目录下的脚本直接生成了ni代码 具体的解决办法是直接ftrace跟踪一波，看看syscall最新的调用路径 文件系统减少定义数量 （未解决）文件系统减少了大量file_operations定义数量，例如 aio_read aio_write 等异步代码直接被省略掉，read 和 write 接口基本也不定义了， 似乎使用了 read_iter 和 write_iter 替代了前两类接口 具体原因还没搞清楚，但是在 [V5,17/30] fs: use read_iter and write_iter rather than aio_read and aio_write 中显示 aio被明确删除掉，用iter替代。 此外 file_operations 当中的 readdir 等接口也被取消，直接由read/read_iter和 iterate 替代,iterate基本上可以理解为负责执行ls命令， filldentry_t 由 dir_context 替代。 jprobe 被取消在 kprobe中只剩下kprobe和kretprobe，jprobe及相关的一套函数被取消，替代方式如下： /source/samples/kprobes/kprobe_example.c 和 /source/samples/kprobes/kretprobe_example.c 中示例 使用kprobe中的handler_pre和handler_post替代。","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"}]},{"title":"dynamicprogramming.md","slug":"dynamicprogramming-md","date":"2020-11-15T10:36:17.000Z","updated":"2020-11-15T11:52:25.507Z","comments":true,"path":"2020/11/15/dynamicprogramming-md/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/dynamicprogramming-md/","excerpt":"动态规划 Dynamic Programming动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 tricky一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。 如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。","text":"动态规划 Dynamic Programming动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 tricky一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。 如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。 硬币找零问题 coin changeleetcode-322 You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:Input: coins = [1, 2, 5], amount = 11Output: 3Explanation: 11 = 5 + 5 + 1 解析：每种coins的数量是不限的，因此假设dp[i]是从0到金额i，所需要的最小硬币的数量初始化假设dp值均为 amount+1dp[i] = min(dp[i-coin[x]]+1, dp[i])循环遍历每个coin的值，获得dp最后的值，即相应的结果 123456789101112131415161718int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; &#x2F;&#x2F; dp[i] &#x3D; min(dp[i-coink]+1, dp[i]) if (amount &#x3D;&#x3D; 0) return 0; vector&lt;int&gt; dp(amount+1, amount+1); &#x2F;&#x2F; 此处初始化为amount+1，便于之后取最小值 dp[0] &#x3D; 0; for (int i &#x3D; 1;i &lt;&#x3D; amount;i++) &#123; for (int j &#x3D; 0;j &lt; coins.size();j++) &#123; if (i &gt;&#x3D; coins[j]) &#123; &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; coins[j] &lt;&lt;&quot; &quot; &lt;&lt; dp[i] &lt;&lt; &quot; &quot;; dp[i] &#x3D; min(dp[i], dp[i-coins[j]]+1); &#x2F;&#x2F; cout &lt;&lt; dp[i] &lt;&lt; endl; &#125; &#125; &#125; return (dp[amount] &#x3D;&#x3D; amount+1) ? -1 : dp[amount]; &#125; 01背包问题01背包是解决什么问题？ 答：当书包容量大小固定，面对1堆重量固定而且带有价格的物品。在不超出包容量前提下，选择那些物品使包里物品总价值最大。 其中代表重量的数组 w[0…i….n], 代表价值的数组 v[0…i…n]。 一般可以通过画表格确定解空间（还没研究明白） 动态规划的思路是设计 dp[N+1][S+1] 其中N代表物品数量，S代表背包总重量，即在N件物品，重量为S的情况下，物品的价值多大当w[i-1] &lt; j(当前剩余重量)时间分别代表装入或不装入dp[i][j] = min(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1]) 例题 target sumleetcode-494 You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1:Input: nums is [1, 1, 1, 1, 1], S is 3.Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. 根据题意可以假设集合nums有两个真子集A,B，其中集合A表示所有为正数的集合，集合B表示所有未负数的集合，目标值未target，那么有 123sum(A) + sum(B) &#x3D; sum(nums)sum(A) - sum(B) &#x3D; target2 * sum(A) &#x3D; sum(nums) + target 由上述递推公式将该问题转化为01背包问题，题解如下 123456789101112131415161718192021222324252627int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n &#x3D; nums.size(); long sum &#x3D; 0; for (int i : nums) sum +&#x3D; i; if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123; return 0; &#125; S &#x3D; (sum + S) &#x2F; 2; &#x2F;&#x2F; 传统dp &#x2F;&#x2F; 对于dp(i,j)就表示可选物品为i到n且背包容量为j(总重量)时背包中所放物品的最大价值 vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(S+1, 0)); &#x2F;&#x2F; 0个数和为0的个数为1 dp[0][0] &#x3D; 1; for (int i &#x3D; 1;i &lt;&#x3D;n;i++ ) &#123; for (int j &#x3D; 0;j &lt; S+1;j++) &#123; if(j-nums[i-1] &lt; 0)&#x2F;&#x2F;背包容量不足，不能放入第i个物品 &#123; dp[i][j] &#x3D; dp[i-1][j];&#x2F;&#x2F;其实就是表格的左边界 &#125; else &#123; dp[i][j] &#x3D; dp[i-1][j-nums[i-1]] + dp[i-1][j];&#x2F;&#x2F;装入第i个物品或者不装入 &#125; &#125; &#125; return dp[n][S]; &#125; 根据上述代码我们发现 dp[i][j] = dp[i-1][...] 的关系，即i至于i-1有关系，因此我们可以减少一维向量，用一维向量记录上一轮的运算结果。 12345678910111213141516171819int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n &#x3D; nums.size(); long sum &#x3D; 0; for (int i : nums) sum +&#x3D; i; if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123; return 0; &#125; S &#x3D; (sum + S) &#x2F; 2; &#x2F;&#x2F; dp优化 vector&lt;int&gt; dp(S+1, 0); dp[0] &#x3D; 1; for (int i &#x3D; 0;i &lt; n;i++) &#123; for (int j &#x3D; S;j &gt;&#x3D; nums[i];j--) &#123; dp[j] +&#x3D; dp[j-nums[i]]; &#125; &#125; return dp[S]; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-14T08:54:12.760Z","updated":"2020-11-15T11:22:11.557Z","comments":true,"path":"2020/11/14/hello-world/","link":"","permalink":"https://www.zi-c.wang/2020/11/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Next-theme ConfigHexo-NexT (v7.0+) 主题配置","categories":[],"tags":[]},{"title":"Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1的自动部署脚本","slug":"Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1的自动部署脚本","date":"2016-10-18T09:50:10.000Z","updated":"2020-11-22T08:51:15.510Z","comments":true,"path":"2016/10/18/Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1的自动部署脚本/","link":"","permalink":"https://www.zi-c.wang/2016/10/18/Nutch2.3.1+hbase-0.98-hadoop+solr5.2.1%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/","excerpt":"在阳总的帮助下，终于搞出了这个自动部署脚本，感谢阳总让我第一次看到真人写的bash脚本，很涨姿势。 hbase-0.98-hadoop 的选择原因是[http://wiki.apache.org/nutch/Nutch2Tutorial ](nutch turorial)上这么推荐的 solr5.x 的玩法似乎和solr4.9 差别不小，之后应该会单独写一篇分析的 测试环境是 centos6环境，使用ubuntu或者其他发行版的兄弟记得改下 那堆yum，rpm","text":"在阳总的帮助下，终于搞出了这个自动部署脚本，感谢阳总让我第一次看到真人写的bash脚本，很涨姿势。 hbase-0.98-hadoop 的选择原因是[http://wiki.apache.org/nutch/Nutch2Tutorial ](nutch turorial)上这么推荐的 solr5.x 的玩法似乎和solr4.9 差别不小，之后应该会单独写一篇分析的 测试环境是 centos6环境，使用ubuntu或者其他发行版的兄弟记得改下 那堆yum，rpm #!/bin/bash 这个写到一开头表示这是.sh那一类文件，剩下的就是用重定向之类的linux下的特殊写法追加写入文本的 脚本中的所有文件都将被部署到 /usr 目录下，如果改目录需要连着配置文件一起改，权限不够加sudo nutch crawl solr hbase 都写入环境变量，可以在任何目录下运行。 nutch 执行的是 /usr/nutch-2/runtime/local/bin/nutch 目录的文件，而不是deploy中 之后集成hadoop再修改配置文件。 以下是自动部署脚本，需要复制下来制作成 .sh 文件，使用 sudo bash xxx.sh 执行 自动部署脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!/bin/bashrpm -Uvh https://centos6.iuscommunity.org/ius-release.rpmyum install epel-release -yyum install git wget screen vim -yyum update -yiptables -Fiptables-saveservice iptables saveip6tables -Fip6tables-saveservice ip6tables savecd /optwget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u102-b14/jdk-8u102-linux-x64.rpm&quot;rpm -ivh jdk-8u102-linux-x64.rpmrm -rf jdk-8u102-linux-x64.rpmwget http://archive.apache.org/dist/hbase/hbase-0.98.8/hbase-0.98.8-hadoop2-bin.tar.gztar xzf hbase-0.98.8-hadoop2-bin.tar.gzrm -rf hbase-0.98.8-hadoop2-bin.tar.gzmv hbase-0.98.8-hadoop2 /usr/hbasewget http://www-eu.apache.org/dist/nutch/2.3.1/apache-nutch-2.3.1-src.tar.gztar xzf apache-nutch-2.3.1-src.tar.gzrm -rf apache-nutch-2.3.1-src.tar.gzmv apache-nutch-2.3.1 /usr/nutch-2chmod -R 777 /usr/nutch-2wget http://www-us.apache.org/dist/ant/binaries/apache-ant-1.9.7-bin.tar.gztar xzf apache-ant-1.9.7-bin.tar.gzrm -rf apache-ant-1.9.7-bin.tar.gzmv apache-ant-1.9.7 /usr/antwget http://archive.apache.org/dist/lucene/solr/5.2.1/solr-5.2.1.tgztar xzf solr-5.2.1.tgzrm -rf solr-5.2.1.tgzmv solr-5.2.1 /usr/solrrm -rf ~/envtempcat &gt; ~/envtemp&lt;&lt;&#x27;EOF&#x27;#set JDK environmentJAVA_HOME=/usr/java/jdk1.8.0_102JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib#set ANT environmentANT_HOME=/usr/ant#set HBASE environmentHBASE_HOME=/usr/hbase#set LOCAL_NUTCH environmentNUTCH_HOME=/usr/nutch-2/runtime/local#set SOLR environmentSOLR_HOME=/usr/solr#set HADOOP environmentHADOOP_HOME=/usr/hadoopHADOOP_INSTALL=$HADOOP_HOMEHADOOP_MAPRED_HOME=$HADOOP_HOMEHADOOP_COMMON_HOME=$HADOOP_HOMEHADOOP_HDFS_HOME=$HADOOP_HOMEYARN_HOME=$HADOOP_HOMEHADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeHADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib:$HADOOP_COMMON_LIB_NATIVE_DIR&quot;PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$ANT_HOME/bin:$HBASE_HOME/bin:$NUTCH_HOME/bin:$SOLR_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbinexport JAVA_HOME JRE_HOMECLASS_PATH ANT_HOME HBASE_HOME NUTCH_HOME SOLR_HOME HADOOP_HOME HADOOP_INSTALL HADOOP_MAPRED_HOME HADOOP_COMMON_HOME HADOOP_HDFS_HOME YARN_HOME HADOOP_COMMON_LIB_NATIVE_DIR HADOOP_OPTS PATHEOFrm -rf ~/profilecp /etc/profile ~/profilecat ~/profile ~/envtemp &gt;/etc/profilerm -rf ~/envtemp ~/profilesource /etc/profilecd ~wget http://www.senra.me/nutch-solr/nutch-site.xmlwget http://www.senra.me/nutch-solr/gora.propertieswget http://www.senra.me/nutch-solr/ivy.xmlwget http://www.senra.me/nutch-solr/hbase-site.xmlwget http://www.senra.me/nutch-solr/solr.xml\\cp -a ~/nutch-site.xml /usr/nutch-2/conf/\\cp -a ~/gora.properties /usr/nutch-2/conf/\\cp -a ~/ivy.xml /usr/nutch-2/ivy/\\cp -a ~/hbase-site.xml /usr/hbase/conf/\\cp -a ~/solr.xml /usr/solr/rm -rf ~/nutch-site.xml ~/gora.properties ~/ivy.xml ~/hbase-site.xml ~/solr.xmlcd /usr/nutch-2ant runtime/usr/hbase/bin/start-hbase.sh/usr/solr/bin/solr start/usr/solr/bin/solr create_core -c demo 20号之后的大创答辩加油！争取国家级！","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.zi-c.wang/tags/markdown/"}]},{"title":"nutch-2.3.1+hbase-0.94+eclipse 环境搭建教程","slug":"nutch-2.3.1+hbase-0.94+eclipse环境搭建","date":"2016-03-08T15:52:10.000Z","updated":"2020-11-22T08:50:36.390Z","comments":true,"path":"2016/03/08/nutch-2.3.1+hbase-0.94+eclipse环境搭建/","link":"","permalink":"https://www.zi-c.wang/2016/03/08/nutch-2.3.1+hbase-0.94+eclipse%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"1.开发环境及软件版本 centos 6.7 apache-nutch-2.3.1 hbase-0.94 eclipse javaEE jdk8 2.安装并配置jdk","text":"1.开发环境及软件版本 centos 6.7 apache-nutch-2.3.1 hbase-0.94 eclipse javaEE jdk8 2.安装并配置jdk 1) 在Oracle网站wget下载jdk8jdk8_installing1wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense&#x3D;accept-securebackup-cookie&quot; http:&#x2F;&#x2F;download.oracle.com&#x2F;otn-pub&#x2F;java&#x2F;jdk&#x2F;8u73-b02&#x2F;jdk-8u73-linux-x64.tar.gz 由于Oracle需要点击accept licence的才能下载，所以必须使用下面的命令，才可以直接下载。否则下载的jdk文件将无法解压缩。 2) 配置JAVA_HOMEjdk8_installing1234mkdir&#x2F;usr&#x2F;java&#x2F;tar -zxf jdk-8u73-linux-x64.tar.gz &#x2F;&#x2F;不适用-v指令以加快解压缩速度mv jdk-8u73-linux-x64&#x2F; &#x2F;usr&#x2F;java&#x2F;vi &#x2F;etc&#x2F;profile &#x2F;&#x2F;打开vi文本编辑器编辑环境变量 按i开始编辑，在文件的末尾输入 jdk8_installing1234567 #set JDK environment JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_45JRE_HOME&#x3D;$JAVA_HOME&#x2F;jreCLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;libPATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;binexport JAVA_HOME JRE_HOMECLASS_PATH PATH 先按Esc退出编辑模式，然后输入 :wq 保存退出 jdk8_installing123source &#x2F;etc&#x2F;profile &#x2F;&#x2F;使环境生效echo $JAVA_HOME &#x2F;&#x2F;检验是否安装成功&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_45 &#x2F;&#x2F;环境生效！！！ 3.安装并配置hbase-0.941) 在hbase页面下载hbase-0.94解压缩并重命名hbase_installing12345678910111213141516171819wget http:&#x2F;&#x2F;www-eu.apache.org&#x2F;dist&#x2F;hbase&#x2F;hbase-0.94.27&#x2F;tar -zxf hbase-0.94.27&#x2F; &#x2F;&#x2F;减少输出，加快速度mv hbase-0.94.27&#x2F; hbase&#x2F; &#x2F;&#x2F;重命名，简短文件名称mv hbase&#x2F; &#x2F;usr&#x2F; &#x2F;&#x2F;将hbase&#x2F;文件夹移动到&#x2F;usr&#x2F;路径下cd &#x2F;usr&#x2F; &#x2F;&#x2F;进入&#x2F;usr目录chmod -R 777 hbase&#x2F; &#x2F;&#x2F;给hbase目录分配权限cd hbase&#x2F;vi conf&#x2F;hbase-site.xml &#x2F;&#x2F;配置hbase-site.xml文件&lt;configuration&gt;&lt;property&gt; &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;&#x2F;usr&#x2F;hbase&#x2F;hbase&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;&#x2F;name&gt; &lt;value&gt;&#x2F;usr&#x2F;hbase&#x2F;zookeeper&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 之后的nutch爬出的数据将存储到rootdir文件夹中，所以必须配置zookeeper的同理。测试是否安装成功 hbase_installing1234.&#x2F;bin&#x2F;start-hbase.sh &#x2F;&#x2F;打开hbase进程.&#x2F;bin&#x2F;hbase shell &#x2F;&#x2F;可以进入hbase命令行模式&#x2F;&#x2F;检验成功可以运行后暂时关闭hbase进程.&#x2F;stop-hbase.sh 至此hbase安装成功，hbase-0.94可以直接在本地运行，不需要hadoop集群（个人暂时是这么理解的欢迎指正） 4.安装并配置apache-nutch-2.3.11)wget下载apache-nutch-2.3.1并解压缩nutch-2_installing1234567wget http:&#x2F;&#x2F;www-eu.apache.org&#x2F;dist&#x2F;nutch&#x2F;2.3.1&#x2F;apache-nutch-2.3.1-src.tar.gz&#x2F;&#x2F;速度不够的话去官网看他给你推荐的链接tar -zxf apache-nutch-2.3.1-src.tar.gzmv apache-nutch-2.3.1&#x2F; nutch-2&#x2F;mv nutch-2&#x2F; &#x2F;usr&#x2F; &#x2F;&#x2F;移动文件cd &#x2F;usr&#x2F;chmod -R 777 nutch-2 下面开始重头戏，配置nutch文件(1)conf目录下的nutch-site.xml文件(我的配置)nutch-2_installing1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;configuration&gt;&lt;property&gt;&lt;name&gt;storage.data.store.class&lt;&#x2F;name&gt;&lt;value&gt;org.apache.gora.hbase.store.HBaseStore&lt;&#x2F;value&gt;&lt;description&gt;Default class for storing data&lt;&#x2F;description&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;plugin.includes&lt;&#x2F;name&gt; &lt;value&gt;protocol-httpclient|urlfilter-regex|index-(basic|more)|query-(basic|site|url|lang)|indexer-solr|nutch-extensionpoints|protocol-httpclient|urlfilter-regex|parse-(text|html|msexcel|msword|mspowerpoint|pdf)|summary-basic|scoring-opic|urlnormalizer-(pass|regex|basic)protocol-http|urlfilter-regex|parse-(html|tika|metatags)|index-(basic|anchor|more|metadata)&lt;&#x2F;value&gt;&lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;http.agent.name&lt;&#x2F;name&gt; &lt;value&gt;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;33.0.1750.117 Safari&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;http.agent.version&lt;&#x2F;name&gt; &lt;value&gt;537.36&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;http.robots.agents&lt;&#x2F;name&gt; &lt;value&gt;Test-Crawler&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;property&gt; &lt;name&gt;plugin.folders&lt;&#x2F;name&gt; &lt;value&gt;.&#x2F;build&#x2F;plugins&lt;&#x2F;value&gt; &lt;description&gt;Directories where nutch plugins are located. Each element may be a relative or absolute path. If absolute, it is used as is. If relative, it is searched for on the classpath.&lt;&#x2F;description&gt;&lt;&#x2F;property&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;plugin.includes&lt;&#x2F;name&gt; &lt;value&gt;protocol-http|urlfilter-regex|parse-(html|tika)|index-(basic|anchor)|urlnormalizer-(pass|regex|basic)|scoring-opic|index-anchor|index-more|languageidentifier|subcollection|feed|creativecommons|tld&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 留心plugin.folders，配置不对花式报错 (2)修改conf/gora.properties加入gora.datastore.default=org.apache.gora.hbase.store.HBaseStore之后注释掉所有其他内容 (3)修改ivy/ivy.xml文件取消注释 表示使用hbase数据库 另外regex-urlfliter.txt网页内容过滤等可以暂时不进行配置 返回nutch-2根目录 nutch-2_installing123yum -y install ant &#x2F;&#x2F;yum直接安装ant，对nutch进行搭建ant eclipseant runtime &#x2F;&#x2F;命令行操作方式构建，进入runtime&#x2F;local&#x2F;bin&#x2F;文件夹中有nutch和crawl感兴趣的关注文章结尾处推荐链接 maven资源被墙了，建议翻墙使用maven资源被墙了，建议翻墙使用maven资源被墙了，建议翻墙使用 重要的事情说三遍 安装完成之后就可以导入eclipse中了 革命尚未成功，同志仍需努力。 行百里者半九十 最后一步不认真的话可能会超级麻烦的！！（认真脸） 别忘了最后一步 在nutch根目录中新建文件夹urls/，在文件夹中新建seed.txt文件 http://www.zi-c.wang 保存退出 5.导入eclipse中（想导入idea也可以这样玩，貌似）1)创建工程java project进入eclipse-&gt;file-&gt;new-&gt;project-&gt;java project直接修改项目路径（/usr/nutch-2）点击next，在build path配置中order&amp;export选项卡，选中nutch-2/conf文件夹，单击top 2)配置run configuration点击run configurations，进入页面。右键java application，新建application命名为injectJobproject：nutch-2main class：org.apache.nutch.crawl.InjectorJob进入run configurations的arguments标签中，在Program Arguments中添加urls/seed.txt -crawlId search点击apply 同理application：generateJobmain class：org.apache.nutch.crawl.GeneratorJobarguments:-topN 10 -crawlId search application：fetcheJobmain class：org.apache.nutch.fetcher.FetcherJobarguments:-all -crawlId search -thread 10 application：parseJobmain class：org.apache.nutch.parse.ParserJobarguments:-all -crawlId search application：updatedbJobmain class：org.apache.nutch.crawl.DbUpdaterJobarguments:-all -crawlId search 3)跑起来吧！！奔放的eclipse4)查看爬取得数据nutch-2_installing12345cd &#x2F;usr&#x2F;hbase&#x2F;.&#x2F;bin&#x2F;hbase shelllist &#x2F;&#x2F;hbase指令请参考我的上一篇文章 hbase常用指令scan &#39;search_webpage&#39; &#x2F;&#x2F;灰常灰常壮观的数据闪过去了&#x3D;_+exit 成功！！！ 6.感想 搭建这套环境对我来说是很大的一个修行！！ 前前后后使用的时间可能超过50h了，真是笨死了。 耗时这么长的原因：主要是我太粗心了，很多应该完成的配置并没有实现成功，浪费了很多时间 另一方面：不会看log 现在看起来非常可笑的事情就是我的环境一旦搭建失败了首先看的是文档而不是日志，真是笨死了 同时我也终于意识到Android application中为什么强调写好log。 搭建这套环境确实提升了个人能力一大截，超级期待下一步的搜索引擎实践！！ 加油奔放的少年！！！ 7.推荐链接1.Apache Nutch Wiki2.【Nutch2.2.1基础教程之2.1】集成Nutch/Hbase/Solr构建搜索引擎之一：安装及运行【单机环境】3.在Eclipse中运行Nutch2.34.about云社区5.hbase wiki6. 杨尚川老师的nutch系列视频（虽然有点旧，但是给你仔细分析每个过程）7.Linux 使用wget 命令下载JDK的方法8.神圣网站stackoverflow，救过我无数次","categories":[],"tags":[{"name":"hbase","slug":"hbase","permalink":"https://www.zi-c.wang/tags/hbase/"},{"name":"nutch","slug":"nutch","permalink":"https://www.zi-c.wang/tags/nutch/"}]},{"title":"hbase的常用shell","slug":"hbase常用shell","date":"2016-01-20T02:43:10.000Z","updated":"2020-11-22T08:52:48.260Z","comments":true,"path":"2016/01/20/hbase常用shell/","link":"","permalink":"https://www.zi-c.wang/2016/01/20/hbase%E5%B8%B8%E7%94%A8shell/","excerpt":"1.打开hbase并进入hbase shell console $HBASE_HOME/bin/start-hbase.sh $HBASE_HOME/bin/hbase shell hbase(main)> whoami","text":"1.打开hbase并进入hbase shell console $HBASE_HOME/bin/start-hbase.sh $HBASE_HOME/bin/hbase shell hbase(main)> whoami 2.表的管理1）查看有哪些表 hbase(main)> list 2）创建表 语法：create , {NAME =&gt; , VERSIONS =&gt; } //例如：创建表t1，有两个family name：f1，f2，且版本数均为2 hbase(main)> create 't1',&#123;NAME => 'f1', VERSIONS => 2&#125;,&#123;NAME => 'f2', VERSIONS => 2&#125; 3）删除表 分两步：首先disable，然后drop //例如：删除表t1 hbase(main)> disable 't1' hbase(main)> drop 't1' 4）查看表的结构 语法：describe //例如：查看表t1的结构 hbase(main)> describe 't1' 5）修改表结构 修改表结构必须先disable 语法：alter ‘t1’, {NAME =&gt; ‘f1’}, {NAME =&gt; ‘f2’, METHOD =&gt; ‘delete’} hbase(main)> disable 'test1' hbase(main)> alter 'test1',&#123;NAME=>'body',TTL=>'15552000'&#125;,&#123;NAME=>'meta', TTL=>'15552000'&#125; hbase(main)> enable 'test1' 3.表数据的增删改查1）添加数据 语法：put ,,family:column,, //例如：给表t1的添加一行记录：rowkey是rowkey001，family name：f1，column name：col1，value：value01，timestamp：系统默认 hbase(main)> put 't1','rowkey001','f1:col1','value01' //用法比较单一。 2）查询数据a）查询某行记录 语法：get ,,[family:column,….] //例如：查询表t1，rowkey001中的f1下的col1的值 hbase(main)> get 't1','rowkey001', 'f1:col1' //或者： hbase(main)> get 't1','rowkey001', &#123;COLUMN=>'f1:col1'&#125; //查询表t1，rowke002中的f1下的所有列值 hbase(main)> get 't1','rowkey001' b）扫描表 语法：scan , {COLUMNS =&gt; [ family:column,…. ], LIMIT =&gt; num} 另外，还可以添加STARTROW、TIMERANGE和FITLER等高级功能 //例如：扫描表t1的前5条数据 hbase(main)&gt; scan ‘t1’,{LIMIT=&gt;5} c）查询表中的数据行数 语法：count , {INTERVAL =&gt; intervalNum, CACHE =&gt; cacheNum} INTERVAL设置多少行显示一次及对应的rowkey，默认1000；CACHE每次去取的缓存区大小，默认是10，调整该参数可提高查询速度 //例如，查询表t1中的行数，每100条显示一次，缓存区为500 hbase(main)> count 't1', &#123;INTERVAL => 100, CACHE => 500&#125; 3）删除数据a )删除行中的某个列值 语法：delete , , family:column , ,必须指定列名 //例如：删除表t1，rowkey001中的f1:col1的数据 hbase(main)> delete 't1','rowkey001','f1:col1' //注：将删除改行f1:col1列所有版本的数据 b )删除行 语法：deleteall , , family:column , ，可以不指定列名，删除整行数据 //例如：删除表t1，rowk001的数据 hbase(main)> deleteall 't1','rowkey001' c）删除表中的所有数据 语法： truncate 其具体过程是：disable table -&gt; drop table -&gt; create table //例如：删除表t1的所有数据 hbase(main)> truncate 't1'","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.zi-c.wang/tags/markdown/"},{"name":"hbase","slug":"hbase","permalink":"https://www.zi-c.wang/tags/hbase/"}]},{"title":"可能经常用到的markdown语法和标签插件","slug":"可能经常用到的markdown语法和标签插件","date":"2016-01-20T02:43:10.000Z","updated":"2020-11-22T08:50:48.340Z","comments":true,"path":"2016/01/20/可能经常用到的markdown语法和标签插件/","link":"","permalink":"https://www.zi-c.wang/2016/01/20/%E5%8F%AF%E8%83%BD%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84markdown%E8%AF%AD%E6%B3%95%E5%92%8C%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/","excerpt":"摘要 本文没有系统介绍markdown语法和标签插件，而是仅仅列举的可能经常使用的markdown语法和标签插件样式 l&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ol&gt;“ 都可以表示分点 First Second Third false","text":"摘要 本文没有系统介绍markdown语法和标签插件，而是仅仅列举的可能经常使用的markdown语法和标签插件样式 l&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ol&gt;“ 都可以表示分点 First Second Third false 关于换行 单一段落( &lt;p&gt;) 用一个空白行 连续两个空格 会变成一个 &lt;br&gt; 连续3个符号，然后是空行，表示 hr横线 关于插入代码 可以是使用&lt;pre&gt;&lt;code&gt;code&lt;/code&gt;&lt;/pre&gt;形式插入代码，不过比较简陋 cout < \"Hello World!!\" < endl;","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.zi-c.wang/tags/markdown/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://www.zi-c.wang/categories/python/"},{"name":"rss","slug":"python/rss","permalink":"https://www.zi-c.wang/categories/python/rss/"},{"name":"github","slug":"python/rss/github","permalink":"https://www.zi-c.wang/categories/python/rss/github/"},{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"},{"name":"raspberryPi","slug":"kernel/raspberryPi","permalink":"https://www.zi-c.wang/categories/kernel/raspberryPi/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/categories/linux/"},{"name":"bash","slug":"linux/bash","permalink":"https://www.zi-c.wang/categories/linux/bash/"},{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/categories/eBPF/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/categories/leetcode/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"linux","slug":"linux","permalink":"https://www.zi-c.wang/tags/linux/"},{"name":"compile","slug":"compile","permalink":"https://www.zi-c.wang/tags/compile/"},{"name":"c","slug":"c","permalink":"https://www.zi-c.wang/tags/c/"},{"name":"programming","slug":"programming","permalink":"https://www.zi-c.wang/tags/programming/"},{"name":"stack","slug":"stack","permalink":"https://www.zi-c.wang/tags/stack/"},{"name":"硬件","slug":"硬件","permalink":"https://www.zi-c.wang/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"装机","slug":"装机","permalink":"https://www.zi-c.wang/tags/%E8%A3%85%E6%9C%BA/"},{"name":"Driver","slug":"Driver","permalink":"https://www.zi-c.wang/tags/Driver/"},{"name":"Linux","slug":"Linux","permalink":"https://www.zi-c.wang/tags/Linux/"},{"name":"vm","slug":"vm","permalink":"https://www.zi-c.wang/tags/vm/"},{"name":"exploit","slug":"exploit","permalink":"https://www.zi-c.wang/tags/exploit/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"},{"name":"binarytree","slug":"binarytree","permalink":"https://www.zi-c.wang/tags/binarytree/"},{"name":"python","slug":"python","permalink":"https://www.zi-c.wang/tags/python/"},{"name":"rss","slug":"rss","permalink":"https://www.zi-c.wang/tags/rss/"},{"name":"github","slug":"github","permalink":"https://www.zi-c.wang/tags/github/"},{"name":"NJU","slug":"NJU","permalink":"https://www.zi-c.wang/tags/NJU/"},{"name":"raspberryPi","slug":"raspberryPi","permalink":"https://www.zi-c.wang/tags/raspberryPi/"},{"name":"bash","slug":"bash","permalink":"https://www.zi-c.wang/tags/bash/"},{"name":"tool","slug":"tool","permalink":"https://www.zi-c.wang/tags/tool/"},{"name":"lwn.net","slug":"lwn-net","permalink":"https://www.zi-c.wang/tags/lwn-net/"},{"name":"io_uring","slug":"io-uring","permalink":"https://www.zi-c.wang/tags/io-uring/"},{"name":"eBPF","slug":"eBPF","permalink":"https://www.zi-c.wang/tags/eBPF/"},{"name":"markdown","slug":"markdown","permalink":"https://www.zi-c.wang/tags/markdown/"},{"name":"hbase","slug":"hbase","permalink":"https://www.zi-c.wang/tags/hbase/"},{"name":"nutch","slug":"nutch","permalink":"https://www.zi-c.wang/tags/nutch/"}]}