{"meta":{"title":"purplewall1206 blog","subtitle":"","description":"something about kernel & programming","author":"purplewall1206","url":"https://www.zi-c.wang","root":"/"},"pages":[{"title":"","date":"2020-11-15T10:43:54.047Z","updated":"2020-11-15T10:43:54.047Z","comments":true,"path":"404.html","permalink":"https://www.zi-c.wang/404.html","excerpt":"","text":"+layout: false +--- 404"},{"title":"about","date":"2020-11-15T10:38:51.000Z","updated":"2020-11-15T10:38:51.790Z","comments":true,"path":"about/index.html","permalink":"https://www.zi-c.wang/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-11-15T10:40:07.000Z","updated":"2020-11-15T10:43:51.827Z","comments":false,"path":"categories/index.html","permalink":"https://www.zi-c.wang/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-15T10:39:13.000Z","updated":"2020-11-15T10:43:56.047Z","comments":false,"path":"tags/index.html","permalink":"https://www.zi-c.wang/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"内核近期改变","slug":"内核近期改变","date":"2020-11-15T11:09:13.000Z","updated":"2020-11-15T11:09:48.790Z","comments":true,"path":"2020/11/15/内核近期改变/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/%E5%86%85%E6%A0%B8%E8%BF%91%E6%9C%9F%E6%94%B9%E5%8F%98/","excerpt":"","text":"内核近期改变 内核近期改变 ioctl 1.原始版本的ioctl 2.内核改进后的ioctl 3.在编写过程中的处理办法 4. 原因分析 异步I/O read_iter 1.具体变化 2.原因分析 3.问题 timer计时器发生改变 block 驱动在5.0后进行了非常大的变化 原因 blk-mq 设计了两层队列 在架构层面 具体到函数 内核计时接口发生变化 系统调用初始化接口变化（未解决） 文件系统减少定义数量 （未解决） jprobe 被取消 ioctl1.原始版本的ioctl1int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long); 2.内核改进后的ioctl123long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);long (*compat_ioctl) (struct file *, unsigned int, unsigned long); 3.在编写过程中的处理办法 将原先的写的 ioctl 函数声明给改成下面的 unlocked_ioctl 或者 compat_ioctl, 在 file_operations 结构体的初始化中也是一样. 修改为unlocked_ioctl 或者 compat_ioctl, 注意参数的兼容性问题, 新的ioctl() 接口没有 struct inode* 参数, 如果ioctl 接口中使用了 inode, 因此需要通过其他方式获取 inode 123456789101112131415161718192021#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36)static int XXX_ioctl( struct inode *indoe, struct file *filp, unsigned int cmd, unsigned long arg)&#123;#else&#x2F;&#x2F;long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);&#x2F;&#x2F;long (*compat_ioctl) (struct file *, unsigned int cmd, unsigned long arg)static long XXX_unlocked_ioctl( struct file *filp, unsigned int cmd, unsigned long arg)&#123; &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;f_dentry-&gt;d_inode; &#x2F;&#x2F;struct inode *inode &#x3D; filp-&gt;d_inode; struct inode *inode &#x3D; inode &#x3D; file_inode(filp);#endif &#x2F;* 此处是ioctl() 函数结构的具体实现 *&#x2F;&#125; 同理，file_operations中也进行同样修改。 123456789101112static struct file_operations fpga_fops &#x3D; &#123; .owner &#x3D; THIS_MODULE, .open &#x3D; fpga_open, .read &#x3D; fpga_read, .write &#x3D; fpga_write, .llseek &#x3D; fpga_llseek,#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 36) .ioctl &#x3D; XXX_ioctl,#else .unlocked_ioctl &#x3D; XXX_unlocked_ioctl,#endif&#125;; 4. 原因分析file_operations (include/linux/fs.h) 结构变化,ioctl本身并不安全，且之前的ioctl使用了大内核锁延迟太大，因此进行修改。具体内容见The new way of ioctl() 异步I/O read_iter1.具体变化file_operations (include/linux/fs.h) 结构变化，导致 read_iter 和 write_iter 负责设备驱动的异步读写，取代了之前的 aio_read 和 aio_write,只需要将资料中二者进行转换即可。 2.原因分析The iov_iter interface iov_iter 功能增强了，并且试图合并 read(write)_iter 和 splice_read(write)，不过截至2020年5月13日来看这俩似乎还存在着 3.问题fs/ramfs/file-mmu.c 中为什么 file_operations 里面没有定义 read 和 write， 而只有异步I/O。 timer计时器发生改变Improving the kernel timers API用 timer_setup 替换了 init_timer,替换内核版本为4.14(2017)，属于较新的替换 1234567891011#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0) init_timer(&amp;dev-&gt;getIntrTimer); dev-&gt;getIntrTimer.data &#x3D; (unsigned long) dev; dev-&gt;getIntrTimer.function &#x3D; GetIntrTimerCallback; &#x2F;* ... *&#x2F; add_timer(&amp;dev-&gt;getIntrTimer);#else timer_setup(&amp;dev-&gt;getIntrTimer, GetIntrTimerCallback, 0); &#x2F;* the third argument may include TIMER_* flags *&#x2F; &#x2F;* ... *&#x2F;#endif callback function的变化 参数类型发生变化，否则会编译失败 12345678910#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,14,0)void GetIntrTimerCallback(unsigned long devAddr)&#123; myDevice *dev &#x3D; (myDevice *) devAddr;#elsevoid GetIntrTimerCallback(struct timer_list *t)&#123; myDevice *dev &#x3D; from_timer(dev, t, getIntrTimer);#endif &#x2F;* Do something with &quot;dev&quot; *&#x2F; block 驱动在5.0后进行了非常大的变化In kernel V5 blk_fetch_request() and blk_init_queue() gone. Now What? Linux Kernel 5.0 – we write Simple Block Device under blk-mq block: remove __bio_kmap_atomic 内核工匠 公众号 Multiqueue架构分析 block 驱动在5.0后进行了非常大的变化 原因是使用了 multi-queue block layer 即 blk-mq 完全取代了之前的 blk-sq（single-queue），因为从前的IO速度瓶颈在硬件方面，因此可以使用单一队列，即使多个cpu竞争自旋锁获取队列写入权限依旧不过分影响性能。而最近的高IOPS（io per second）硬件逐渐增多比如ssd，nvme等硬件设备开始大量使用，那么从前的single queue在高IOPS场景下80% cpu时间耗费在锁获取上了，因此设计了新的blk-mq 获取锁仅占用 3% cpu时间。 blk-mq 设计了两层队列 首先为每个cpu分配了一个软件暂存队列（software staging queue），负责完成bio 提交/完成处理，IO请求暂存（合并、排序等）、IO请求标记、调度、记账（和新的IO调度算法BFS有关） 硬件派发队列（Hardware Dispatch Queue） 为每个硬件队列分派一个硬件派发队列，负责存放软件队列向硬件派发的IO请求，一个和多个软件队列和一个硬件队列存在固定映射关系 在架构层面mq 将 request 和 tag 绑定，request内存分配在块设备驱动初始化时完成（调用blk_mq_alloc_tag_set）避免IO时分配request内存带来消耗 tag作为request（static_rqs/rqs）的索引。 具体到函数有 blk_fetch_request , __blk_end_request_cur ,blk_init_queue, __bio_kmap_atomic(bio, iter) , __bio_kunmap_atomic(buffer) 等 其中 取代 __bio_kmap_atomic(bio, iter) , __bio_kunmap_atomic(buffer) 如下 123456789- char *buffer &#x3D; __bio_kmap_atomic(bio, iter);+ char *buffer &#x3D; kmap_atomic(bvec.bv_page) + bvec.bv_offset; unsigned len &#x3D; bvec.bv_len &gt;&gt; SECTOR_SHIFT; simdisk_transfer(dev, sector, len, buffer, bio_data_dir(bio) &#x3D;&#x3D; WRITE); sector +&#x3D; len;- __bio_kunmap_atomic(buffer);+ kunmap_atomic(buffer) 除此之外 BLK_MQ_F_SG_MERGE 和 QUEUE_FLAG_NO_SG_MERGE 都可以被省略了block: kill BLK_MQ_F_SG_MERGE 12- lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;+ lo-&gt;tag_set.flags &#x3D; BLK_MQ_F_SHOULD_MERGE; 内核计时接口发生变化64位系统中,由于2038问题 时间戳 timespec 在 inode数据结构中的i_*time 中弃用，转而使用 timespec64 相应的 getnstimeofday 等函数也被弃用， 转而使用 ktime_get_ts64(struct timespec64 *ts) 等函数获取时间，另外需要注意 这个函数必须使用 GPL协议才能成功加载。 详见内核时间api文件，ktime accessors 最新设计的时间数据结构为 ktime_t 获取方式为 ktime_t ktime_get(void) 系统调用初始化接口变化（未解决）系统调用初始化接口代码越变越少，而且有点难以理解，除了在arch/x86/entry/syscall 目录下定义之外，还用了同目录下的脚本直接生成了ni代码 具体的解决办法是直接ftrace跟踪一波，看看syscall最新的调用路径 文件系统减少定义数量 （未解决）文件系统减少了大量file_operations定义数量，例如 aio_read aio_write 等异步代码直接被省略掉，read 和 write 接口基本也不定义了， 似乎使用了 read_iter 和 write_iter 替代了前两类接口 具体原因还没搞清楚，但是在 [V5,17/30] fs: use read_iter and write_iter rather than aio_read and aio_write 中显示 aio被明确删除掉，用iter替代。 此外 file_operations 当中的 readdir 等接口也被取消，直接由read/read_iter和 iterate 替代,iterate基本上可以理解为负责执行ls命令， filldentry_t 由 dir_context 替代。 jprobe 被取消在 kprobe中只剩下kprobe和kretprobe，jprobe及相关的一套函数被取消，替代方式如下： /source/samples/kprobes/kprobe_example.c 和 /source/samples/kprobes/kretprobe_example.c 中示例 使用kprobe中的handler_pre和handler_post替代。","categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"}]},{"title":"dynamicprogramming.md","slug":"dynamicprogramming-md","date":"2020-11-15T10:36:17.000Z","updated":"2020-11-15T10:57:20.564Z","comments":true,"path":"2020/11/15/dynamicprogramming-md/","link":"","permalink":"https://www.zi-c.wang/2020/11/15/dynamicprogramming-md/","excerpt":"","text":"动态规划 Dynamic Programming动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 tricky一般不要求记录解空间具体内容的，但是看起来好像需要从所有解中提取结果的都可以试试看动态规划，设计不好dp不妨试试看从0到i的物品的xxx，dp有可能是1维2维甚至3维。 如果要求解空间具体内容的上backtrack也不错，而且dp的题也可以用backtrack或者dfs碰碰运气。 硬币找零问题 coin changeleetcode-322 You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1:Input: coins = [1, 2, 5], amount = 11Output: 3Explanation: 11 = 5 + 5 + 1 解析：每种coins的数量是不限的，因此假设dp[i]是从0到金额i，所需要的最小硬币的数量初始化假设dp值均为 amount+1dp[i] = min(dp[i-coin[x]]+1, dp[i])循环遍历每个coin的值，获得dp最后的值，即相应的结果 123456789101112131415161718int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; &#x2F;&#x2F; dp[i] &#x3D; min(dp[i-coink]+1, dp[i]) if (amount &#x3D;&#x3D; 0) return 0; vector&lt;int&gt; dp(amount+1, amount+1); &#x2F;&#x2F; 此处初始化为amount+1，便于之后取最小值 dp[0] &#x3D; 0; for (int i &#x3D; 1;i &lt;&#x3D; amount;i++) &#123; for (int j &#x3D; 0;j &lt; coins.size();j++) &#123; if (i &gt;&#x3D; coins[j]) &#123; &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; coins[j] &lt;&lt;&quot; &quot; &lt;&lt; dp[i] &lt;&lt; &quot; &quot;; dp[i] &#x3D; min(dp[i], dp[i-coins[j]]+1); &#x2F;&#x2F; cout &lt;&lt; dp[i] &lt;&lt; endl; &#125; &#125; &#125; return (dp[amount] &#x3D;&#x3D; amount+1) ? -1 : dp[amount]; &#125; 01背包问题01背包是解决什么问题？ 答：当书包容量大小固定，面对1堆重量固定而且带有价格的物品。在不超出包容量前提下，选择那些物品使包里物品总价值最大。 其中代表重量的数组 w[0…i….n], 代表价值的数组 v[0…i…n]。 一般可以通过画表格确定解空间（还没研究明白） 动态规划的思路是设计 dp[N+1][S+1] 其中N代表物品数量，S代表背包总重量，即在N件物品，重量为S的情况下，物品的价值多大当w[i-1] &lt; j(当前剩余重量)时间分别代表装入或不装入dp[i][j] = min(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1]) 例题 target sumleetcode-494 You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1:Input: nums is [1, 1, 1, 1, 1], S is 3.Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. 根据题意可以假设集合nums有两个真子集A,B，其中集合A表示所有为正数的集合，集合B表示所有未负数的集合，目标值未target，那么有 123sum(A) + sum(B) &#x3D; sum(nums)sum(A) - sum(B) &#x3D; target2 * sum(A) &#x3D; sum(nums) + target 由上述递推公式将该问题转化为01背包问题，题解如下 123456789101112131415161718192021222324252627int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n &#x3D; nums.size(); long sum &#x3D; 0; for (int i : nums) sum +&#x3D; i; if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123; return 0; &#125; S &#x3D; (sum + S) &#x2F; 2; &#x2F;&#x2F; 传统dp &#x2F;&#x2F; 对于dp(i,j)就表示可选物品为i到n且背包容量为j(总重量)时背包中所放物品的最大价值 vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(S+1, 0)); &#x2F;&#x2F; 0个数和为0的个数为1 dp[0][0] &#x3D; 1; for (int i &#x3D; 1;i &lt;&#x3D;n;i++ ) &#123; for (int j &#x3D; 0;j &lt; S+1;j++) &#123; if(j-nums[i-1] &lt; 0)&#x2F;&#x2F;背包容量不足，不能放入第i个物品 &#123; dp[i][j] &#x3D; dp[i-1][j];&#x2F;&#x2F;其实就是表格的左边界 &#125; else &#123; dp[i][j] &#x3D; dp[i-1][j-nums[i-1]] + dp[i-1][j];&#x2F;&#x2F;装入第i个物品或者不装入 &#125; &#125; &#125; return dp[n][S]; &#125; 根据上述代码我们发现 dp[i][j] = dp[i-1][...] 的关系，即i至于i-1有关系，因此我们可以减少一维向量，用一维向量记录上一轮的运算结果。 12345678910111213141516171819int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n &#x3D; nums.size(); long sum &#x3D; 0; for (int i : nums) sum +&#x3D; i; if ((S + sum) % 2 &#x3D;&#x3D; 1 || S &gt; sum) &#123; return 0; &#125; S &#x3D; (sum + S) &#x2F; 2; &#x2F;&#x2F; dp优化 vector&lt;int&gt; dp(S+1, 0); dp[0] &#x3D; 1; for (int i &#x3D; 0;i &lt; n;i++) &#123; for (int j &#x3D; S;j &gt;&#x3D; nums[i];j--) &#123; dp[j] +&#x3D; dp[j-nums[i]]; &#125; &#125; return dp[S]; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-14T08:54:12.760Z","updated":"2020-11-14T08:54:12.760Z","comments":true,"path":"2020/11/14/hello-world/","link":"","permalink":"https://www.zi-c.wang/2020/11/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/categories/kernel/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/categories/leetcode/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"https://www.zi-c.wang/tags/kernel/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.zi-c.wang/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.zi-c.wang/tags/algorithm/"}]}